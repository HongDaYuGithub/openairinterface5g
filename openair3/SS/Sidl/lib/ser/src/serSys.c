/*
 * Copyright 2022 Sequans Communications.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <string.h>
#include "serSys.h"
#include "serMem.h"
#include "serUtils.h"

static int _serSysEncPmchLogicalChannel_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PmchLogicalChannel_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->Pmch_InfoIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->LogicalChannelIdentity, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMRB_Identity_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MRB_Identity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->Mbsfn_AreaId, _lidx);
	_serSysEncPmchLogicalChannel_Type(_buffer, _size, _lidx, &p->PmchLogicalChannel);

	return SIDL_STATUS_OK;
}

static int _serSysEncMCC_PLMN_Identity_mcc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MCC_PLMN_Identity_mcc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_Identity(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMCC_PLMN_Identity_mcc_Optional(_buffer, _size, _lidx, &p->mcc);
	HTON_32(&_buffer[*_lidx], p->mnc.d, _lidx);
	for (size_t i1 = 0; i1 < p->mnc.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->mnc.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTMGI_r9_plmn_Id_r9_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TMGI_r9_plmn_Id_r9_Value* p, enum TMGI_r9_plmn_Id_r9_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TMGI_r9_plmn_Id_r9_plmn_Index_r9) {
		HTON_8(&_buffer[*_lidx], p->plmn_Index_r9, _lidx);
	}
	if (d == TMGI_r9_plmn_Id_r9_explicitValue_r9) {
		_serSysEncPLMN_Identity(_buffer, _size, _lidx, &p->explicitValue_r9);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTMGI_r9_plmn_Id_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TMGI_r9_plmn_Id_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTMGI_r9_plmn_Id_r9_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncTMGI_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TMGI_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTMGI_r9_plmn_Id_r9(_buffer, _size, _lidx, &p->plmn_Id_r9);
	for (size_t i1 = 0; i1 < 3; i1++) {
		HTON_8(&_buffer[*_lidx], p->serviceId_r9[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncO1_MBMSSessionInfo_r13_sessionId_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O1_MBMSSessionInfo_r13_sessionId_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMSSessionInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMSSessionInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTMGI_r9(_buffer, _size, _lidx, &p->tmgi_r13);
	_serSysEncO1_MBMSSessionInfo_r13_sessionId_r13_Optional(_buffer, _size, _lidx, &p->sessionId_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSC_MRB_Identity_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SC_MRB_Identity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMBMSSessionInfo_r13(_buffer, _size, _lidx, &p->MbmsSessionInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearerId_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RadioBearerId_Type_Value* p, enum RadioBearerId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RadioBearerId_Type_Srb) {
		HTON_8(&_buffer[*_lidx], p->Srb, _lidx);
	}
	if (d == RadioBearerId_Type_Drb) {
		HTON_8(&_buffer[*_lidx], p->Drb, _lidx);
	}
	if (d == RadioBearerId_Type_Mrb) {
		_serSysEncMRB_Identity_Type(_buffer, _size, _lidx, &p->Mrb);
	}
	if (d == RadioBearerId_Type_ScMrb) {
		_serSysEncSC_MRB_Identity_Type(_buffer, _size, _lidx, &p->ScMrb);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearerId_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioBearerId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRadioBearerId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncQosFlow_Identification_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct QosFlow_Identification_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->PDU_SessionId, _lidx);
	HTON_32(&_buffer[*_lidx], p->QFI, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRoutingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RoutingInfo_Type_Value* p, enum RoutingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RoutingInfo_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == RoutingInfo_Type_RadioBearerId) {
		_serSysEncRadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	}
	if (d == RoutingInfo_Type_QosFlow) {
		_serSysEncQosFlow_Identification_Type(_buffer, _size, _lidx, &p->QosFlow);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRoutingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RoutingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRoutingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemFrameNumberInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemFrameNumberInfo_Type_Value* p, enum SystemFrameNumberInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemFrameNumberInfo_Type_Number) {
		HTON_16(&_buffer[*_lidx], p->Number, _lidx);
	}
	if (d == SystemFrameNumberInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemFrameNumberInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSubFrameInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SubFrameInfo_Type_Value* p, enum SubFrameInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubFrameInfo_Type_Number) {
		HTON_8(&_buffer[*_lidx], p->Number, _lidx);
	}
	if (d == SubFrameInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSubFrameInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubFrameInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSubFrameInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncHyperSystemFrameNumberInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const HyperSystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSlotOffset_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SlotOffset_Type_Value* p, enum SlotOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotOffset_Type_Numerology0) {
		HTON_8(&_buffer[*_lidx], p->Numerology0, _lidx);
	}
	if (d == SlotOffset_Type_Numerology1) {
		HTON_8(&_buffer[*_lidx], p->Numerology1, _lidx);
	}
	if (d == SlotOffset_Type_Numerology2) {
		HTON_8(&_buffer[*_lidx], p->Numerology2, _lidx);
	}
	if (d == SlotOffset_Type_Numerology3) {
		HTON_8(&_buffer[*_lidx], p->Numerology3, _lidx);
	}
	if (d == SlotOffset_Type_Numerology4) {
		HTON_8(&_buffer[*_lidx], p->Numerology4, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSlotOffset_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SlotOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSlotOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSlotTimingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SlotTimingInfo_Type_Value* p, enum SlotTimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotTimingInfo_Type_SlotOffset) {
		_serSysEncSlotOffset_Type(_buffer, _size, _lidx, &p->SlotOffset);
	}
	if (d == SlotTimingInfo_Type_FirstSlot) {
		HTON_8(&_buffer[*_lidx], p->FirstSlot, _lidx);
	}
	if (d == SlotTimingInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSlotTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SlotTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSlotTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSubFrameTiming_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubFrameTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->SFN);
	_serSysEncSubFrameInfo_Type(_buffer, _size, _lidx, &p->Subframe);
	_serSysEncHyperSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->HSFN);
	_serSysEncSlotTimingInfo_Type(_buffer, _size, _lidx, &p->Slot);

	return SIDL_STATUS_OK;
}

static int _serSysEncTimingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TimingInfo_Type_Value* p, enum TimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TimingInfo_Type_SubFrame) {
		_serSysEncSubFrameTiming_Type(_buffer, _size, _lidx, &p->SubFrame);
	}
	if (d == TimingInfo_Type_Now) {
		HTON_8(&_buffer[*_lidx], p->Now, _lidx);
	}
	if (d == TimingInfo_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncReqAspControlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReqAspControlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->CnfFlag, _lidx);
	HTON_8(&_buffer[*_lidx], p->FollowOnFlag, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRlcBearerRouting_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RlcBearerRouting_Type_Value* p, enum RlcBearerRouting_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RlcBearerRouting_Type_EUTRA) {
		{
			size_t _tmp = (size_t)p->EUTRA;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == RlcBearerRouting_Type_NR) {
		{
			size_t _tmp = (size_t)p->NR;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == RlcBearerRouting_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRlcBearerRouting_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RlcBearerRouting_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRlcBearerRouting_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRlcBearerRouting_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncReqAspCommonPart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReqAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serSysEncReqAspControlInfo_Type(_buffer, _size, _lidx, &p->ControlInfo);
	_serSysEncRlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional(_buffer, _size, _lidx, &p->RlcBearerRouting);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellConfigCapability_Type_ConfigCapability_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellConfigCapability_Type_ConfigCapability_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->subframeAssignment;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->specialSubframePatterns;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->specialSubframePatterns_v1130;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1130_tdd_Config_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1130_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->R8);
	_serSysEncTDD_Config_v1130_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TDD_Config_Type_Value* p, enum TDD_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TDD_Config_Type_R8andLater) {
		_serSysEncTDD_Config_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTDD_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEUTRA_TDD_Info_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EUTRA_TDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_Type(_buffer, _size, _lidx, &p->Configuration);

	return SIDL_STATUS_OK;
}

static int _serSysEncEUTRA_HalfDuplexFDD_Info_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EUTRA_HalfDuplexFDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncEUTRA_RAT_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EUTRA_RAT_Type_Value* p, enum EUTRA_RAT_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EUTRA_RAT_Type_FDD) {
		HTON_8(&_buffer[*_lidx], p->FDD, _lidx);
	}
	if (d == EUTRA_RAT_Type_TDD) {
		_serSysEncEUTRA_TDD_Info_Type(_buffer, _size, _lidx, &p->TDD);
	}
	if (d == EUTRA_RAT_Type_HalfDuplexFDD) {
		_serSysEncEUTRA_HalfDuplexFDD_Info_Type(_buffer, _size, _lidx, &p->HalfDuplexFDD);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEUTRA_RAT_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EUTRA_RAT_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEUTRA_RAT_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellIdentity_eNB_CellId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellIdentity_eNB_CellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 28; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_TcOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_TcOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint8_t_TcOffset_Optional(_buffer, _size, _lidx, &p->TcOffset);
	HTON_32(&_buffer[*_lidx], p->Tcell, _lidx);
	HTON_16(&_buffer[*_lidx], p->SfnOffset, _lidx);
	HTON_16(&_buffer[*_lidx], p->HsfnOffset, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCommonStaticCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CommonStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEUTRA_RAT_Type(_buffer, _size, _lidx, &p->RAT);
	HTON_16(&_buffer[*_lidx], p->PhysicalCellId, _lidx);
	_serSysEncCellIdentity_eNB_CellId_Optional(_buffer, _size, _lidx, &p->eNB_CellId);
	HTON_32(&_buffer[*_lidx], p->EutraBand, _lidx);
	_serSysEncCellTimingInfo_Type(_buffer, _size, _lidx, &p->CellTimingInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncDownlinkStaticCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DownlinkStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->Earfcn, _lidx);
	{
		size_t _tmp = (size_t)p->Bandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->RBSize;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->CyclicPrefix;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkStaticCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->Earfcn, _lidx);
	{
		size_t _tmp = (size_t)p->Bandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->CyclicPrefix;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkStaticCellInfo_Type_Uplink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkStaticCellInfo_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkStaticCellInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncStaticCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct StaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCommonStaticCellInfo_Type(_buffer, _size, _lidx, &p->Common);
	_serSysEncDownlinkStaticCellInfo_Type(_buffer, _size, _lidx, &p->Downlink);
	_serSysEncUplinkStaticCellInfo_Type_Uplink_Optional(_buffer, _size, _lidx, &p->Uplink);

	return SIDL_STATUS_OK;
}

static int _serSysEncStaticCellInfo_Type_StaticCellInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct StaticCellInfo_Type_StaticCellInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncStaticCellInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->antennaPortsCount;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoCommon_Type_Value* p, enum AntennaInfoCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoCommon_Type_R8) {
		_serSysEncAntennaInfoCommon(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaPortInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaPortInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->PowerAttenuation, _lidx);
	HTON_8(&_buffer[*_lidx], p->PropagationDelay, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaPortConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaPortConfig_Type_Value* p, enum AntennaPortConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaPortConfig_Type_AddOrReconfigure) {
		_serSysEncAntennaPortInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
	}
	if (d == AntennaPortConfig_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaPortConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaPortConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaPortConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaPort_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaPort_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->Id, _lidx);
	_serSysEncAntennaPortConfig_Type(_buffer, _size, _lidx, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serSysEncDownlinkAntennaGroupConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DownlinkAntennaGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoCommon_Type(_buffer, _size, _lidx, &p->AntennaInfoCommon);
	HTON_32(&_buffer[*_lidx], p->AntennaPort.d, _lidx);
	for (size_t i1 = 0; i1 < p->AntennaPort.d; i1++) {
		_serSysEncAntennaPort_Type(_buffer, _size, _lidx, &p->AntennaPort.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DownlinkAntennaGroupConfig_Type_AntennaGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDownlinkAntennaGroupConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratio_Type_RA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratio_Type_RA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratio_Type_RB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratio_Type_RB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratio_Type_RA_Optional(_buffer, _size, _lidx, &p->RA);
	_serSysEncToRS_EPRE_Ratio_Type_RB_Optional(_buffer, _size, _lidx, &p->RB);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPbchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PbchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPbchConfig_Type_Pbch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPbchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCfiValue_Type_CfiValue_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CfiValue_Type_CfiValue_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcfichConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PcfichConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCfiValue_Type_CfiValue_Optional(_buffer, _size, _lidx, &p->CfiValue);
	_serSysEncToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcfichConfig_Type_Pcfich_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PcfichConfig_Type_Pcfich_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPcfichConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPHICH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PHICH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->phich_Duration;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->phich_Resource;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPHICH_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PHICH_Config_Type_Value* p, enum PHICH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PHICH_Config_Type_R8) {
		_serSysEncPHICH_Config(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPHICH_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PHICH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPHICH_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPHICH_Config_Type_PhichConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PHICH_Config_Type_PhichConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPHICH_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhichConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhichConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPHICH_Config_Type_PhichConfig_Optional(_buffer, _size, _lidx, &p->PhichConfig);
	_serSysEncToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhichConfig_Type_Phich_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhichConfig_Type_Phich_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPhichConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_CommonSearchSpaceFormat_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_CommonSearchSpaceFormat_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_UeSpecificSearchSpaceFormat_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_UeSpecificSearchSpaceFormat_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCCE_StartIndex_DL_UL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CCE_StartIndex_DL_UL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->CCE_StartIndex_DL, _lidx);
	HTON_32(&_buffer[*_lidx], p->CCE_StartIndex_UL, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchCandidate_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchCandidate_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->RNTI[i2], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->CCE_StartIndexList.d, _lidx);
	for (size_t i2 = 0; i2 < p->CCE_StartIndexList.d; i2++) {
		_serSysEncCCE_StartIndex_DL_UL_Type(_buffer, _size, _lidx, &p->CCE_StartIndexList.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchCandidateList_Type_PdcchCandidateList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchCandidateList_Type_PdcchCandidateList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPdcchCandidate_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint8_t_CommonSearchSpaceFormat_Optional(_buffer, _size, _lidx, &p->CommonSearchSpaceFormat);
	_serSysEncUint8_t_UeSpecificSearchSpaceFormat_Optional(_buffer, _size, _lidx, &p->UeSpecificSearchSpaceFormat);
	_serSysEncPdcchCandidateList_Type_PdcchCandidateList_Optional(_buffer, _size, _lidx, &p->PdcchCandidateList);
	_serSysEncToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchConfig_Type_Pdcch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchConfig_Type_Pdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPdcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_RachResponse_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_RachResponse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdschRelativeTxPower_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdschRelativeTxPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_RachResponse_Optional(_buffer, _size, _lidx, &p->RachResponse);
	_serSysEncToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional(_buffer, _size, _lidx, &p->BcchOnPdsch);
	_serSysEncToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional(_buffer, _size, _lidx, &p->PcchOnPdsch);
	_serSysEncToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional(_buffer, _size, _lidx, &p->CcchOnPdsch);
	_serSysEncToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional(_buffer, _size, _lidx, &p->DcchDtchOnPdsch);
	_serSysEncToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional(_buffer, _size, _lidx, &p->OcngOnPdsch);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdschRelativeTxPower_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdschRelativeTxPower_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPdschRelativeTxPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeA_r13);
	_serSysEncPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeB_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdschConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPdschRelativeTxPower_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serSysEncPDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional(_buffer, _size, _lidx, &p->PDSCH_ConfigCommon);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdschConfig_Type_Pdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPdschConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPrimarySyncSignal_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PrimarySyncSignal_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPrimarySyncSignal_Type_Pss_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PrimarySyncSignal_Type_Pss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPrimarySyncSignal_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecondarySyncSignal_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecondarySyncSignal_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecondarySyncSignal_Type_Sss_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecondarySyncSignal_Type_Sss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSecondarySyncSignal_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10_csi_RS_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_r10_csi_RS_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->antennaPortsCount_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->resourceConfig_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeConfig_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_C_r10, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10_csi_RS_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_Config_r10_csi_RS_r10_Value* p, enum CSI_RS_Config_r10_csi_RS_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_Config_r10_csi_RS_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_Config_r10_csi_RS_r10_setup) {
		_serSysEncCSI_RS_Config_r10_csi_RS_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10_csi_RS_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_r10_csi_RS_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_Config_r10_csi_RS_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_Config_r10_csi_RS_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncZeroTxPowerCSI_RS_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ZeroTxPowerCSI_RS_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->zeroTxPowerResourceConfigList_r12[i1], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->zeroTxPowerSubframeConfig_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncZeroTxPowerCSI_RS_Conf_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ZeroTxPowerCSI_RS_Conf_r12_Value* p, enum ZeroTxPowerCSI_RS_Conf_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ZeroTxPowerCSI_RS_Conf_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == ZeroTxPowerCSI_RS_Conf_r12_setup) {
		_serSysEncZeroTxPowerCSI_RS_r12(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncZeroTxPowerCSI_RS_Conf_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ZeroTxPowerCSI_RS_Conf_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncZeroTxPowerCSI_RS_Conf_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncZeroTxPowerCSI_RS_Conf_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional(_buffer, _size, _lidx, &p->csi_RS_r10);
	_serSysEncZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional(_buffer, _size, _lidx, &p->zeroTxPowerCSI_RS_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_r10_CSI_RS_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_r10_CSI_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_Config_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig_subframeAllocation_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MBSFN_SubframeConfig_subframeAllocation_Value* p, enum MBSFN_SubframeConfig_subframeAllocation_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MBSFN_SubframeConfig_subframeAllocation_oneFrame) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			HTON_8(&_buffer[*_lidx], p->oneFrame[i3], _lidx);
		}
	}
	if (d == MBSFN_SubframeConfig_subframeAllocation_fourFrames) {
		for (size_t i3 = 0; i3 < 24; i3++) {
			HTON_8(&_buffer[*_lidx], p->fourFrames[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig_subframeAllocation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfig_subframeAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMBSFN_SubframeConfig_subframeAllocation_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->radioframeAllocationPeriod;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->radioframeAllocationOffset, _lidx);
	_serSysEncMBSFN_SubframeConfig_subframeAllocation(_buffer, _size, _lidx, &p->subframeAllocation);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->subframeConfigList.d, _lidx);
	for (size_t i2 = 0; i2 < p->subframeConfigList.d; i2++) {
		_serSysEncMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->subframeConfigList.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value* p, enum CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup) {
		_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->qcl_ScramblingIdentity_r11, _lidx);
	{
		size_t _tmp = (size_t)p->crs_PortsCount_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value* p, enum MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_oneFrame_v1430) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			HTON_8(&_buffer[*_lidx], p->oneFrame_v1430[i3], _lidx);
		}
	}
	if (d == MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_fourFrames_v1430) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			HTON_8(&_buffer[*_lidx], p->fourFrames_v1430[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig_v1430_subframeAllocation_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfig_v1430_subframeAllocation_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfig_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfig_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMBSFN_SubframeConfig_v1430_subframeAllocation_v1430(_buffer, _size, _lidx, &p->subframeAllocation_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->subframeConfigList_v1430.d, _lidx);
	for (size_t i2 = 0; i2 < p->subframeConfigList_v1430.d; i2++) {
		_serSysEncMBSFN_SubframeConfig_v1430(_buffer, _size, _lidx, &p->subframeConfigList_v1430.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value* p, enum CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup) {
		_serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_RS_ConfigNZPId_r11, _lidx);
	{
		size_t _tmp = (size_t)p->antennaPortsCount_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->resourceConfig_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeConfig_r11, _lidx);
	HTON_16(&_buffer[*_lidx], p->scramblingIdentity_r11, _lidx);
	_serSysEncCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(_buffer, _size, _lidx, &p->qcl_CRS_Info_r11);
	_serSysEncCSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZPId_v1310);
	_serSysEncNZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysEncNZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);
	_serSysEncCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigZP_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigZP_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_RS_ConfigZPId_r11, _lidx);
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->resourceConfigList_r11[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->subframeConfig_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCSI_RS_ConfigZP_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_Config_r10_CSI_RS_Config_Optional(_buffer, _size, _lidx, &p->CSI_RS_Config);
	_serSysEncCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(_buffer, _size, _lidx, &p->CSI_RS_ConfigNZPToAddModList);
	_serSysEncCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(_buffer, _size, _lidx, &p->CSI_RS_ConfigNZPToReleaseModList);
	_serSysEncCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(_buffer, _size, _lidx, &p->CSI_RS_ConfigZPToAddModList);
	_serSysEncCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(_buffer, _size, _lidx, &p->CSI_RS_ConfigZPToReleaseModList);
	_serSysEncToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_Type_CSI_RS_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_Type_CSI_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPmchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PmchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysEncPmchConfig_Type_Pmch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PmchConfig_Type_Pmch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPmchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchCandidateList_Type_ePdcchCandidateList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchCandidateList_Type_ePdcchCandidateList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPdcchCandidate_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePattern_r10_subframePatternTDD_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasSubframePattern_r10_subframePatternTDD_r10_Value* p, enum MeasSubframePattern_r10_subframePatternTDD_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10) {
		for (size_t i1 = 0; i1 < 20; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframeConfig1_5_r10[i1], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10) {
		for (size_t i1 = 0; i1 < 70; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframeConfig0_r10[i1], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10) {
		for (size_t i1 = 0; i1 < 60; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframeConfig6_r10[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePattern_r10_subframePatternTDD_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasSubframePattern_r10_subframePatternTDD_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasSubframePattern_r10_subframePatternTDD_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePattern_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasSubframePattern_r10_Value* p, enum MeasSubframePattern_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePattern_r10_subframePatternFDD_r10) {
		for (size_t i1 = 0; i1 < 40; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframePatternFDD_r10[i1], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10) {
		_serSysEncMeasSubframePattern_r10_subframePatternTDD_r10(_buffer, _size, _lidx, &p->subframePatternTDD_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePattern_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasSubframePattern_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasSubframePattern_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMeasSubframePattern_r10(_buffer, _size, _lidx, &p->subframePattern_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value* p, enum EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup) {
		_serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_resourceBlockAssignment_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->numberPRB_Pairs_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->resourceBlockAssignment_r11.d, _lidx);
	for (size_t i2 = 0; i2 < p->resourceBlockAssignment_r11.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->resourceBlockAssignment_r11.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value* p, enum EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value* p, enum EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value* p, enum EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_fdd_r13) {
		{
			size_t _tmp = (size_t)p->fdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_tdd_r13) {
		{
			size_t _tmp = (size_t)p->tdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_mpdcch_config_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->csi_NumRepetitionCE_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mpdcch_pdsch_HoppingConfig_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13(_buffer, _size, _lidx, &p->mpdcch_StartSF_UESS_r13);
	{
		size_t _tmp = (size_t)p->mpdcch_NumRepetition_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->mpdcch_Narrowband_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_SetConfig_r11_mpdcch_config_r13_Value* p, enum EPDCCH_SetConfig_r11_mpdcch_config_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup) {
		_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_mpdcch_config_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfig_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfig_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->setConfigId_r11, _lidx);
	{
		size_t _tmp = (size_t)p->transmissionType_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(_buffer, _size, _lidx, &p->resourceBlockAssignment_r11);
	HTON_16(&_buffer[*_lidx], p->dmrs_ScramblingSequenceInt_r11, _lidx);
	HTON_16(&_buffer[*_lidx], p->pucch_ResourceStartOffset_r11, _lidx);
	_serSysEncPDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional(_buffer, _size, _lidx, &p->re_MappingQCL_ConfigId_r11);
	_serSysEncEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigZPId2_r12);
	_serSysEncEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional(_buffer, _size, _lidx, &p->numberPRB_Pairs_v1310);
	_serSysEncEPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_config_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncEPDCCH_SetConfig_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_config_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional(_buffer, _size, _lidx, &p->subframePatternConfig_r11);
	_serSysEncUint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional(_buffer, _size, _lidx, &p->startSymbol_r11);
	_serSysEncEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(_buffer, _size, _lidx, &p->setConfigToReleaseList_r11);
	_serSysEncEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(_buffer, _size, _lidx, &p->setConfigToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EPDCCH_Config_r11_config_r11_Value* p, enum EPDCCH_Config_r11_config_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_Config_r11_config_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EPDCCH_Config_r11_config_r11_setup) {
		_serSysEncEPDCCH_Config_r11_config_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_config_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEPDCCH_Config_r11_config_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEPDCCH_Config_r11_config_r11(_buffer, _size, _lidx, &p->config_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncEPDCCH_Config_r11_EPDCCH_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EPDCCH_Config_r11_EPDCCH_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEPDCCH_Config_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy_e_dummy_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_dummy_e_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy2_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union FreqHoppingParameters_r13_dummy2_Value* p, enum FreqHoppingParameters_r13_dummy2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_dummy2_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == FreqHoppingParameters_r13_dummy2_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_dummy2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqHoppingParameters_r13_dummy2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy2_dummy2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_dummy2_dummy2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13_dummy2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy3_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union FreqHoppingParameters_r13_dummy3_Value* p, enum FreqHoppingParameters_r13_dummy3_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_dummy3_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == FreqHoppingParameters_r13_dummy3_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_dummy3* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqHoppingParameters_r13_dummy3_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_dummy3_dummy3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_dummy3_dummy3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13_dummy3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value* p, enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value* p, enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_FreqHoppingParameters_r13_dummy4_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_FreqHoppingParameters_r13_dummy4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncFreqHoppingParameters_r13_dummy_e_dummy_Optional(_buffer, _size, _lidx, &p->dummy);
	_serSysEncFreqHoppingParameters_r13_dummy2_dummy2_Optional(_buffer, _size, _lidx, &p->dummy2);
	_serSysEncFreqHoppingParameters_r13_dummy3_dummy3_Optional(_buffer, _size, _lidx, &p->dummy3);
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional(_buffer, _size, _lidx, &p->interval_ULHoppingConfigCommonModeA_r13);
	_serSysEncFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional(_buffer, _size, _lidx, &p->interval_ULHoppingConfigCommonModeB_r13);
	_serSysEncUint8_t_FreqHoppingParameters_r13_dummy4_Optional(_buffer, _size, _lidx, &p->dummy4);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEpdcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EpdcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serSysEncPdcchCandidateList_Type_ePdcchCandidateList_Optional(_buffer, _size, _lidx, &p->ePdcchCandidateList);
	_serSysEncEPDCCH_Config_r11_EPDCCH_Config_Optional(_buffer, _size, _lidx, &p->EPDCCH_Config);
	_serSysEncFreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional(_buffer, _size, _lidx, &p->mPDCCH_FreqHoppingParameters_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncEpdcchConfig_Type_Epdcch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EpdcchConfig_Type_Epdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEpdcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value* p, enum MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms40_r12) {
		HTON_8(&_buffer[*_lidx], p->ms40_r12, _lidx);
	}
	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms80_r12) {
		HTON_8(&_buffer[*_lidx], p->ms80_r12, _lidx);
	}
	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms160_r12) {
		HTON_8(&_buffer[*_lidx], p->ms160_r12, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDMTC_PeriodOffset_r12_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const DMTC_PeriodOffset_r12_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDMTC_PeriodOffset_r12_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value* p, enum MeasDS_Config_r12_setup_ds_OccasionDuration_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasDS_Config_r12_setup_ds_OccasionDuration_r12_durationFDD_r12) {
		HTON_8(&_buffer[*_lidx], p->durationFDD_r12, _lidx);
	}
	if (d == MeasDS_Config_r12_setup_ds_OccasionDuration_r12_durationTDD_r12) {
		HTON_8(&_buffer[*_lidx], p->durationTDD_r12, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDS_OccasionDuration_r12_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const DS_OccasionDuration_r12_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDS_OccasionDuration_r12_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDS_RS_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DS_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional(_buffer, _size, _lidx, &p->DMTC_PeriodOffset);
	_serSysEncDS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional(_buffer, _size, _lidx, &p->DS_OccasionDuration_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncDS_RS_Config_Type_DS_RS_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DS_RS_Config_Type_DS_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDS_RS_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysicalLayerConfigDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysicalLayerConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(_buffer, _size, _lidx, &p->AntennaGroup);
	_serSysEncPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysEncPcfichConfig_Type_Pcfich_Optional(_buffer, _size, _lidx, &p->Pcfich);
	_serSysEncPhichConfig_Type_Phich_Optional(_buffer, _size, _lidx, &p->Phich);
	_serSysEncPdcchConfig_Type_Pdcch_Optional(_buffer, _size, _lidx, &p->Pdcch);
	_serSysEncPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serSysEncPrimarySyncSignal_Type_Pss_Optional(_buffer, _size, _lidx, &p->Pss);
	_serSysEncSecondarySyncSignal_Type_Sss_Optional(_buffer, _size, _lidx, &p->Sss);
	_serSysEncCSI_RS_Config_Type_CSI_RS_Config_Optional(_buffer, _size, _lidx, &p->CSI_RS_Config);
	_serSysEncPmchConfig_Type_Pmch_Optional(_buffer, _size, _lidx, &p->Pmch);
	_serSysEncEpdcchConfig_Type_Epdcch_Optional(_buffer, _size, _lidx, &p->Epdcch);
	_serSysEncDS_RS_Config_Type_DS_RS_Config_Optional(_buffer, _size, _lidx, &p->DS_RS_Config);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPhysicalLayerConfigDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAttenuation_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Attenuation_Type_Value* p, enum Attenuation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Attenuation_Type_Value) {
		HTON_8(&_buffer[*_lidx], p->Value, _lidx);
	}
	if (d == Attenuation_Type_Off) {
		HTON_8(&_buffer[*_lidx], p->Off, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInitialAttenuation_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const InitialAttenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAttenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncInitialCellPower_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InitialCellPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->MaxReferencePower, _lidx);
	_serSysEncInitialAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serSysEncInitialCellPower_Type_InitialCellPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InitialCellPower_Type_InitialCellPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncInitialCellPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchToPbchConfig_Type_Pbch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqDomainSchedulCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqDomainSchedulCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->FirstRbIndex, _lidx);
	HTON_32(&_buffer[*_lidx], p->MaxRbCnt, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfoCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfoCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ResourceAllocType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->Modulation_1stCW;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->Modulation_2ndCW;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqDomainSchedulCommon_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	HTON_32(&_buffer[*_lidx], p->RedundancyVersionList.d, _lidx);
	for (size_t i1 = 0; i1 < p->RedundancyVersionList.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->RedundancyVersionList.v[i1], _lidx);
	}
	_serSysEncRepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysEncDCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDciDlInfoCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSib1Schedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sib1Schedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncSib1Schedul_Type_Sib1Schedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSib1Schedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSiWindowLength_Type_WindowLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SiWindowLength_Type_WindowLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSI_Periodicity_r12_e_Periodicity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SI_Periodicity_r12_e_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDciDlInfoCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInt32_t_SubframeOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_SubframeOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSingleSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SingleSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);
	_serSysEncInt32_t_SubframeOffset_Optional(_buffer, _size, _lidx, &p->SubframeOffset);

	return SIDL_STATUS_OK;
}

static int _serSysEncSingleSiSchedul_Type_Window_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSingleSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSI_Periodicity_r12_e_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serSysEncSingleSiSchedul_Type_Window_DynamicOptional(_buffer, _size, _lidx, &p->Window);

	return SIDL_STATUS_OK;
}

static int _serSysEncSiSchedulList_Type_SiList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SiSchedulList_Type_SiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSiSchedulList_Type_SegmentedSiList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SiSchedulList_Type_SegmentedSiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAllSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AllSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSiWindowLength_Type_WindowLength_Optional(_buffer, _size, _lidx, &p->WindowLength);
	_serSysEncSiSchedulList_Type_SiList_Optional(_buffer, _size, _lidx, &p->SiList);
	_serSysEncSiSchedulList_Type_SegmentedSiList_Optional(_buffer, _size, _lidx, &p->SegmentedSiList);

	return SIDL_STATUS_OK;
}

static int _serSysEncAllSiSchedul_Type_SiSchedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AllSiSchedul_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAllSiSchedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchToPdschConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSib1Schedul_Type_Sib1Schedul_Optional(_buffer, _size, _lidx, &p->Sib1Schedul);
	_serSysEncAllSiSchedul_Type_SiSchedul_Optional(_buffer, _size, _lidx, &p->SiSchedul);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchToPdschConfig_Type_Pdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcchToPdschConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMasterInformationBlock(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MasterInformationBlock* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->dl_Bandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPHICH_Config(_buffer, _size, _lidx, &p->phich_Config);
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->systemFrameNumber[i1], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->schedulingInfoSIB1_BR_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->systemInfoUnchanged_BR_r15, _lidx);
	for (size_t i1 = 0; i1 < 4; i1++) {
		HTON_8(&_buffer[*_lidx], p->spare[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_BCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_BCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMasterInformationBlock(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_BCH_Message_BcchInfo_Type_MIB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_BCH_Message_BcchInfo_Type_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->ac_BarringFactor;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ac_BarringTime;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i2 = 0; i2 < 5; i2++) {
		HTON_8(&_buffer[*_lidx], p->ac_BarringForSpecialAC[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_ac_BarringInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_ac_BarringInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ac_BarringForEmergency, _lidx);
	_serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Signalling);
	_serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Data);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType2_ac_BarringInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sizeOfRA_PreamblesGroupA;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->messageSizeGroupA;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->messagePowerOffsetGroupB;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_preambleInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_preambleInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->numberOfRA_Preambles;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional(_buffer, _size, _lidx, &p->preamblesGroupAConfig);

	return SIDL_STATUS_OK;
}

static int _serSysEncPowerRampingParameters(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PowerRampingParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerRampingStep;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->preambleInitialReceivedTargetPower;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_ra_SupervisionInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_ra_SupervisionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->preambleTransMax;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ra_ResponseWindowSize;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mac_ContentionResolutionTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfo_r13_preambleMappingInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfo_r13_preambleMappingInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->firstPreamble_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->lastPreamble_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfo_r13_edt_Parameters_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->edt_LastPreamble_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->edt_SmallTBS_Enabled_r15, _lidx);
	{
		size_t _tmp = (size_t)p->edt_TBS_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional(_buffer, _size, _lidx, &p->mac_ContentionResolutionTimer_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_CE_LevelInfo_r13_preambleMappingInfo_r13(_buffer, _size, _lidx, &p->preambleMappingInfo_r13);
	{
		size_t _tmp = (size_t)p->ra_ResponseWindowSize_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mac_ContentionResolutionTimer_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->rar_HoppingConfig_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional(_buffer, _size, _lidx, &p->edt_Parameters_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncRACH_CE_LevelInfo_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_ConfigCommon_preambleInfo(_buffer, _size, _lidx, &p->preambleInfo);
	_serSysEncPowerRampingParameters(_buffer, _size, _lidx, &p->powerRampingParameters);
	_serSysEncRACH_ConfigCommon_ra_SupervisionInfo(_buffer, _size, _lidx, &p->ra_SupervisionInfo);
	HTON_8(&_buffer[*_lidx], p->maxHARQ_Msg3Tx, _lidx);
	_serSysEncPreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional(_buffer, _size, _lidx, &p->preambleTransMax_CE_r13);
	_serSysEncRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(_buffer, _size, _lidx, &p->rach_CE_LevelInfoList_r13);
	_serSysEncRACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional(_buffer, _size, _lidx, &p->edt_SmallTBS_Subset_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->modificationPeriodCoeff;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->defaultPagingCycle;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->nB;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->prach_ConfigIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->highSpeedFlag, _lidx);
	HTON_8(&_buffer[*_lidx], p->zeroCorrelationZoneConfig, _lidx);
	HTON_8(&_buffer[*_lidx], p->prach_FreqOffset, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->rootSequenceIndex, _lidx);
	_serSysEncPRACH_ConfigInfo(_buffer, _size, _lidx, &p->prach_ConfigInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->referenceSignalPower, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_b, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_pusch_ConfigBasic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_pusch_ConfigBasic* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->n_SB, _lidx);
	{
		size_t _tmp = (size_t)p->hoppingMode;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->pusch_HoppingOffset, _lidx);
	HTON_8(&_buffer[*_lidx], p->enable64QAM, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_ReferenceSignalsPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_ReferenceSignalsPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->groupHoppingEnabled, _lidx);
	HTON_8(&_buffer[*_lidx], p->groupAssignmentPUSCH, _lidx);
	HTON_8(&_buffer[*_lidx], p->sequenceHoppingEnabled, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigCommon_pusch_ConfigBasic(_buffer, _size, _lidx, &p->pusch_ConfigBasic);
	_serSysEncUL_ReferenceSignalsPUSCH(_buffer, _size, _lidx, &p->ul_ReferenceSignalsPUSCH);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaPUCCH_Shift;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->nRB_CQI, _lidx);
	HTON_8(&_buffer[*_lidx], p->nCS_AN, _lidx);
	HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigCommon_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->srs_BandwidthConfig;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->srs_SubframeConfig;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->ackNackSRS_SimultaneousTransmission, _lidx);
	_serSysEncSoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional(_buffer, _size, _lidx, &p->srs_MaxUpPts);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigCommon_Value* p, enum SoundingRS_UL_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SoundingRS_UL_ConfigCommon_setup) {
		_serSysEncSoundingRS_UL_ConfigCommon_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_PUCCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_PUCCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format1;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format1b;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format2;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format2a;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format2b;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p0_NominalPUSCH, _lidx);
	{
		size_t _tmp = (size_t)p->alpha;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_NominalPUCCH, _lidx);
	_serSysEncDeltaFList_PUCCH(_buffer, _size, _lidx, &p->deltaFList_PUCCH);
	HTON_8(&_buffer[*_lidx], p->deltaPreambleMsg3, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format3_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format1bCS_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommon_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_v1250_txFailParams_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_v1250_txFailParams_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->connEstFailCount_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->connEstFailOffsetValidity_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional(_buffer, _size, _lidx, &p->connEstFailOffset_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_ConfigCommon_v1250_txFailParams_r12(_buffer, _size, _lidx, &p->txFailParams_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_ConfigCommon_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1270(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1270* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->enable64QAM_v1270;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigCommon_v1270(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_Config_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->modificationPeriodCoeff_v1310;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Config_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->paging_narrowBands_r13, _lidx);
	{
		size_t _tmp = (size_t)p->mpdcch_NumRepetition_Paging_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional(_buffer, _size, _lidx, &p->nB_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFreqHoppingParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional(_buffer, _size, _lidx, &p->pusch_maxNumRepetitionCEmodeA_r13);
	_serSysEncPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional(_buffer, _size, _lidx, &p->pusch_maxNumRepetitionCEmodeB_r13);
	_serSysEncUint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional(_buffer, _size, _lidx, &p->pusch_HoppingOffset_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value* p, enum PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13) {
		{
			size_t _tmp = (size_t)p->fdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13) {
		{
			size_t _tmp = (size_t)p->tdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ParametersCE_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ParametersCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->prach_ConfigIndex_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->prach_FreqOffset_r13, _lidx);
	_serSysEncPRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional(_buffer, _size, _lidx, &p->prach_StartingSubframe_r13);
	_serSysEncPRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional(_buffer, _size, _lidx, &p->maxNumPreambleAttemptCE_r13);
	{
		size_t _tmp = (size_t)p->numRepetitionPerPreambleAttempt_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->mpdcch_NarrowbandsToMonitor_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->mpdcch_NarrowbandsToMonitor_r13.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->mpdcch_NarrowbandsToMonitor_r13.v[i3], _lidx);
	}
	{
		size_t _tmp = (size_t)p->mpdcch_NumRepetition_RA_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->prach_HoppingConfig_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->rsrp_ThresholdsPrachInfoList_r13.d, _lidx);
	for (size_t i2 = 0; i2 < p->rsrp_ThresholdsPrachInfoList_r13.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->rsrp_ThresholdsPrachInfoList_r13.v[i2], _lidx);
	}
	_serSysEncPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_startSF_CSS_RA_r13);
	_serSysEncUint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->prach_HoppingOffset_r13);
	HTON_32(&_buffer[*_lidx], p->prach_ParametersListCE_r13.d, _lidx);
	for (size_t i2 = 0; i2 < p->prach_ParametersListCE_r13.d; i2++) {
		_serSysEncPRACH_ParametersCE_r13(_buffer, _size, _lidx, &p->prach_ParametersListCE_r13.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_ConfigSIB_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct N1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_InfoList_r13);
	_serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level0_r13);
	_serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level1_r13);
	_serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level2_r13);
	_serSysEncPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncHighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional(_buffer, _size, _lidx, &p->highSpeedEnhancedMeasFlag_r14);
	_serSysEncHighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional(_buffer, _size, _lidx, &p->highSpeedEnhancedDemodulationFlag_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncHighSpeedConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->rootSequenceIndexHighSpeed_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->zeroCorrelationZoneConfigHighSpeed_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->prach_ConfigIndexHighSpeed_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->prach_FreqOffsetHighSpeed_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level3_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigCommon_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->prach_ConfigIndex_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->prach_FreqOffset_r15, _lidx);
	_serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional(_buffer, _size, _lidx, &p->prach_StartingSubframe_r15);
	HTON_32(&_buffer[*_lidx], p->mpdcch_NarrowbandsToMonitor_r15.d, _lidx);
	for (size_t i3 = 0; i3 < p->mpdcch_NarrowbandsToMonitor_r15.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->mpdcch_NarrowbandsToMonitor_r15.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEDT_PRACH_ParametersCE_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EDT_PRACH_ParametersCE_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(_buffer, _size, _lidx, &p->edt_PRACH_ParametersCE_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->edt_PRACH_ParametersListCE_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->edt_PRACH_ParametersListCE_r15.d; i2++) {
		_serSysEncEDT_PRACH_ParametersCE_r15(_buffer, _size, _lidx, &p->edt_PRACH_ParametersListCE_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_ConfigSIB_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSS_Config_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSS_Config_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->duration_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->freqLocation_r15, _lidx);
	{
		size_t _tmp = (size_t)p->periodicity_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->powerBoost_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->timeOffset_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRSS_Config_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->maxDurationFactor_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncWUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional(_buffer, _size, _lidx, &p->numPOs_r15);
	{
		size_t _tmp = (size_t)p->freqLocation_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->timeOffsetDRX_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->timeOffset_eDRX_Short_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncWUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional(_buffer, _size, _lidx, &p->timeOffset_eDRX_Long_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWUS_Config_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->highSpeedMeasGapCE_ModeA_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncHighSpeedConfig_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1a_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1b_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format3_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_RM_Format4_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_TBCC_Format4_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_Format1and1a_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_Format1b_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_RM_Format4_r15);
	_serSysEncDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_TBCC_Format4_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DeltaFList_SPUCCH_r15_Value* p, enum DeltaFList_SPUCCH_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DeltaFList_SPUCCH_r15_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == DeltaFList_SPUCCH_r15_setup) {
		_serSysEncDeltaFList_SPUCCH_r15_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaFList_SPUCCH_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaFList_SPUCCH_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDeltaFList_SPUCCH_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDeltaFList_SPUCCH_r15(_buffer, _size, _lidx, &p->deltaFList_SPUCCH_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommon_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_v1560(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_v1560* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerBoost_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWUS_Config_v1560(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->numDRX_CyclesRelaxed_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWUS_Config_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncHighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEnhMeasFlag2_r16);
	_serSysEncHighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEnhDemodFlag2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncHighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncHighSpeedConfig_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRS_ChEstMPDCCH_ConfigCommon_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRS_ChEstMPDCCH_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerRatio_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCRS_ChEstMPDCCH_ConfigCommon_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->maxDurationFactor_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncGWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional(_buffer, _size, _lidx, &p->numPOs_r16);
	{
		size_t _tmp = (size_t)p->timeOffsetDRX_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->timeOffset_eDRX_Short_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncGWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional(_buffer, _size, _lidx, &p->timeOffset_eDRX_Long_r16);
	_serSysEncGWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional(_buffer, _size, _lidx, &p->numDRX_CyclesRelaxed_r16);
	_serSysEncGWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional(_buffer, _size, _lidx, &p->powerBoost_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncGWUS_TimeParameters_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union GWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value* p, enum GWUS_ResourceConfig_r16_resourceMappingPattern_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithWUS) {
		{
			size_t _tmp = (size_t)p->resourceLocationWithWUS;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithoutWUS) {
		{
			size_t _tmp = (size_t)p->resourceLocationWithoutWUS;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ResourceConfig_r16_resourceMappingPattern_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_ResourceConfig_r16_resourceMappingPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncGWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		{
			size_t _tmp = (size_t)p->v.v[i2];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ResourceConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_ResourceConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncGWUS_ResourceConfig_r16_resourceMappingPattern_r16(_buffer, _size, _lidx, &p->resourceMappingPattern_r16);
	_serSysEncGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(_buffer, _size, _lidx, &p->numGroupsList_r16);
	_serSysEncGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(_buffer, _size, _lidx, &p->groupsForServiceList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncGWUS_ResourceConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncGWUS_ResourceConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		{
			size_t _tmp = (size_t)p->v.v[i2];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncGWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional(_buffer, _size, _lidx, &p->groupAlternation_r16);
	_serSysEncGWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional(_buffer, _size, _lidx, &p->commonSequence_r16);
	_serSysEncGWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional(_buffer, _size, _lidx, &p->timeParameters_r16);
	_serSysEncGWUS_ResourceConfig_r16(_buffer, _size, _lidx, &p->resourceConfigDRX_r16);
	_serSysEncGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(_buffer, _size, _lidx, &p->resourceConfig_eDRX_Short_r16);
	_serSysEncGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(_buffer, _size, _lidx, &p->resourceConfig_eDRX_Long_r16);
	_serSysEncGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(_buffer, _size, _lidx, &p->probThreshList_r16);
	_serSysEncGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(_buffer, _size, _lidx, &p->groupNarrowBandList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncGWUS_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->alphaSRS_Add_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_NominalSRS_Add_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommon_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioResourceConfigCommonSIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioResourceConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_ConfigCommon(_buffer, _size, _lidx, &p->rach_ConfigCommon);
	_serSysEncBCCH_Config(_buffer, _size, _lidx, &p->bcch_Config);
	_serSysEncPCCH_Config(_buffer, _size, _lidx, &p->pcch_Config);
	_serSysEncPRACH_ConfigSIB(_buffer, _size, _lidx, &p->prach_Config);
	_serSysEncPDSCH_ConfigCommon(_buffer, _size, _lidx, &p->pdsch_ConfigCommon);
	_serSysEncPUSCH_ConfigCommon(_buffer, _size, _lidx, &p->pusch_ConfigCommon);
	_serSysEncPUCCH_ConfigCommon(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serSysEncSoundingRS_UL_ConfigCommon(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigCommon);
	_serSysEncUplinkPowerControlCommon(_buffer, _size, _lidx, &p->uplinkPowerControlCommon);
	{
		size_t _tmp = (size_t)p->ul_CyclicPrefixLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1020);
	_serSysEncRACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon_v1250);
	_serSysEncPUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1270);
	_serSysEncBCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional(_buffer, _size, _lidx, &p->bcch_Config_v1310);
	_serSysEncPCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional(_buffer, _size, _lidx, &p->pcch_Config_v1310);
	_serSysEncFreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional(_buffer, _size, _lidx, &p->freqHoppingParameters_r13);
	_serSysEncPDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pdsch_ConfigCommon_v1310);
	_serSysEncPUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1310);
	_serSysEncPRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->prach_ConfigCommon_v1310);
	_serSysEncPUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon_v1310);
	_serSysEncHighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_r14);
	_serSysEncPRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional(_buffer, _size, _lidx, &p->prach_Config_v1430);
	_serSysEncPUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon_v1430);
	_serSysEncPRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(_buffer, _size, _lidx, &p->prach_Config_v1530);
	_serSysEncRSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional(_buffer, _size, _lidx, &p->ce_RSS_Config_r15);
	_serSysEncWUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional(_buffer, _size, _lidx, &p->wus_Config_r15);
	_serSysEncHighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_v1530);
	_serSysEncUplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1540);
	_serSysEncWUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional(_buffer, _size, _lidx, &p->wus_Config_v1560);
	_serSysEncWUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional(_buffer, _size, _lidx, &p->wus_Config_v1610);
	_serSysEncHighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_v1610);
	_serSysEncCRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional(_buffer, _size, _lidx, &p->crs_ChEstMPDCCH_ConfigCommon_r16);
	_serSysEncGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(_buffer, _size, _lidx, &p->gwus_Config_r16);
	_serSysEncUplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1610);
	_serSysEncRadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional(_buffer, _size, _lidx, &p->rss_MeasConfig_r16);
	_serSysEncRadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional(_buffer, _size, _lidx, &p->rss_MeasNonNCL_r16);
	_serSysEncB2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional(_buffer, _size, _lidx, &p->puncturedSubcarriersDL_r16);
	_serSysEncBool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional(_buffer, _size, _lidx, &p->highSpeedInterRAT_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_TimersAndConstants_t300_r15_e_t300_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_TimersAndConstants_t300_r15_e_t300_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_TimersAndConstants(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_TimersAndConstants* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t300;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t301;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t310;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->n310;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t311;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->n311;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional(_buffer, _size, _lidx, &p->t300_v1310);
	_serSysEncUE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional(_buffer, _size, _lidx, &p->t301_v1310);
	_serSysEncUE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional(_buffer, _size, _lidx, &p->t310_v1330);
	_serSysEncUE_TimersAndConstants_t300_r15_e_t300_r15_Optional(_buffer, _size, _lidx, &p->t300_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_freqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_freqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional(_buffer, _size, _lidx, &p->ul_CarrierFreq);
	_serSysEncSystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(_buffer, _size, _lidx, &p->ul_Bandwidth);
	HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmission, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12_ac_BarringInfo_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12_ac_BarringInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ac_BarringForEmergency_r12, _lidx);
	_serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Signalling_r12);
	_serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Data_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringPerPLMN_r12_ac_BarringInfo_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r12, _lidx);
	_serSysEncAC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringInfo_r12);
	_serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVoice_r12);
	_serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVideo_r12);
	_serSysEncAC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForSMS_r12);
	_serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForCSFB_r12);
	_serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Voice_r12);
	_serSysEncAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Video_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncAC_BarringPerPLMN_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBarringPerACDC_Category_r13_acdc_BarringConfig_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BarringPerACDC_Category_r13_acdc_BarringConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->ac_BarringFactor_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ac_BarringTime_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBarringPerACDC_Category_r13_acdc_BarringConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBarringPerACDC_Category_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BarringPerACDC_Category_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->acdc_Category_r13, _lidx);
	_serSysEncBarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional(_buffer, _size, _lidx, &p->acdc_BarringConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncACDC_BarringForCommon_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ACDC_BarringForCommon_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->acdc_HPLMNonly_r13, _lidx);
	HTON_32(&_buffer[*_lidx], p->barringPerACDC_CategoryList_r13.d, _lidx);
	for (size_t i2 = 0; i2 < p->barringPerACDC_CategoryList_r13.d; i2++) {
		_serSysEncBarringPerACDC_Category_r13(_buffer, _size, _lidx, &p->barringPerACDC_CategoryList_r13.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncACDC_BarringForCommon_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncACDC_BarringPerPLMN_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ACDC_BarringPerPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->acdc_OnlyForHPLMN_r13, _lidx);
	HTON_32(&_buffer[*_lidx], p->barringPerACDC_CategoryList_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->barringPerACDC_CategoryList_r13.d; i3++) {
		_serSysEncBarringPerACDC_Category_r13(_buffer, _size, _lidx, &p->barringPerACDC_CategoryList_r13.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncACDC_BarringPerPLMN_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_Restricting_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_Restricting_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional(_buffer, _size, _lidx, &p->udt_Restricting_r13);
	_serSysEncUDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional(_buffer, _size, _lidx, &p->udt_RestrictingTime_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUDT_Restricting_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUDT_Restricting_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_RestrictingPerPLMN_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_RestrictingPerPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r13, _lidx);
	_serSysEncUDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional(_buffer, _size, _lidx, &p->udt_Restricting_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncUDT_RestrictingPerPLMN_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCIOT_OptimisationPLMN_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CIOT_OptimisationPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional(_buffer, _size, _lidx, &p->up_CIoT_EPS_Optimisation_r13);
	_serSysEncCIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional(_buffer, _size, _lidx, &p->cp_CIoT_EPS_Optimisation_r13);
	_serSysEncCIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional(_buffer, _size, _lidx, &p->attachWithoutPDN_Connectivity_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCIOT_OptimisationPLMN_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBSFN_SubframeConfig_v1430(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_Info_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_Info_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional(_buffer, _size, _lidx, &p->upperLayerIndication_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncPLMN_Info_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType2* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional(_buffer, _size, _lidx, &p->ac_BarringInfo);
	_serSysEncRadioResourceConfigCommonSIB(_buffer, _size, _lidx, &p->radioResourceConfigCommon);
	_serSysEncUE_TimersAndConstants(_buffer, _size, _lidx, &p->ue_TimersAndConstants);
	_serSysEncSystemInformationBlockType2_freqInfo(_buffer, _size, _lidx, &p->freqInfo);
	_serSysEncMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList);
	{
		size_t _tmp = (size_t)p->timeAlignmentTimerCommon;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Voice_r9);
	_serSysEncAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Video_r9);
	_serSysEncAC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional(_buffer, _size, _lidx, &p->ac_BarringForCSFB_r10);
	_serSysEncSystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVoice_r12);
	_serSysEncSystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVideo_r12);
	_serSysEncSystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForSMS_r12);
	_serSysEncAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringPerPLMN_List_r12);
	_serSysEncSystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional(_buffer, _size, _lidx, &p->voiceServiceCauseIndication_r12);
	_serSysEncACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(_buffer, _size, _lidx, &p->acdc_BarringForCommon_r13);
	_serSysEncACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(_buffer, _size, _lidx, &p->acdc_BarringPerPLMN_List_r13);
	_serSysEncUDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional(_buffer, _size, _lidx, &p->udt_RestrictingForCommon_r13);
	_serSysEncUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(_buffer, _size, _lidx, &p->udt_RestrictingPerPLMN_List_r13);
	_serSysEncCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(_buffer, _size, _lidx, &p->cIoT_EPS_OptimisationInfo_r13);
	_serSysEncSystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional(_buffer, _size, _lidx, &p->useFullResumeID_r13);
	_serSysEncSystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional(_buffer, _size, _lidx, &p->unicastFreqHoppingInd_r13);
	_serSysEncMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList_v1430);
	_serSysEncSystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional(_buffer, _size, _lidx, &p->videoServiceCauseIndication_r14);
	_serSysEncPLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(_buffer, _size, _lidx, &p->plmn_InfoList_r15);
	_serSysEncSystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional(_buffer, _size, _lidx, &p->cp_EDT_r15);
	_serSysEncSystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional(_buffer, _size, _lidx, &p->up_EDT_r15);
	_serSysEncSystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional(_buffer, _size, _lidx, &p->idleModeMeasurements_r15);
	_serSysEncSystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional(_buffer, _size, _lidx, &p->reducedCP_LatencyEnabled_r15);
	_serSysEncSystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional(_buffer, _size, _lidx, &p->mbms_ROM_ServiceIndication_r15);
	_serSysEncSystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional(_buffer, _size, _lidx, &p->rlos_Enabled_r16);
	_serSysEncSystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional(_buffer, _size, _lidx, &p->earlySecurityReactivation_r16);
	_serSysEncSystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional(_buffer, _size, _lidx, &p->cp_EDT_5GC_r16);
	_serSysEncSystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional(_buffer, _size, _lidx, &p->up_EDT_5GC_r16);
	_serSysEncSystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional(_buffer, _size, _lidx, &p->cp_PUR_EPC_r16);
	_serSysEncSystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional(_buffer, _size, _lidx, &p->up_PUR_EPC_r16);
	_serSysEncSystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional(_buffer, _size, _lidx, &p->cp_PUR_5GC_r16);
	_serSysEncSystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional(_buffer, _size, _lidx, &p->up_PUR_5GC_r16);
	_serSysEncSystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional(_buffer, _size, _lidx, &p->mpdcch_CQI_Reporting_r16);
	_serSysEncSystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional(_buffer, _size, _lidx, &p->rai_ActivationEnh_r16);
	_serSysEncSystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMobilityStateParameters(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MobilityStateParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t_Evaluation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_HystNormal;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->n_CellChangeMedium, _lidx);
	HTON_8(&_buffer[*_lidx], p->n_CellChangeHigh, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sf_Medium;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sf_High;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMobilityStateParameters(_buffer, _size, _lidx, &p->mobilityStateParameters);
	_serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(_buffer, _size, _lidx, &p->q_HystSF);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_cellReselectionInfoCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_cellReselectionInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->q_Hyst;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(_buffer, _size, _lidx, &p->speedStateReselectionPars);

	return SIDL_STATUS_OK;
}

static int _serSysEncReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_cellReselectionServingFreqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_cellReselectionServingFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearch);
	HTON_8(&_buffer[*_lidx], p->threshServingLow, _lidx);
	HTON_8(&_buffer[*_lidx], p->cellReselectionPriority, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncAllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sf_Medium;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sf_High;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_intraFreqCellReselectionInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_intraFreqCellReselectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serSysEncP_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serSysEncReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional(_buffer, _size, _lidx, &p->s_IntraSearch);
	_serSysEncAllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional(_buffer, _size, _lidx, &p->allowedMeasBandwidth);
	HTON_8(&_buffer[*_lidx], p->presenceAntennaPort1, _lidx);
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->neighCellConfig[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->t_ReselectionEUTRA, _lidx);
	_serSysEncSpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_s_IntraSearch_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_s_IntraSearch_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->s_IntraSearchP_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->s_IntraSearchQ_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType3_s_IntraSearch_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_s_NonIntraSearch_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_s_NonIntraSearch_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->s_NonIntraSearchP_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->s_NonIntraSearchQ_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType3_s_NonIntraSearch_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionServingFreqInfo_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionServingFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cellReselectionSubPriority_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionServingFreqInfo_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionServingInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionServingInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->redistributionFactorServing_r13, _lidx);
	_serSysEncRedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional(_buffer, _size, _lidx, &p->redistributionFactorCell_r13);
	{
		size_t _tmp = (size_t)p->t360_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional(_buffer, _size, _lidx, &p->redistrOnPagingOnly_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRedistributionServingInfo_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMinCE_r13, _lidx);
	_serSysEncQ_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_CE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncT_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct T_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMinCE1_r13, _lidx);
	_serSysEncQ_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_CE1_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_v1360(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_v1360* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->delta_RxLevMinCE1_v1360, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionInfoCommon_v1460(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionInfoCommon_v1460* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->s_SearchDeltaP_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionInfoCommon_v1460(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionInfoHSDN_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionInfoHSDN_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->cellEquivalentSize_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionInfoHSDN_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerClass14dBm_Offset_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionServingFreqInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionServingFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionPriority_r16);
	_serSysEncCellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionSubPriority_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionServingFreqInfo_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType3_cellReselectionInfoCommon(_buffer, _size, _lidx, &p->cellReselectionInfoCommon);
	_serSysEncSystemInformationBlockType3_cellReselectionServingFreqInfo(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo);
	_serSysEncSystemInformationBlockType3_intraFreqCellReselectionInfo(_buffer, _size, _lidx, &p->intraFreqCellReselectionInfo);
	_serSysEncOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional(_buffer, _size, _lidx, &p->s_IntraSearch_v920);
	_serSysEncSystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearch_v920);
	_serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional(_buffer, _size, _lidx, &p->q_QualMin_r9);
	_serSysEncReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional(_buffer, _size, _lidx, &p->threshServingLowQ_r9);
	_serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r11);
	_serSysEncQ_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);
	_serSysEncCellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo_v1310);
	_serSysEncRedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional(_buffer, _size, _lidx, &p->redistributionServingInfo_r13);
	_serSysEncCellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysEncT_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_CE_r13);
	_serSysEncCellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);
	_serSysEncCellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);
	_serSysEncCellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional(_buffer, _size, _lidx, &p->cellReselectionInfoCommon_v1460);
	_serSysEncCellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionInfoHSDN_r15);
	_serSysEncCellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);
	_serSysEncSystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional(_buffer, _size, _lidx, &p->crs_IntfMitigNeighCellsCE_r15);
	_serSysEncCellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqNeighCellInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId, _lidx);
	{
		size_t _tmp = (size_t)p->q_OffsetCell;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncIntraFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdRange_range_e_range_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdRange_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdRange(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdRange* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->start, _lidx);
	_serSysEncPhysCellIdRange_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRSS_ConfigCarrierInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSS_ConfigCarrierInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->narrowbandIndex_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->narrowbandIndex_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->narrowbandIndex_r16.v[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->timeOffsetGranularity_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRSS_ConfigCarrierInfo_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqNeighCellInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->rss_MeasPowerBias_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncIntraFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType4(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType4* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(_buffer, _size, _lidx, &p->intraFreqNeighCellList);
	_serSysEncIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(_buffer, _size, _lidx, &p->intraFreqBlackCellList);
	_serSysEncPhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional(_buffer, _size, _lidx, &p->csg_PhysCellIdRange);
	_serSysEncOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(_buffer, _size, _lidx, &p->intraFreqNeighHSDN_CellList_r15);
	_serSysEncRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(_buffer, _size, _lidx, &p->rss_ConfigCarrierInfo_r16);
	_serSysEncIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, &p->intraFreqNeighCellList_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_InterFreqCarrierFreqInfo_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_InterFreqCarrierFreqInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighCellInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId, _lidx);
	{
		size_t _tmp = (size_t)p->q_OffsetCell;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncInterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_threshX_Q_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_threshX_Q_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncInterFreqCarrierFreqInfo_threshX_Q_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->dl_CarrierFreq, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serSysEncP_Max_InterFreqCarrierFreqInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionEUTRA, _lidx);
	_serSysEncSpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);
	{
		size_t _tmp = (size_t)p->allowedMeasBandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->presenceAntennaPort1, _lidx);
	_serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->neighCellConfig[i3], _lidx);
	}
	_serSysEncQ_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq);
	_serSysEncInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(_buffer, _size, _lidx, &p->interFreqNeighCellList);
	_serSysEncInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(_buffer, _size, _lidx, &p->interFreqBlackCellList);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional(_buffer, _size, _lidx, &p->q_QualMin_r9);
	_serSysEncInterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional(_buffer, _size, _lidx, &p->threshX_Q_r9);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncInterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncInterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_r12_threshX_Q_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_r12_threshX_Q_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncInterFreqCarrierFreqInfo_r12_threshX_Q_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->dl_CarrierFreq_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r12, _lidx);
	_serSysEncP_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional(_buffer, _size, _lidx, &p->p_Max_r12);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionEUTRA_r12, _lidx);
	_serSysEncSpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF_r12);
	HTON_8(&_buffer[*_lidx], p->threshX_High_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low_r12, _lidx);
	{
		size_t _tmp = (size_t)p->allowedMeasBandwidth_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->presenceAntennaPort1_r12, _lidx);
	_serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->neighCellConfig_r12[i3], _lidx);
	}
	_serSysEncQ_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq_r12);
	_serSysEncInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(_buffer, _size, _lidx, &p->interFreqNeighCellList_r12);
	_serSysEncInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(_buffer, _size, _lidx, &p->interFreqBlackCellList_r12);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional(_buffer, _size, _lidx, &p->q_QualMin_r12);
	_serSysEncInterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional(_buffer, _size, _lidx, &p->threshX_Q_r12);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r12);
	_serSysEncMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(_buffer, _size, _lidx, &p->multiBandInfoList_r12);
	_serSysEncInterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);
	_serSysEncQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNS_PmaxValue_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NS_PmaxValue_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncP_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional(_buffer, _size, _lidx, &p->additionalPmax_r10);
	HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmission, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncNS_PmaxValue_r10(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i3].d, _lidx);
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysEncNS_PmaxValue_r10(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v10j0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v10j0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(_buffer, _size, _lidx, &p->freqBandInfo_r10);
	_serSysEncMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(_buffer, _size, _lidx, &p->multiBandInfoList_v10j0);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v10j0(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionNeighCell_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionNeighCell_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->redistributionFactorCell_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncRedistributionNeighCell_r13(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionInterFreqInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionInterFreqInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional(_buffer, _size, _lidx, &p->redistributionFactorFreq_r13);
	_serSysEncRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(_buffer, _size, _lidx, &p->redistributionNeighCellList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRedistributionInterFreqInfo_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncT_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct T_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority_r13);
	_serSysEncRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(_buffer, _size, _lidx, &p->redistributionInterFreqInfo_r13);
	_serSysEncCellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysEncT_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_CE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1310(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1310(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1350(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1350* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1350(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1350(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1360(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1360* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1360(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->hsdn_Indication_r15, _lidx);
	_serSysEncInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(_buffer, _size, _lidx, &p->interFreqNeighHSDN_CellList_r15);
	_serSysEncCellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1530(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1530(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierEUTRA_r15_qualityThreshold_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierEUTRA_r15_qualityThreshold_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_r15);
	_serSysEncRSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasIdleCarrierEUTRA_r15_qualityThreshold_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierEUTRA_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierEUTRA_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq_r15, _lidx);
	{
		size_t _tmp = (size_t)p->allowedMeasBandwidth_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(_buffer, _size, _lidx, &p->validityArea_r15);
	_serSysEncCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(_buffer, _size, _lidx, &p->measCellList_r15);
	{
		size_t _tmp = (size_t)p->reportQuantities;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional(_buffer, _size, _lidx, &p->qualityThreshold_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleConfigSIB_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleConfigSIB_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->measIdleCarrierListEUTRA_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->measIdleCarrierListEUTRA_r15.d; i2++) {
		_serSysEncMeasIdleCarrierEUTRA_r15(_buffer, _size, _lidx, &p->measIdleCarrierListEUTRA_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasIdleConfigSIB_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRSS_ConfigCarrierInfo_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighCellInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->rss_MeasPowerBias_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncInterFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionPriority_r16);
	_serSysEncCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionSubPriority_r16);
	_serSysEncRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(_buffer, _size, _lidx, &p->rss_ConfigCarrierInfo_r16);
	_serSysEncInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, &p->interFreqNeighCellList_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct InterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdRangeNR_r16_range_e_range_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdRangeNR_r16_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdRangeNR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdRangeNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->start, _lidx);
	_serSysEncPhysCellIdRangeNR_r16_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPhysCellIdRangeNR_r16(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierNR_r16_qualityThresholdNR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierNR_r16_qualityThresholdNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_ThresholdNR_r16);
	_serSysEncRSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_ThresholdNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasIdleCarrierNR_r16_qualityThresholdNR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncThresholdListNR_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ThresholdListNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional(_buffer, _size, _lidx, &p->nr_RSRP_r15);
	_serSysEncRSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional(_buffer, _size, _lidx, &p->nr_RSRQ_r15);
	_serSysEncRS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional(_buffer, _size, _lidx, &p->nr_SINR_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncThresholdListNR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB_NR_r15_periodicityAndOffset_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MTC_SSB_NR_r15_periodicityAndOffset_r15_Value* p, enum MTC_SSB_NR_r15_periodicityAndOffset_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf5_r15) {
		HTON_8(&_buffer[*_lidx], p->sf5_r15, _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf10_r15) {
		HTON_8(&_buffer[*_lidx], p->sf10_r15, _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf20_r15) {
		HTON_8(&_buffer[*_lidx], p->sf20_r15, _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf40_r15) {
		HTON_8(&_buffer[*_lidx], p->sf40_r15, _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf80_r15) {
		HTON_8(&_buffer[*_lidx], p->sf80_r15, _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf160_r15) {
		HTON_8(&_buffer[*_lidx], p->sf160_r15, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB_NR_r15_periodicityAndOffset_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB_NR_r15_periodicityAndOffset_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMTC_SSB_NR_r15_periodicityAndOffset_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB_NR_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB_NR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMTC_SSB_NR_r15_periodicityAndOffset_r15(_buffer, _size, _lidx, &p->periodicityAndOffset_r15);
	{
		size_t _tmp = (size_t)p->ssb_Duration_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMTC_SSB_NR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSSB_ToMeasure_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SSB_ToMeasure_r15_Value* p, enum SSB_ToMeasure_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SSB_ToMeasure_r15_shortBitmap_r15) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			HTON_8(&_buffer[*_lidx], p->shortBitmap_r15[i3], _lidx);
		}
	}
	if (d == SSB_ToMeasure_r15_mediumBitmap_r15) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			HTON_8(&_buffer[*_lidx], p->mediumBitmap_r15[i3], _lidx);
		}
	}
	if (d == SSB_ToMeasure_r15_longBitmap_r15) {
		for (size_t i3 = 0; i3 < 64; i3++) {
			HTON_8(&_buffer[*_lidx], p->longBitmap_r15[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSSB_ToMeasure_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SSB_ToMeasure_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSSB_ToMeasure_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSSB_ToMeasure_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RSSI_Measurement_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RSSI_Measurement_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->measurementSlots_r15.d, _lidx);
	for (size_t i3 = 0; i3 < p->measurementSlots_r15.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->measurementSlots_r15.v[i3], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->endSymbol_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSS_RSSI_Measurement_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional(_buffer, _size, _lidx, &p->maxRS_IndexCellQual_r16);
	_serSysEncThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional(_buffer, _size, _lidx, &p->threshRS_Index_r16);
	_serSysEncMTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional(_buffer, _size, _lidx, &p->measTimingConfig_r16);
	_serSysEncSSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r16);
	HTON_8(&_buffer[*_lidx], p->deriveSSB_IndexFromCell_r16, _lidx);
	_serSysEncSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(_buffer, _size, _lidx, &p->ss_RSSI_Measurement_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBeamMeasConfigIdleNR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BeamMeasConfigIdleNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->reportQuantityRS_IndexNR_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->maxReportRS_Index_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->reportRS_IndexResultsNR_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBeamMeasConfigIdleNR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleCarrierNR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleCarrierNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreqNR_r16, _lidx);
	{
		size_t _tmp = (size_t)p->subcarrierSpacingSSB_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serSysEncCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(_buffer, _size, _lidx, &p->measCellListNR_r16);
	{
		size_t _tmp = (size_t)p->reportQuantitiesNR_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->qualityThresholdNR_r16);
	_serSysEncMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(_buffer, _size, _lidx, &p->ssb_MeasConfig_r16);
	_serSysEncBeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(_buffer, _size, _lidx, &p->beamMeasConfigIdle_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleConfigSIB_NR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleConfigSIB_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->measIdleCarrierListNR_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->measIdleCarrierListNR_r16.d; i2++) {
		_serSysEncMeasIdleCarrierNR_r16(_buffer, _size, _lidx, &p->measIdleCarrierListNR_r16.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasIdleConfigSIB_NR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType5(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType5* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->interFreqCarrierFreqList.d, _lidx);
	for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
		_serSysEncInterFreqCarrierFreqInfo(_buffer, _size, _lidx, &p->interFreqCarrierFreqList.v[i2]);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1250);
	_serSysEncInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_r12);
	_serSysEncInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1280);
	_serSysEncInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1310);
	_serSysEncInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1310);
	_serSysEncInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1350);
	_serSysEncInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1350);
	_serSysEncInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1360);
	_serSysEncUint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional(_buffer, _size, _lidx, &p->scptm_FreqOffset_r14);
	_serSysEncInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1530);
	_serSysEncInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1530);
	_serSysEncMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(_buffer, _size, _lidx, &p->measIdleConfigSIB_r15);
	_serSysEncInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1610);
	_serSysEncInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqListExt_v1610);
	_serSysEncMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(_buffer, _size, _lidx, &p->measIdleConfigSIB_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_threshX_Q_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_threshX_Q_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCarrierFreqUTRA_FDD_threshX_Q_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->carrierFreq, _lidx);
	_serSysEncCellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_MaxUTRA, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_QualMin, _lidx);
	_serSysEncCarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional(_buffer, _size, _lidx, &p->threshX_Q_r9);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqUTRA_FDD(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_TDD(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_TDD* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->carrierFreq, _lidx);
	_serSysEncCellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_MaxUTRA, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqUTRA_TDD(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqInfoUTRA_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqInfoUTRA_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqInfoUTRA_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqInfoUTRA_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_FDD_Ext_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_FDD_Ext_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->carrierFreq_r12, _lidx);
	_serSysEncCellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	HTON_8(&_buffer[*_lidx], p->threshX_High_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_MaxUTRA_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_QualMin_r12, _lidx);
	_serSysEncCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional(_buffer, _size, _lidx, &p->threshX_Q_r12);
	_serSysEncFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(_buffer, _size, _lidx, &p->multiBandInfoList_r12);
	_serSysEncCarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqUTRA_FDD_Ext_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqUTRA_TDD_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqUTRA_TDD_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->carrierFreq_r12, _lidx);
	_serSysEncCellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	HTON_8(&_buffer[*_lidx], p->threshX_High_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_MaxUTRA_r12, _lidx);
	_serSysEncCarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqUTRA_TDD_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType6(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType6* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_FDD);
	_serSysEncCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_TDD);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionUTRA, _lidx);
	_serSysEncSpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionUTRA_SF);
	_serSysEncOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_FDD_v1250);
	_serSysEncCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_TDD_v1250);
	_serSysEncCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_FDD_Ext_r12);
	_serSysEncCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(_buffer, _size, _lidx, &p->carrierFreqListUTRA_TDD_Ext_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->arfcn_Spacing, _lidx);
	HTON_8(&_buffer[*_lidx], p->numberOfFollowingARFCNs, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsGERAN_followingARFCNs_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CarrierFreqsGERAN_followingARFCNs_Value* p, enum CarrierFreqsGERAN_followingARFCNs_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CarrierFreqsGERAN_followingARFCNs_explicitListOfARFCNs) {
		HTON_32(&_buffer[*_lidx], p->explicitListOfARFCNs.d, _lidx);
		for (size_t i3 = 0; i3 < p->explicitListOfARFCNs.d; i3++) {
			HTON_16(&_buffer[*_lidx], p->explicitListOfARFCNs.v[i3], _lidx);
		}
	}
	if (d == CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs) {
		_serSysEncCarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs(_buffer, _size, _lidx, &p->equallySpacedARFCNs);
	}
	if (d == CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs) {
		HTON_32(&_buffer[*_lidx], p->variableBitMapOfARFCNs.d, _lidx);
		for (size_t i3 = 0; i3 < p->variableBitMapOfARFCNs.d; i3++) {
			HTON_8(&_buffer[*_lidx], p->variableBitMapOfARFCNs.v[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsGERAN_followingARFCNs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsGERAN_followingARFCNs* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCarrierFreqsGERAN_followingARFCNs_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsGERAN(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsGERAN* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->startingARFCN, _lidx);
	{
		size_t _tmp = (size_t)p->bandIndicator;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCarrierFreqsGERAN_followingARFCNs(_buffer, _size, _lidx, &p->followingARFCNs);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsInfoGERAN_commonInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsInfoGERAN_commonInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	for (size_t i3 = 0; i3 < 8; i3++) {
		HTON_8(&_buffer[*_lidx], p->ncc_Permitted[i3], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serSysEncUint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional(_buffer, _size, _lidx, &p->p_MaxGERAN);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsInfoGERAN(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsInfoGERAN* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCarrierFreqsGERAN(_buffer, _size, _lidx, &p->carrierFreqs);
	_serSysEncCarrierFreqsInfoGERAN_commonInfo(_buffer, _size, _lidx, &p->commonInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqsInfoGERAN(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType7(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType7* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->t_ReselectionGERAN, _lidx);
	_serSysEncSpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionGERAN_SF);
	_serSysEncCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(_buffer, _size, _lidx, &p->carrierFreqsInfoList);
	_serSysEncOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemTimeInfoCDMA2000_cdma_SystemTime_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemTimeInfoCDMA2000_cdma_SystemTime_Value* p, enum SystemTimeInfoCDMA2000_cdma_SystemTime_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime) {
		for (size_t i2 = 0; i2 < 39; i2++) {
			HTON_8(&_buffer[*_lidx], p->synchronousSystemTime[i2], _lidx);
		}
	}
	if (d == SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime) {
		for (size_t i2 = 0; i2 < 49; i2++) {
			HTON_8(&_buffer[*_lidx], p->asynchronousSystemTime[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemTimeInfoCDMA2000_cdma_SystemTime(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemTimeInfoCDMA2000_cdma_SystemTime* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemTimeInfoCDMA2000_cdma_SystemTime_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemTimeInfoCDMA2000(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemTimeInfoCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->cdma_EUTRA_Synchronisation, _lidx);
	_serSysEncSystemTimeInfoCDMA2000_cdma_SystemTime(_buffer, _size, _lidx, &p->cdma_SystemTime);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemTimeInfoCDMA2000(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType8_searchWindowSize_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType8_searchWindowSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPreRegistrationInfoHRPD(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PreRegistrationInfoHRPD* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->preRegistrationAllowed, _lidx);
	_serSysEncPreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional(_buffer, _size, _lidx, &p->preRegistrationZoneId);
	_serSysEncSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(_buffer, _size, _lidx, &p->secondaryPreRegistrationZoneIdList);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBandClassInfoCDMA2000(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BandClassInfoCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->bandClass;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellsPerBandclassCDMA2000(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellsPerBandclassCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->arfcn, _lidx);
	HTON_32(&_buffer[*_lidx], p->physCellIdList.d, _lidx);
	for (size_t i4 = 0; i4 < p->physCellIdList.d; i4++) {
		HTON_16(&_buffer[*_lidx], p->physCellIdList.v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellCDMA2000(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->bandClass;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->neighCellsPerFreqList.d, _lidx);
	for (size_t i3 = 0; i3 < p->neighCellsPerFreqList.d; i3++) {
		_serSysEncNeighCellsPerBandclassCDMA2000(_buffer, _size, _lidx, &p->neighCellsPerFreqList.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->bandClassList.d, _lidx);
	for (size_t i2 = 0; i2 < p->bandClassList.d; i2++) {
		_serSysEncBandClassInfoCDMA2000(_buffer, _size, _lidx, &p->bandClassList.v[i2]);
	}
	HTON_32(&_buffer[*_lidx], p->neighCellList.d, _lidx);
	for (size_t i2 = 0; i2 < p->neighCellList.d; i2++) {
		_serSysEncNeighCellCDMA2000(_buffer, _size, _lidx, &p->neighCellList.v[i2]);
	}
	HTON_8(&_buffer[*_lidx], p->t_ReselectionCDMA2000, _lidx);
	_serSysEncSpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionCDMA2000_SF);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8_parametersHRPD(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8_parametersHRPD* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPreRegistrationInfoHRPD(_buffer, _size, _lidx, &p->preRegistrationInfoHRPD);
	_serSysEncCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(_buffer, _size, _lidx, &p->cellReselectionParametersHRPD);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType8_parametersHRPD(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 15; i2++) {
		HTON_8(&_buffer[*_lidx], p->sid[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->nid[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->multipleSID, _lidx);
	HTON_8(&_buffer[*_lidx], p->multipleNID, _lidx);
	HTON_8(&_buffer[*_lidx], p->homeReg, _lidx);
	HTON_8(&_buffer[*_lidx], p->foreignSIDReg, _lidx);
	HTON_8(&_buffer[*_lidx], p->foreignNIDReg, _lidx);
	HTON_8(&_buffer[*_lidx], p->parameterReg, _lidx);
	HTON_8(&_buffer[*_lidx], p->powerUpReg, _lidx);
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->registrationPeriod[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 12; i2++) {
		HTON_8(&_buffer[*_lidx], p->registrationZone[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 3; i2++) {
		HTON_8(&_buffer[*_lidx], p->totalZone[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 3; i2++) {
		HTON_8(&_buffer[*_lidx], p->zoneTimer[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSFB_RegistrationParam1XRTT(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 42; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8_parameters1XRTT(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8_parameters1XRTT* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT);
	_serSysEncB42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional(_buffer, _size, _lidx, &p->longCodeState1XRTT);
	_serSysEncCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(_buffer, _size, _lidx, &p->cellReselectionParameters1XRTT);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType8_parameters1XRTT(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellsPerBandclassCDMA2000_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellsPerBandclassCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->physCellIdList_v920.d, _lidx);
	for (size_t i4 = 0; i4 < p->physCellIdList_v920.d; i4++) {
		HTON_16(&_buffer[*_lidx], p->physCellIdList_v920.v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellCDMA2000_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->neighCellsPerFreqList_v920.d, _lidx);
	for (size_t i3 = 0; i3 < p->neighCellsPerFreqList_v920.d; i3++) {
		_serSysEncNeighCellsPerBandclassCDMA2000_v920(_buffer, _size, _lidx, &p->neighCellsPerFreqList_v920.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->neighCellList_v920.d, _lidx);
	for (size_t i2 = 0; i2 < p->neighCellList_v920.d; i2++) {
		_serSysEncNeighCellCDMA2000_v920(_buffer, _size, _lidx, &p->neighCellList_v920.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerDownReg_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSFB_RegistrationParam1XRTT_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig1XRTT_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig1XRTT_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ac_Barring0to9_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring10_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring11_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring12_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring13_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring14_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_Barring15_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_BarringMsg_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_BarringReg_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->ac_BarringEmg_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig1XRTT_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_systemTimeInfo_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ParametersCDMA2000_r11_systemTimeInfo_r11_Value* p, enum ParametersCDMA2000_r11_systemTimeInfo_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ParametersCDMA2000_r11_systemTimeInfo_r11_explicitValue) {
		_serSysEncSystemTimeInfoCDMA2000(_buffer, _size, _lidx, &p->explicitValue);
	}
	if (d == ParametersCDMA2000_r11_systemTimeInfo_r11_defaultValue) {
		HTON_8(&_buffer[*_lidx], p->defaultValue, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_systemTimeInfo_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_systemTimeInfo_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncParametersCDMA2000_r11_systemTimeInfo_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncParametersCDMA2000_r11_systemTimeInfo_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellsPerBandclassCDMA2000_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellsPerBandclassCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->arfcn, _lidx);
	HTON_32(&_buffer[*_lidx], p->physCellIdList_r11.d, _lidx);
	for (size_t i5 = 0; i5 < p->physCellIdList_r11.d; i5++) {
		HTON_16(&_buffer[*_lidx], p->physCellIdList_r11.v[i5], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNeighCellCDMA2000_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NeighCellCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->bandClass;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->neighFreqInfoList_r11.d, _lidx);
	for (size_t i4 = 0; i4 < p->neighFreqInfoList_r11.d; i4++) {
		_serSysEncNeighCellsPerBandclassCDMA2000_r11(_buffer, _size, _lidx, &p->neighFreqInfoList_r11.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->bandClassList.d, _lidx);
	for (size_t i3 = 0; i3 < p->bandClassList.d; i3++) {
		_serSysEncBandClassInfoCDMA2000(_buffer, _size, _lidx, &p->bandClassList.v[i3]);
	}
	HTON_32(&_buffer[*_lidx], p->neighCellList_r11.d, _lidx);
	for (size_t i3 = 0; i3 < p->neighCellList_r11.d; i3++) {
		_serSysEncNeighCellCDMA2000_r11(_buffer, _size, _lidx, &p->neighCellList_r11.v[i3]);
	}
	HTON_8(&_buffer[*_lidx], p->t_ReselectionCDMA2000, _lidx);
	_serSysEncSpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionCDMA2000_SF);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_parametersHRPD_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_parametersHRPD_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPreRegistrationInfoHRPD(_buffer, _size, _lidx, &p->preRegistrationInfoHRPD_r11);
	_serSysEncCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(_buffer, _size, _lidx, &p->cellReselectionParametersHRPD_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncParametersCDMA2000_r11_parametersHRPD_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSFB_RegistrationParam1XRTT(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSFB_RegistrationParam1XRTT_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 42; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellReselectionParametersCDMA2000_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAC_BarringConfig1XRTT_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_parameters1XRTT_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_parameters1XRTT_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_r11);
	_serSysEncCSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_Ext_r11);
	_serSysEncB42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional(_buffer, _size, _lidx, &p->longCodeState1XRTT_r11);
	_serSysEncCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(_buffer, _size, _lidx, &p->cellReselectionParameters1XRTT_r11);
	_serSysEncAC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional(_buffer, _size, _lidx, &p->ac_BarringConfig1XRTT_r11);
	_serSysEncBool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional(_buffer, _size, _lidx, &p->csfb_SupportForDualRxUEs_r11);
	_serSysEncParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional(_buffer, _size, _lidx, &p->csfb_DualRxTxSupport_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncParametersCDMA2000_r11_parameters1XRTT_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncParametersCDMA2000_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ParametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional(_buffer, _size, _lidx, &p->systemTimeInfo_r11);
	HTON_8(&_buffer[*_lidx], p->searchWindowSize_r11, _lidx);
	_serSysEncParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(_buffer, _size, _lidx, &p->parametersHRPD_r11);
	_serSysEncParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(_buffer, _size, _lidx, &p->parameters1XRTT_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SIB8_PerPLMN_r11_parametersCDMA2000_r11_Value* p, enum SIB8_PerPLMN_r11_parametersCDMA2000_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SIB8_PerPLMN_r11_parametersCDMA2000_r11_explicitValue) {
		_serSysEncParametersCDMA2000_r11(_buffer, _size, _lidx, &p->explicitValue);
	}
	if (d == SIB8_PerPLMN_r11_parametersCDMA2000_r11_defaultValue) {
		HTON_8(&_buffer[*_lidx], p->defaultValue, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSIB8_PerPLMN_r11_parametersCDMA2000_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SIB8_PerPLMN_r11_parametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSIB8_PerPLMN_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SIB8_PerPLMN_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_Identity_r11, _lidx);
	_serSysEncSIB8_PerPLMN_r11_parametersCDMA2000_r11(_buffer, _size, _lidx, &p->parametersCDMA2000_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSIB8_PerPLMN_r11(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType8(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType8* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional(_buffer, _size, _lidx, &p->systemTimeInfo);
	_serSysEncUint8_t_SystemInformationBlockType8_searchWindowSize_Optional(_buffer, _size, _lidx, &p->searchWindowSize);
	_serSysEncSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(_buffer, _size, _lidx, &p->parametersHRPD);
	_serSysEncSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(_buffer, _size, _lidx, &p->parameters1XRTT);
	_serSysEncOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncBool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional(_buffer, _size, _lidx, &p->csfb_SupportForDualRxUEs_r9);
	_serSysEncCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(_buffer, _size, _lidx, &p->cellReselectionParametersHRPD_v920);
	_serSysEncCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(_buffer, _size, _lidx, &p->cellReselectionParameters1XRTT_v920);
	_serSysEncCSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_v920);
	_serSysEncAC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional(_buffer, _size, _lidx, &p->ac_BarringConfig1XRTT_r9);
	_serSysEncSystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional(_buffer, _size, _lidx, &p->csfb_DualRxTxSupport_r10);
	_serSysEncSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(_buffer, _size, _lidx, &p->sib8_PerPLMN_List_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(_buffer, _size, _lidx, &p->hnb_Name);
	_serSysEncOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncO50_SystemInformationBlockType10_dummy_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O50_SystemInformationBlockType10_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 50; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType10* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningType[i2], _lidx);
	}
	_serSysEncO50_SystemInformationBlockType10_dummy_Optional(_buffer, _size, _lidx, &p->dummy);
	_serSysEncOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncO1_SystemInformationBlockType11_dataCodingScheme_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O1_SystemInformationBlockType11_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType11* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->warningMessageSegmentType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->warningMessageSegmentNumber, _lidx);
	HTON_32(&_buffer[*_lidx], p->warningMessageSegment.d, _lidx);
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningMessageSegment.v[i2], _lidx);
	}
	_serSysEncO1_SystemInformationBlockType11_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serSysEncOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncO1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType12_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType12_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier_r9[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber_r9[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->warningMessageSegmentType_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->warningMessageSegmentNumber_r9, _lidx);
	HTON_32(&_buffer[*_lidx], p->warningMessageSegment_r9.d, _lidx);
	for (size_t i2 = 0; i2 < p->warningMessageSegment_r9.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningMessageSegment_r9.v[i2], _lidx);
	}
	_serSysEncO1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional(_buffer, _size, _lidx, &p->dataCodingScheme_r9);
	_serSysEncOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(_buffer, _size, _lidx, &p->warningAreaCoordinatesSegment_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_mcch_Config_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_mcch_Config_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->mcch_RepetitionPeriod_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->mcch_Offset_r9, _lidx);
	{
		size_t _tmp = (size_t)p->mcch_ModificationPeriod_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i3 = 0; i3 < 6; i3++) {
		HTON_8(&_buffer[*_lidx], p->sf_AllocInfo_r9[i3], _lidx);
	}
	{
		size_t _tmp = (size_t)p->signallingMCS_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_mcch_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional(_buffer, _size, _lidx, &p->mcch_RepetitionPeriod_v1430);
	_serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional(_buffer, _size, _lidx, &p->mcch_ModificationPeriod_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->mbsfn_AreaId_r9, _lidx);
	{
		size_t _tmp = (size_t)p->non_MBSFNregionLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->notificationIndicator_r9, _lidx);
	_serSysEncMBSFN_AreaInfo_r9_mcch_Config_r9(_buffer, _size, _lidx, &p->mcch_Config_r9);
	_serSysEncMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional(_buffer, _size, _lidx, &p->mcch_Config_r14);
	_serSysEncMBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional(_buffer, _size, _lidx, &p->subcarrierSpacingMBMS_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_NotificationConfig_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_NotificationConfig_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->notificationRepetitionCoeff_r9;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->notificationOffset_r9, _lidx);
	HTON_8(&_buffer[*_lidx], p->notificationSF_Index_r9, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_NotificationConfig_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_NotificationConfig_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->notificationSF_Index_v1430, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMBMS_NotificationConfig_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r16_mcch_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r16_mcch_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->mcch_RepetitionPeriod_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mcch_ModificationPeriod_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->mcch_Offset_r16, _lidx);
	for (size_t i3 = 0; i3 < 10; i3++) {
		HTON_8(&_buffer[*_lidx], p->sf_AllocInfo_r16[i3], _lidx);
	}
	{
		size_t _tmp = (size_t)p->signallingMCS_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->mbsfn_AreaId_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->notificationIndicator_r16, _lidx);
	_serSysEncMBSFN_AreaInfo_r16_mcch_Config_r16(_buffer, _size, _lidx, &p->mcch_Config_r16);
	{
		size_t _tmp = (size_t)p->subcarrierSpacingMBMS_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional(_buffer, _size, _lidx, &p->timeSeparation_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBSFN_AreaInfo_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType13_r9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType13_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->mbsfn_AreaInfoList_r9.d, _lidx);
	for (size_t i2 = 0; i2 < p->mbsfn_AreaInfoList_r9.d; i2++) {
		_serSysEncMBSFN_AreaInfo_r9(_buffer, _size, _lidx, &p->mbsfn_AreaInfoList_r9.v[i2]);
	}
	_serSysEncMBMS_NotificationConfig_r9(_buffer, _size, _lidx, &p->notificationConfig_r9);
	_serSysEncOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncMBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional(_buffer, _size, _lidx, &p->notificationConfig_v1430);
	_serSysEncMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(_buffer, _size, _lidx, &p->mbsfn_AreaInfoList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncEAB_Config_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EAB_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->eab_Category_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i2 = 0; i2 < 10; i2++) {
		HTON_8(&_buffer[*_lidx], p->eab_BarringBitmap_r11[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEAB_Config_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEAB_ConfigPLMN_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EAB_ConfigPLMN_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional(_buffer, _size, _lidx, &p->eab_Config_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType14_r11_eab_Param_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType14_r11_eab_Param_r11_Value* p, enum SystemInformationBlockType14_r11_eab_Param_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType14_r11_eab_Param_r11_eab_Common_r11) {
		_serSysEncEAB_Config_r11(_buffer, _size, _lidx, &p->eab_Common_r11);
	}
	if (d == SystemInformationBlockType14_r11_eab_Param_r11_eab_PerPLMN_List_r11) {
		HTON_32(&_buffer[*_lidx], p->eab_PerPLMN_List_r11.d, _lidx);
		for (size_t i2 = 0; i2 < p->eab_PerPLMN_List_r11.d; i2++) {
			_serSysEncEAB_ConfigPLMN_r11(_buffer, _size, _lidx, &p->eab_PerPLMN_List_r11.v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType14_r11_eab_Param_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType14_r11_eab_Param_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType14_r11_eab_Param_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType14_r11_eab_Param_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType14_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType14_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(_buffer, _size, _lidx, &p->eab_Param_r11);
	_serSysEncOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional(_buffer, _size, _lidx, &p->eab_PerRSRP_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_SAI_InterFreq_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_SAI_InterFreq_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->dl_CarrierFreq_r11, _lidx);
	HTON_32(&_buffer[*_lidx], p->mbms_SAI_List_r11.d, _lidx);
	for (size_t i3 = 0; i3 < p->mbms_SAI_List_r11.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->mbms_SAI_List_r11.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBMS_SAI_InterFreq_r11(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_SAI_InterFreq_v1140(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_SAI_InterFreq_v1140* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(_buffer, _size, _lidx, &p->multiBandInfoList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBMS_SAI_InterFreq_v1140(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_CarrierType_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_CarrierType_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->carrierType_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional(_buffer, _size, _lidx, &p->frameOffset_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMBMS_CarrierType_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncMBMS_CarrierType_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType15_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType15_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(_buffer, _size, _lidx, &p->mbms_SAI_IntraFreq_r11);
	_serSysEncMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(_buffer, _size, _lidx, &p->mbms_SAI_InterFreqList_r11);
	_serSysEncOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(_buffer, _size, _lidx, &p->mbms_SAI_InterFreqList_v1140);
	_serSysEncMBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional(_buffer, _size, _lidx, &p->mbms_IntraFreqCarrierType_r14);
	_serSysEncMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(_buffer, _size, _lidx, &p->mbms_InterFreqCarrierTypeList_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncB2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInt16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncInt8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType16_r11_timeInfo_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType16_r11_timeInfo_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->timeInfoUTC_r11, _lidx);
	_serSysEncB2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional(_buffer, _size, _lidx, &p->dayLightSavingTime_r11);
	_serSysEncInt16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional(_buffer, _size, _lidx, &p->leapSeconds_r11);
	_serSysEncInt8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional(_buffer, _size, _lidx, &p->localTimeOffset_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType16_r11_timeInfo_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncReferenceTime_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReferenceTime_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->refDays_r15, _lidx);
	HTON_32(&_buffer[*_lidx], p->refSeconds_r15, _lidx);
	HTON_16(&_buffer[*_lidx], p->refMilliSeconds_r15, _lidx);
	HTON_16(&_buffer[*_lidx], p->refQuarterMicroSeconds_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncTimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncTimeReferenceInfo_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimeReferenceInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncReferenceTime_r15(_buffer, _size, _lidx, &p->time_r15);
	_serSysEncUint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional(_buffer, _size, _lidx, &p->uncertainty_r15);
	_serSysEncTimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional(_buffer, _size, _lidx, &p->timeInfoType_r15);
	_serSysEncUint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional(_buffer, _size, _lidx, &p->referenceSFN_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncTimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTimeReferenceInfo_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType16_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType16_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional(_buffer, _size, _lidx, &p->timeInfo_r11);
	_serSysEncOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncTimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional(_buffer, _size, _lidx, &p->timeReferenceInfo_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRP_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRP_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdRSRP_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdRSRP_High_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRP_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_High_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_OnAllSymbolsWithWB_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_OnAllSymbolsWithWB_High_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_OnAllSymbolsLow_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_OnAllSymbolsHigh_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_WB_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdRSRQ_WB_High_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdChannelUtilization_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdChannelUtilizationLow_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdChannelUtilizationHigh_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->thresholdBackhaulDL_BandwidthLow_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->thresholdBackhaulDL_BandwidthHigh_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->thresholdBackhaulUL_BandwidthLow_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->thresholdBackhaulUL_BandwidthHigh_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->thresholdWLAN_RSSI_Low_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->thresholdWLAN_RSSI_High_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 16; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncT_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct T_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRP_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_OnAllSymbolsWithWB_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_OnAllSymbols_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_WB_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional(_buffer, _size, _lidx, &p->thresholdChannelUtilization_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional(_buffer, _size, _lidx, &p->thresholdBackhaul_Bandwidth_r12);
	_serSysEncWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional(_buffer, _size, _lidx, &p->thresholdWLAN_RSSI_r12);
	_serSysEncB16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional(_buffer, _size, _lidx, &p->offloadPreferenceIndicator_r12);
	_serSysEncT_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional(_buffer, _size, _lidx, &p->t_SteeringWLAN_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncWLAN_OffloadConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncO6_WLAN_Identifiers_r12_bssid_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O6_WLAN_Identifiers_r12_bssid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 6; i4++) {
		HTON_8(&_buffer[*_lidx], p->v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncO6_WLAN_Identifiers_r12_hessid_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O6_WLAN_Identifiers_r12_hessid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 6; i4++) {
		HTON_8(&_buffer[*_lidx], p->v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_Identifiers_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_Identifiers_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(_buffer, _size, _lidx, &p->ssid_r12);
	_serSysEncO6_WLAN_Identifiers_r12_bssid_r12_Optional(_buffer, _size, _lidx, &p->bssid_r12);
	_serSysEncO6_WLAN_Identifiers_r12_hessid_r12_Optional(_buffer, _size, _lidx, &p->hessid_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncWLAN_Identifiers_r12(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadInfoPerPLMN_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadInfoPerPLMN_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncWLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional(_buffer, _size, _lidx, &p->wlan_OffloadConfigCommon_r12);
	_serSysEncWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(_buffer, _size, _lidx, &p->wlan_Id_List_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncWLAN_OffloadInfoPerPLMN_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType17_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType17_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(_buffer, _size, _lidx, &p->wlan_OffloadInfoPerPLMN_List_r12);
	_serSysEncOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicator_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_OffsetIndicator_r12_Value* p, enum SL_OffsetIndicator_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_OffsetIndicator_r12_small_r12) {
		HTON_16(&_buffer[*_lidx], p->small_r12, _lidx);
	}
	if (d == SL_OffsetIndicator_r12_large_r12) {
		HTON_16(&_buffer[*_lidx], p->large_r12, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicator_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicator_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_OffsetIndicator_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSubframeBitmapSL_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SubframeBitmapSL_r12_Value* p, enum SubframeBitmapSL_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubframeBitmapSL_r12_bs4_r12) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs4_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs8_r12) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs8_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs12_r12) {
		for (size_t i3 = 0; i3 < 12; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs12_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs16_r12) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs16_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs30_r12) {
		for (size_t i3 = 0; i3 < 30; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs30_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs40_r12) {
		for (size_t i3 = 0; i3 < 40; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs40_r12[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs42_r12) {
		for (size_t i3 = 0; i3 < 42; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs42_r12[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSubframeBitmapSL_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubframeBitmapSL_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSubframeBitmapSL_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TF_ResourceConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TF_ResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->prb_Num_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->prb_Start_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->prb_End_r12, _lidx);
	_serSysEncSL_OffsetIndicator_r12(_buffer, _size, _lidx, &p->offsetIndicator_r12);
	_serSysEncSubframeBitmapSL_r12(_buffer, _size, _lidx, &p->subframeBitmap_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_HoppingConfigComm_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_HoppingConfigComm_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->hoppingParameter_r12, _lidx);
	{
		size_t _tmp = (size_t)p->numSubbands_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->rb_Offset_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->data_TF_ResourceConfig_r12);
	_serSysEncSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(_buffer, _size, _lidx, &p->trpt_Subset_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_rxParametersNCell_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_rxParametersNCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional(_buffer, _size, _lidx, &p->tdd_Config_r12);
	HTON_8(&_buffer[*_lidx], p->syncConfigIndex_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePool_r12_rxParametersNCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TxParameters_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TxParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->alpha_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_txParameters_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->sc_TxParameters_r12);
	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->dataTxParameters_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePool_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePool_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePool_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sc_CP_Len_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sc_Period_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->sc_TF_ResourceConfig_r12);
	{
		size_t _tmp = (size_t)p->data_CP_Len_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_HoppingConfigComm_r12(_buffer, _size, _lidx, &p->dataHoppingConfig_r12);
	_serSysEncSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(_buffer, _size, _lidx, &p->ue_SelectedResourceConfig_r12);
	_serSysEncSL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional(_buffer, _size, _lidx, &p->rxParametersNCell_r12);
	_serSysEncSL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysEncSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(_buffer, _size, _lidx, &p->priorityList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 19; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_txParameters_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->syncTxParameters_r12);
	HTON_8(&_buffer[*_lidx], p->syncTxThreshIC_r12, _lidx);
	_serSysEncB19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional(_buffer, _size, _lidx, &p->syncInfoReserved_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncConfig_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_rxParamsNCell_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_rxParamsNCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId_r12, _lidx);
	{
		size_t _tmp = (size_t)p->discSyncWindow_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncConfig_r12_rxParamsNCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->syncCP_Len_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->syncOffsetIndicator_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->slssid_r12, _lidx);
	_serSysEncSL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysEncSL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional(_buffer, _size, _lidx, &p->rxParamsNCell_r12);
	_serSysEncSL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(_buffer, _size, _lidx, &p->syncTxPeriodic_r13);
	_serSysEncSL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator_v1430);
	_serSysEncSL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator2_r14);
	_serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator3_r14);
	_serSysEncSL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(_buffer, _size, _lidx, &p->slss_TxDisabled_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType18_r12_commConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType18_r12_commConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->commRxPool_r12.d, _lidx);
	for (size_t i2 = 0; i2 < p->commRxPool_r12.d; i2++) {
		_serSysEncSL_CommResourcePool_r12(_buffer, _size, _lidx, &p->commRxPool_r12.v[i2]);
	}
	_serSysEncSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(_buffer, _size, _lidx, &p->commTxPoolNormalCommon_r12);
	_serSysEncSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(_buffer, _size, _lidx, &p->commTxPoolExceptional_r12);
	_serSysEncSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(_buffer, _size, _lidx, &p->commSyncConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType18_r12_commConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType18_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType18_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(_buffer, _size, _lidx, &p->commConfig_r12);
	_serSysEncOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(_buffer, _size, _lidx, &p->commTxPoolNormalCommonExt_r13);
	_serSysEncSystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional(_buffer, _size, _lidx, &p->commTxResourceUC_ReqAllowed_r13);
	_serSysEncSystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional(_buffer, _size, _lidx, &p->commTxAllowRelayCommon_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PoolSelectionConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PoolSelectionConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshLow_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshHigh_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value* p, enum SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_rsrpBased_r12) {
		_serSysEncSL_PoolSelectionConfig_r12(_buffer, _size, _lidx, &p->rsrpBased_r12);
	}
	if (d == SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_random_r12) {
		HTON_8(&_buffer[*_lidx], p->random_r12, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12(_buffer, _size, _lidx, &p->poolSelection_r12);
	{
		size_t _tmp = (size_t)p->txProbability_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->txParametersGeneral_r12);
	_serSysEncSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(_buffer, _size, _lidx, &p->ue_SelectedResourceConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParameters_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_rxParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional(_buffer, _size, _lidx, &p->tdd_Config_r12);
	HTON_8(&_buffer[*_lidx], p->syncConfigIndex_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_rxParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_discPeriod_v1310_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscResourcePool_r12_discPeriod_v1310_Value* p, enum SL_DiscResourcePool_r12_discPeriod_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_discPeriod_v1310_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SL_DiscResourcePool_r12_discPeriod_v1310_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_discPeriod_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_discPeriod_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscResourcePool_r12_discPeriod_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_discPeriod_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->physCellId_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->physCellId_r13.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->physCellId_r13.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup) {
		_serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional(_buffer, _size, _lidx, &p->ul_CarrierFreq);
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(_buffer, _size, _lidx, &p->ul_Bandwidth);
	HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmission, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->physCellId_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->physCellId_r13.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->physCellId_r13.v[i3], _lidx);
	}
	_serSysEncP_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serSysEncTDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional(_buffer, _size, _lidx, &p->tdd_Config_r13);
	_serSysEncTDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo(_buffer, _size, _lidx, &p->freqInfo);
	HTON_8(&_buffer[*_lidx], p->referenceSignalPower, _lidx);
	_serSysEncUint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional(_buffer, _size, _lidx, &p->syncConfigIndex_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup) {
		_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->additionalSpectrumEmission_v1370, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370(_buffer, _size, _lidx, &p->freqInfo_v1370);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value* p, enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup) {
		_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscResourcePool_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscResourcePool_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cp_Len_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->discPeriod_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->numRetx_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->numRepetition_r12, _lidx);
	_serSysEncSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->tf_ResourceConfig_r12);
	_serSysEncSL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysEncSL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional(_buffer, _size, _lidx, &p->rxParameters_r12);
	_serSysEncSL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional(_buffer, _size, _lidx, &p->discPeriod_v1310);
	_serSysEncSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(_buffer, _size, _lidx, &p->rxParamsAddNeighFreq_r13);
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(_buffer, _size, _lidx, &p->txParamsAddNeighFreq_r13);
	_serSysEncSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional(_buffer, _size, _lidx, &p->txParamsAddNeighFreq_v1370);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxPowerInfo_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxPowerInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->discMaxTxPower_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		_serSysEncSL_DiscTxPowerInfo_r12(_buffer, _size, _lidx, &p->v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->discRxPool_r12.d, _lidx);
	for (size_t i2 = 0; i2 < p->discRxPool_r12.d; i2++) {
		_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->discRxPool_r12.v[i2]);
	}
	_serSysEncSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(_buffer, _size, _lidx, &p->discTxPoolCommon_r12);
	_serSysEncSL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional(_buffer, _size, _lidx, &p->discTxPowerInfo_r12);
	_serSysEncSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(_buffer, _size, _lidx, &p->discSyncConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType19_r12_discConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo2_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PLMN_IdentityInfo2_r12_Value* p, enum PLMN_IdentityInfo2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PLMN_IdentityInfo2_r12_plmn_Index_r12) {
		HTON_8(&_buffer[*_lidx], p->plmn_Index_r12, _lidx);
	}
	if (d == PLMN_IdentityInfo2_r12_plmnIdentity_r12) {
		_serSysEncPLMN_Identity(_buffer, _size, _lidx, &p->plmnIdentity_r12);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo2_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPLMN_IdentityInfo2_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPLMN_IdentityInfo2_r12(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CarrierFreqInfo_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CarrierFreqInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq_r12, _lidx);
	_serSysEncPLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(_buffer, _size, _lidx, &p->plmn_IdentityList_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CarrierFreqInfo_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxResourcesInterFreq_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_DiscTxResourcesInterFreq_r13_Value* p, enum SL_DiscTxResourcesInterFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscTxResourcesInterFreq_r13_acquireSI_FromCarrier_r13) {
		HTON_8(&_buffer[*_lidx], p->acquireSI_FromCarrier_r13, _lidx);
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_discTxPoolCommon_r13) {
		HTON_32(&_buffer[*_lidx], p->discTxPoolCommon_r13.d, _lidx);
		for (size_t i3 = 0; i3 < p->discTxPoolCommon_r13.d; i3++) {
			_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->discTxPoolCommon_r13.v[i3]);
		}
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_requestDedicated_r13) {
		HTON_8(&_buffer[*_lidx], p->requestDedicated_r13, _lidx);
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_noTxOnCarrier_r13) {
		HTON_8(&_buffer[*_lidx], p->noTxOnCarrier_r13, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxResourcesInterFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxResourcesInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_DiscTxResourcesInterFreq_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscTxResourcesInterFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ResourcesInterFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ResourcesInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(_buffer, _size, _lidx, &p->discRxResourcesInterFreq_r13);
	_serSysEncSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(_buffer, _size, _lidx, &p->discTxResourcesInterFreq_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_ResourcesInterFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_ResourcesInterFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 3; i3++) {
		_serSysEncSL_DiscTxPowerInfo_r12(_buffer, _size, _lidx, &p->v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_asyncParameters_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_asyncParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->syncCP_Len_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->syncOffsetIndicator_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->slssid_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncConfigNFreq_r13_asyncParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 19; i4++) {
		HTON_8(&_buffer[*_lidx], p->v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_txParameters_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_txParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->syncTxParameters_r13);
	HTON_8(&_buffer[*_lidx], p->syncTxThreshIC_r13, _lidx);
	_serSysEncB19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional(_buffer, _size, _lidx, &p->syncInfoReserved_r13);
	_serSysEncSL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(_buffer, _size, _lidx, &p->syncTxPeriodic_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncConfigNFreq_r13_txParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_rxParameters_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_rxParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->discSyncWindow_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncConfigNFreq_r13_rxParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigNFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigNFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional(_buffer, _size, _lidx, &p->asyncParameters_r13);
	_serSysEncSL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional(_buffer, _size, _lidx, &p->txParameters_r13);
	_serSysEncSL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional(_buffer, _size, _lidx, &p->rxParameters_r13);
	_serSysEncSL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator_v1430);
	_serSysEncSL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator2_r14);
	_serSysEncSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator3_r14);
	_serSysEncSL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(_buffer, _size, _lidx, &p->slss_TxDisabled_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_SyncConfigNFreq_r13(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoNFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoNFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r13, _lidx);
	_serSysEncUint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);
	{
		size_t _tmp = (size_t)p->q_Hyst_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->q_RxLevMinReselection_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionEUTRA_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoNFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigOtherInterFreq_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigOtherInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional(_buffer, _size, _lidx, &p->txPowerInfo_r13);
	_serSysEncSL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional(_buffer, _size, _lidx, &p->refCarrierCommon_r13);
	_serSysEncSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(_buffer, _size, _lidx, &p->discSyncConfig_r13);
	_serSysEncCellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional(_buffer, _size, _lidx, &p->discCellSelectionInfo_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_DiscConfigOtherInterFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CarrierFreqInfo_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CarrierFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(_buffer, _size, _lidx, &p->discResourcesNonPS_r13);
	_serSysEncSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(_buffer, _size, _lidx, &p->discResourcesPS_r13);
	_serSysEncSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(_buffer, _size, _lidx, &p->discConfigOther_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CarrierFreqInfo_v1310(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfig_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfig_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(_buffer, _size, _lidx, &p->discInterFreqList_v1310);
	_serSysEncSystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional(_buffer, _size, _lidx, &p->gapRequestsAllowedCommon);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType19_r12_discConfig_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigRelayUE_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigRelayUE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional(_buffer, _size, _lidx, &p->threshHigh_r13);
	_serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional(_buffer, _size, _lidx, &p->threshLow_r13);
	_serSysEncSL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional(_buffer, _size, _lidx, &p->hystMax_r13);
	_serSysEncSL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional(_buffer, _size, _lidx, &p->hystMin_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncReselectionInfoRelay_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReselectionInfoRelay_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r13, _lidx);
	{
		size_t _tmp = (size_t)p->filterCoefficient_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional(_buffer, _size, _lidx, &p->minHyst_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscConfigRemoteUE_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscConfigRemoteUE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional(_buffer, _size, _lidx, &p->threshHigh_r13);
	_serSysEncSL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional(_buffer, _size, _lidx, &p->hystMax_r13);
	_serSysEncReselectionInfoRelay_r13(_buffer, _size, _lidx, &p->reselectionInfoIC_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfigRelay_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfigRelay_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DiscConfigRelayUE_r13(_buffer, _size, _lidx, &p->relayUE_Config_r13);
	_serSysEncSL_DiscConfigRemoteUE_r13(_buffer, _size, _lidx, &p->remoteUE_Config_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType19_r12_discConfigRelay_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfigPS_13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfigPS_13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->discRxPoolPS_r13.d, _lidx);
	for (size_t i2 = 0; i2 < p->discRxPoolPS_r13.d; i2++) {
		_serSysEncSL_DiscResourcePool_r12(_buffer, _size, _lidx, &p->discRxPoolPS_r13.v[i2]);
	}
	_serSysEncSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(_buffer, _size, _lidx, &p->discTxPoolPS_Common_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType19_r12_discConfigPS_13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType19_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType19_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(_buffer, _size, _lidx, &p->discConfig_r12);
	_serSysEncSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(_buffer, _size, _lidx, &p->discInterFreqList_r12);
	_serSysEncOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(_buffer, _size, _lidx, &p->discConfig_v1310);
	_serSysEncSystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional(_buffer, _size, _lidx, &p->discConfigRelay_r13);
	_serSysEncSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(_buffer, _size, _lidx, &p->discConfigPS_13);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value* p, enum SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_fdd_r14) {
		{
			size_t _tmp = (size_t)p->fdd_r14;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_tdd_r14) {
		{
			size_t _tmp = (size_t)p->tdd_r14;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_br_BCCH_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->dummy;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->dummy2;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->mpdcch_Narrowband_SC_MCCH_r14, _lidx);
	{
		size_t _tmp = (size_t)p->mpdcch_NumRepetition_SC_MCCH_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14(_buffer, _size, _lidx, &p->mpdcch_StartSF_SC_MCCH_r14);
	{
		size_t _tmp = (size_t)p->mpdcch_PDSCH_HoppingConfig_SC_MCCH_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->sc_mcch_CarrierFreq_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->sc_mcch_Offset_BR_r14, _lidx);
	{
		size_t _tmp = (size_t)p->sc_mcch_RepetitionPeriod_BR_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sc_mcch_ModificationPeriod_BR_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value* p, enum SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf10) {
		HTON_8(&_buffer[*_lidx], p->sf10, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf20) {
		HTON_8(&_buffer[*_lidx], p->sf20, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf32) {
		HTON_8(&_buffer[*_lidx], p->sf32, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf40) {
		HTON_8(&_buffer[*_lidx], p->sf40, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf64) {
		HTON_8(&_buffer[*_lidx], p->sf64, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf80) {
		HTON_8(&_buffer[*_lidx], p->sf80, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf128) {
		HTON_8(&_buffer[*_lidx], p->sf128, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf160) {
		HTON_8(&_buffer[*_lidx], p->sf160, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf256) {
		HTON_8(&_buffer[*_lidx], p->sf256, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf320) {
		HTON_16(&_buffer[*_lidx], p->sf320, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf512) {
		HTON_16(&_buffer[*_lidx], p->sf512, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf640) {
		HTON_16(&_buffer[*_lidx], p->sf640, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf1024) {
		HTON_16(&_buffer[*_lidx], p->sf1024, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf2048) {
		HTON_16(&_buffer[*_lidx], p->sf2048, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf4096) {
		HTON_16(&_buffer[*_lidx], p->sf4096, _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf8192) {
		HTON_16(&_buffer[*_lidx], p->sf8192, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSC_MCCH_SchedulingInfo_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SC_MCCH_SchedulingInfo_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->onDurationTimerSCPTM_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->drx_InactivityTimerSCPTM_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14(_buffer, _size, _lidx, &p->schedulingPeriodStartOffsetSCPTM_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSC_MCCH_SchedulingInfo_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType20_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType20_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sc_mcch_RepetitionPeriod_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->sc_mcch_Offset_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->sc_mcch_FirstSubframe_r13, _lidx);
	_serSysEncUint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional(_buffer, _size, _lidx, &p->sc_mcch_duration_r13);
	{
		size_t _tmp = (size_t)p->sc_mcch_ModificationPeriod_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional(_buffer, _size, _lidx, &p->br_BCCH_Config_r14);
	_serSysEncSC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional(_buffer, _size, _lidx, &p->sc_mcch_SchedulingInfo_r14);
	_serSysEncSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14);
	_serSysEncSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14);
	_serSysEncSystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional(_buffer, _size, _lidx, &p->sc_mcch_RepetitionPeriod_v1470);
	_serSysEncSystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional(_buffer, _size, _lidx, &p->sc_mcch_ModificationPeriod_v1470);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_OffsetIndicator_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSubframeBitmapSL_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SubframeBitmapSL_r14_Value* p, enum SubframeBitmapSL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubframeBitmapSL_r14_bs10_r14) {
		for (size_t i3 = 0; i3 < 10; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs10_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs16_r14) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs16_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs20_r14) {
		for (size_t i3 = 0; i3 < 20; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs20_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs30_r14) {
		for (size_t i3 = 0; i3 < 30; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs30_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs40_r14) {
		for (size_t i3 = 0; i3 < 40; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs40_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs50_r14) {
		for (size_t i3 = 0; i3 < 50; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs50_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs60_r14) {
		for (size_t i3 = 0; i3 < 60; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs60_r14[i3], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs100_r14) {
		for (size_t i3 = 0; i3 < 100; i3++) {
			HTON_8(&_buffer[*_lidx], p->bs100_r14[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSubframeBitmapSL_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubframeBitmapSL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSubframeBitmapSL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14_rxParametersNCell_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14_rxParametersNCell_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional(_buffer, _size, _lidx, &p->tdd_Config_r14);
	HTON_8(&_buffer[*_lidx], p->syncConfigIndex_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePoolV2X_r14_rxParametersNCell_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_TxParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PPPP_TxConfigIndex_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PPPP_TxConfigIndex_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->priorityThreshold_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->defaultTxConfigIndex_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->cbr_ConfigIndex_r14, _lidx);
	HTON_32(&_buffer[*_lidx], p->tx_ConfigIndexList_r14.d, _lidx);
	for (size_t i4 = 0; i4 < p->tx_ConfigIndexList_r14.d; i4++) {
		HTON_8(&_buffer[*_lidx], p->tx_ConfigIndexList_r14.v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_PPPP_TxConfigIndex_r14(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_P2X_ResourceSelectionConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_P2X_ResourceSelectionConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional(_buffer, _size, _lidx, &p->partialSensing_r14);
	_serSysEncSL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional(_buffer, _size, _lidx, &p->randomSelection_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_P2X_ResourceSelectionConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncAllowed_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncAllowed_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysEncSL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional(_buffer, _size, _lidx, &p->enb_Sync_r14);
	_serSysEncSL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional(_buffer, _size, _lidx, &p->ue_Sync_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_SyncAllowed_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		{
			size_t _tmp = (size_t)p->v.v[i3];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_MinT2Value_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_MinT2Value_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->priorityList_r15.d, _lidx);
	for (size_t i4 = 0; i4 < p->priorityList_r15.d; i4++) {
		HTON_8(&_buffer[*_lidx], p->priorityList_r15.v[i4], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->minT2Value_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_MinT2Value_r15(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMCS_PSSCH_Range_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MCS_PSSCH_Range_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->minMCS_PSSCH_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->maxMCS_PSSCH_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysEncMCS_PSSCH_Range_r15(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PPPP_TxConfigIndex_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PPPP_TxConfigIndex_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(_buffer, _size, _lidx, &p->mcs_PSSCH_RangeList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_PPPP_TxConfigIndex_v1530(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional(_buffer, _size, _lidx, &p->sl_OffsetIndicator_r14);
	_serSysEncSubframeBitmapSL_r14(_buffer, _size, _lidx, &p->sl_Subframe_r14);
	HTON_8(&_buffer[*_lidx], p->adjacencyPSCCH_PSSCH_r14, _lidx);
	{
		size_t _tmp = (size_t)p->sizeSubchannel_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->numSubchannel_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->startRB_Subchannel_r14, _lidx);
	_serSysEncUint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional(_buffer, _size, _lidx, &p->startRB_PSCCH_Pool_r14);
	_serSysEncSL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional(_buffer, _size, _lidx, &p->rxParametersNCell_r14);
	_serSysEncSL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional(_buffer, _size, _lidx, &p->dataTxParameters_r14);
	_serSysEncUint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional(_buffer, _size, _lidx, &p->zoneID_r14);
	_serSysEncUint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional(_buffer, _size, _lidx, &p->threshS_RSSI_CBR_r14);
	_serSysEncSL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional(_buffer, _size, _lidx, &p->poolReportId_r14);
	_serSysEncSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(_buffer, _size, _lidx, &p->cbr_pssch_TxConfigList_r14);
	_serSysEncSL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional(_buffer, _size, _lidx, &p->resourceSelectionConfigP2X_r14);
	_serSysEncSL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional(_buffer, _size, _lidx, &p->syncAllowed_r14);
	_serSysEncSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(_buffer, _size, _lidx, &p->restrictResourceReservationPeriod_r14);
	_serSysEncSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(_buffer, _size, _lidx, &p->sl_MinT2ValueList_r15);
	_serSysEncSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(_buffer, _size, _lidx, &p->cbr_pssch_TxConfigList_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPLMN_Identity(_buffer, _size, _lidx, &p->plmn_Identity);
	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncPLMN_IdentityInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysEncSL_SyncConfigNFreq_r13(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TxPower_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_TxPower_r14_Value* p, enum SL_TxPower_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_TxPower_r14_minusinfinity_r14) {
		HTON_8(&_buffer[*_lidx], p->minusinfinity_r14, _lidx);
	}
	if (d == SL_TxPower_r14_txPower_r14) {
		HTON_8(&_buffer[*_lidx], p->txPower_r14, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TxPower_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TxPower_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_TxPower_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_TxPower_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PSSCH_TxParameters_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PSSCH_TxParameters_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->minMCS_PSSCH_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->maxMCS_PSSCH_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->minSubChannel_NumberPSSCH_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->maxSubchannel_NumberPSSCH_r14, _lidx);
	{
		size_t _tmp = (size_t)p->allowedRetxNumberPSSCH_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional(_buffer, _size, _lidx, &p->maxTxPower_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PSSCH_TxParameters_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PSSCH_TxParameters_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->minMCS_PSSCH_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->maxMCS_PSSCH_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_PSSCH_TxParameters_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_PSSCH_TxParameters_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PSSCH_TxConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PSSCH_TxConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	{
		size_t _tmp = (size_t)p->thresUE_Speed_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->parametersAboveThres_r14);
	_serSysEncSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->parametersBelowThres_r14);
	_serSysEncSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional(_buffer, _size, _lidx, &p->parametersAboveThres_v1530);
	_serSysEncSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional(_buffer, _size, _lidx, &p->parametersBelowThres_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		{
			size_t _tmp = (size_t)p->v.v[i4];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->minNumCandidateSF_r14, _lidx);
	for (size_t i4 = 0; i4 < 10; i4++) {
		HTON_8(&_buffer[*_lidx], p->gapCandidateSensing_r14[i4], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->pssch_TxConfigList_r14.d, _lidx);
	for (size_t i4 = 0; i4 < p->pssch_TxConfigList_r14.d; i4++) {
		_serSysEncSL_PSSCH_TxConfig_r14(_buffer, _size, _lidx, &p->pssch_TxConfigList_r14.v[i4]);
	}
	for (size_t i4 = 0; i4 < 64; i4++) {
		HTON_8(&_buffer[*_lidx], p->thresPSSCH_RSRP_List_r14[i4], _lidx);
	}
	_serSysEncSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(_buffer, _size, _lidx, &p->restrictResourceReservationPeriod_r14);
	{
		size_t _tmp = (size_t)p->probResourceKeep_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional(_buffer, _size, _lidx, &p->p2x_SensingConfig_r14);
	_serSysEncSL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional(_buffer, _size, _lidx, &p->sl_ReselectAfter_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommTxPoolSensingConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ZoneConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ZoneConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->zoneLength_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->zoneWidth_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->zoneIdLongiMod_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->zoneIdLatiMod_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_ZoneConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_InterFreqUE_Config_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_InterFreqUE_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(_buffer, _size, _lidx, &p->physCellIdList_r14);
	_serSysEncSL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	_serSysEncSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(_buffer, _size, _lidx, &p->v2x_SyncConfig_r14);
	_serSysEncSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommRxPool_r14);
	_serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommTxPoolNormal_r14);
	_serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(_buffer, _size, _lidx, &p->p2x_CommTxPoolNormal_r14);
	_serSysEncSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommTxPoolExceptional_r14);
	_serSysEncSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(_buffer, _size, _lidx, &p->v2x_ResourceSelectionConfig_r14);
	_serSysEncSL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional(_buffer, _size, _lidx, &p->zoneConfig_r14);
	_serSysEncUint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional(_buffer, _size, _lidx, &p->offsetDFN_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_V2X_InterFreqUE_Config_r14(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value* p, enum SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmission_r14) {
		HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmission_r14, _lidx);
	}
	if (d == SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmission_v1440) {
		HTON_16(&_buffer[*_lidx], p->additionalSpectrumEmission_v1440, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_FreqSelectionConfig_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_FreqSelectionConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->priorityList_r15.d, _lidx);
	for (size_t i4 = 0; i4 < p->priorityList_r15.d; i4++) {
		HTON_8(&_buffer[*_lidx], p->priorityList_r15.v[i4], _lidx);
	}
	_serSysEncSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional(_buffer, _size, _lidx, &p->threshCBR_FreqReselection_r15);
	_serSysEncSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional(_buffer, _size, _lidx, &p->threshCBR_FreqKeeping_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncSL_V2X_FreqSelectionConfig_r15(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoV2X_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(_buffer, _size, _lidx, &p->plmn_IdentityList_r14);
	HTON_32(&_buffer[*_lidx], p->v2x_CommCarrierFreq_r14, _lidx);
	_serSysEncP_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional(_buffer, _size, _lidx, &p->sl_MaxTxPower_r14);
	_serSysEncSL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional(_buffer, _size, _lidx, &p->sl_Bandwidth_r14);
	_serSysEncSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(_buffer, _size, _lidx, &p->v2x_SchedulingPool_r14);
	_serSysEncSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(_buffer, _size, _lidx, &p->v2x_UE_ConfigList_r14);
	_serSysEncSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmissionV2X_r14);
	_serSysEncSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(_buffer, _size, _lidx, &p->v2x_FreqSelectionConfigList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_InterFreqInfoV2X_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CommTxPoolSensingConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_ZoneConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_PSSCH_TxConfig_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_PSSCH_TxConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cr_Limit_r14, _lidx);
	_serSysEncSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->tx_Parameters_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_CommonTxConfigList_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_CommonTxConfigList_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->cbr_RangeCommonConfigList_r14.d, _lidx);
	for (size_t i2 = 0; i2 < p->cbr_RangeCommonConfigList_r14.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->cbr_RangeCommonConfigList_r14.v[i2].d, _lidx);
		for (size_t i3 = 0; i3 < p->cbr_RangeCommonConfigList_r14.v[i2].d; i3++) {
			HTON_8(&_buffer[*_lidx], p->cbr_RangeCommonConfigList_r14.v[i2].v[i3], _lidx);
		}
	}
	HTON_32(&_buffer[*_lidx], p->sl_CBR_PSSCH_TxConfigList_r14.d, _lidx);
	for (size_t i2 = 0; i2 < p->sl_CBR_PSSCH_TxConfigList_r14.d; i2++) {
		_serSysEncSL_CBR_PSSCH_TxConfig_r14(_buffer, _size, _lidx, &p->sl_CBR_PSSCH_TxConfigList_r14.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_CBR_CommonTxConfigList_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_ConfigCommon_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_ConfigCommon_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommRxPool_r14);
	_serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommTxPoolNormalCommon_r14);
	_serSysEncSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(_buffer, _size, _lidx, &p->p2x_CommTxPoolNormalCommon_r14);
	_serSysEncSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(_buffer, _size, _lidx, &p->v2x_CommTxPoolExceptional_r14);
	_serSysEncSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(_buffer, _size, _lidx, &p->v2x_SyncConfig_r14);
	_serSysEncSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(_buffer, _size, _lidx, &p->v2x_InterFreqInfoList_r14);
	_serSysEncSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(_buffer, _size, _lidx, &p->v2x_ResourceSelectionConfig_r14);
	_serSysEncSL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional(_buffer, _size, _lidx, &p->zoneConfig_r14);
	_serSysEncSL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	_serSysEncSL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional(_buffer, _size, _lidx, &p->thresSL_TxPrioritization_r14);
	_serSysEncSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(_buffer, _size, _lidx, &p->anchorCarrierFreqList_r14);
	_serSysEncUint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional(_buffer, _size, _lidx, &p->offsetDFN_r14);
	_serSysEncSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(_buffer, _size, _lidx, &p->cbr_CommonTxConfigList_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_V2X_ConfigCommon_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType21_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType21_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(_buffer, _size, _lidx, &p->sl_V2X_ConfigCommon_r14);
	_serSysEncOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(_buffer, _size, _lidx, &p->anchorCarrierFreqListNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMTC_SSB_NR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSS_RSSI_Measurement_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNR_r15_threshX_Q_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNR_r15_threshX_Q_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCarrierFreqNR_r15_threshX_Q_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncInt8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNS_PmaxValueNR_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NS_PmaxValueNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncP_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional(_buffer, _size, _lidx, &p->additionalPmaxNR_r15);
	HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmissionNR_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysEncNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInt8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncThresholdListNR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i3].d, _lidx);
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysEncNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i3].d, _lidx);
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysEncNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSSB_ToMeasure_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNR_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq_r15, _lidx);
	_serSysEncMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(_buffer, _size, _lidx, &p->multiBandInfoList_r15);
	_serSysEncMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(_buffer, _size, _lidx, &p->multiBandInfoListSUL_r15);
	_serSysEncMTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional(_buffer, _size, _lidx, &p->measTimingConfig_r15);
	{
		size_t _tmp = (size_t)p->subcarrierSpacingSSB_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(_buffer, _size, _lidx, &p->ss_RSSI_Measurement_r15);
	_serSysEncCellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r15);
	_serSysEncCellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority_r15);
	HTON_8(&_buffer[*_lidx], p->threshX_High_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low_r15, _lidx);
	_serSysEncCarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional(_buffer, _size, _lidx, &p->threshX_Q_r15);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin_r15, _lidx);
	_serSysEncInt8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL_r15);
	HTON_8(&_buffer[*_lidx], p->p_MaxNR_r15, _lidx);
	_serSysEncNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(_buffer, _size, _lidx, &p->ns_PmaxListNR_r15);
	_serSysEncInt8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional(_buffer, _size, _lidx, &p->q_QualMin_r15);
	HTON_8(&_buffer[*_lidx], p->deriveSSB_IndexFromCell_r15, _lidx);
	_serSysEncMaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional(_buffer, _size, _lidx, &p->maxRS_IndexCellQual_r15);
	_serSysEncThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional(_buffer, _size, _lidx, &p->threshRS_Index_r15);
	_serSysEncMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(_buffer, _size, _lidx, &p->multiBandNsPmaxListNR_v1550);
	_serSysEncMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(_buffer, _size, _lidx, &p->multiBandNsPmaxListNR_SUL_v1550);
	_serSysEncSSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqNR_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB2_LP_NR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB2_LP_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(_buffer, _size, _lidx, &p->pci_List_r16);
	{
		size_t _tmp = (size_t)p->periodicity_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMTC_SSB2_LP_NR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct WhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNR_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNR_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(_buffer, _size, _lidx, &p->smtc2_LP_r16);
	_serSysEncSSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_CommonNR_r16);
	_serSysEncWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(_buffer, _size, _lidx, &p->whiteCellListNR_r16);
	_serSysEncCarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional(_buffer, _size, _lidx, &p->highSpeedCarrierNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqNR_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType24_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType24_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(_buffer, _size, _lidx, &p->carrierFreqListNR_r15);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionNR_r15, _lidx);
	_serSysEncSpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF_r15);
	_serSysEncOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(_buffer, _size, _lidx, &p->carrierFreqListNR_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerCat_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerCat_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->accessCategory_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->uac_barringInfoSetIndex_r15, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncUAC_BarringPerCat_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value* p, enum UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_ImplicitAC_BarringList_r15) {
		for (size_t i3 = 0; i3 < 63; i3++) {
			HTON_8(&_buffer[*_lidx], p->uac_ImplicitAC_BarringList_r15[i3], _lidx);
		}
	}
	if (d == UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_ExplicitAC_BarringList_r15) {
		HTON_32(&_buffer[*_lidx], p->uac_ExplicitAC_BarringList_r15.d, _lidx);
		for (size_t i3 = 0; i3 < p->uac_ExplicitAC_BarringList_r15.d; i3++) {
			_serSysEncUAC_BarringPerCat_r15(_buffer, _size, _lidx, &p->uac_ExplicitAC_BarringList_r15.v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerPLMN_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerPLMN_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r15, _lidx);
	_serSysEncUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(_buffer, _size, _lidx, &p->uac_AC_BarringListType_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncUAC_BarringPerPLMN_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUAC_BarringInfoSet_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UAC_BarringInfoSet_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->uac_BarringFactor_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->uac_BarringTime_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i3 = 0; i3 < 7; i3++) {
		HTON_8(&_buffer[*_lidx], p->uac_BarringForAccessIdentity_r15[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value* p, enum SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_plmnCommon_r15) {
		{
			size_t _tmp = (size_t)p->plmnCommon_r15;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_individualPLMNList_r15) {
		HTON_32(&_buffer[*_lidx], p->individualPLMNList_r15.d, _lidx);
		for (size_t i2 = 0; i2 < p->individualPLMNList_r15.d; i2++) {
			{
				size_t _tmp = (size_t)p->individualPLMNList_r15.v[i2];
				HTON_32(&_buffer[*_lidx], _tmp, _lidx);
			}
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType25_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType25_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(_buffer, _size, _lidx, &p->uac_BarringForCommon_r15);
	_serSysEncUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(_buffer, _size, _lidx, &p->uac_BarringPerPLMN_List_r15);
	HTON_32(&_buffer[*_lidx], p->uac_BarringInfoSetList_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->uac_BarringInfoSetList_r15.d; i2++) {
		_serSysEncUAC_BarringInfoSet_r15(_buffer, _size, _lidx, &p->uac_BarringInfoSetList_r15.v[i2]);
	}
	_serSysEncSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(_buffer, _size, _lidx, &p->uac_AC1_SelectAssistInfo_r15);
	_serSysEncOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional(_buffer, _size, _lidx, &p->ab_PerRSRP_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_InterFreqInfoV2X_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PPPP_TxConfigIndex_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PPPP_TxConfigIndex_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->priorityThreshold_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->defaultTxConfigIndex_r15, _lidx);
	HTON_8(&_buffer[*_lidx], p->cbr_ConfigIndex_r15, _lidx);
	HTON_32(&_buffer[*_lidx], p->tx_ConfigIndexList_r15.d, _lidx);
	for (size_t i3 = 0; i3 < p->tx_ConfigIndexList_r15.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->tx_ConfigIndexList_r15.v[i3], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->mcs_PSSCH_RangeList_r15.d, _lidx);
	for (size_t i3 = 0; i3 < p->mcs_PSSCH_RangeList_r15.d; i3++) {
		_serSysEncMCS_PSSCH_Range_r15(_buffer, _size, _lidx, &p->mcs_PSSCH_RangeList_r15.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_PPPP_TxConfigIndex_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		for (size_t i4 = 0; i4 < 24; i4++) {
			HTON_8(&_buffer[*_lidx], p->v.v[i3][i4], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_AllowedCarrierFreqList_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_AllowedCarrierFreqList_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->allowedCarrierFreqSet1.d, _lidx);
	for (size_t i3 = 0; i3 < p->allowedCarrierFreqSet1.d; i3++) {
		HTON_32(&_buffer[*_lidx], p->allowedCarrierFreqSet1.v[i3], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->allowedCarrierFreqSet2.d, _lidx);
	for (size_t i3 = 0; i3 < p->allowedCarrierFreqSet2.d; i3++) {
		HTON_32(&_buffer[*_lidx], p->allowedCarrierFreqSet2.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_AllowedCarrierFreqList_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PPPR_Dest_CarrierFreq(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PPPR_Dest_CarrierFreq* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(_buffer, _size, _lidx, &p->destinationInfoList_r15);
	_serSysEncSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(_buffer, _size, _lidx, &p->allowedCarrierFreqList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_PPPR_Dest_CarrierFreq(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_PacketDuplicationConfig_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_PacketDuplicationConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshSL_Reliability_r15, _lidx);
	_serSysEncSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(_buffer, _size, _lidx, &p->allowedCarrierFreqConfig_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_V2X_PacketDuplicationConfig_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncSL_V2X_FreqSelectionConfig_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType26_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType26_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(_buffer, _size, _lidx, &p->v2x_InterFreqInfoList_r15);
	_serSysEncSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(_buffer, _size, _lidx, &p->cbr_pssch_TxConfigList_r15);
	_serSysEncSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(_buffer, _size, _lidx, &p->v2x_PacketDuplicationConfig_r15);
	_serSysEncSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(_buffer, _size, _lidx, &p->syncFreqList_r15);
	_serSysEncSystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional(_buffer, _size, _lidx, &p->slss_TxMultiFreq_r15);
	_serSysEncSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(_buffer, _size, _lidx, &p->v2x_FreqSelectionConfigList_r15);
	_serSysEncUint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional(_buffer, _size, _lidx, &p->threshS_RSSI_CBR_r15);
	_serSysEncOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncB10_PLMN_Info_r16_nr_BandList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B10_PLMN_Info_r16_nr_BandList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 10; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_Info_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_Info_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncB10_PLMN_Info_r16_nr_BandList_r16_Optional(_buffer, _size, _lidx, &p->nr_BandList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType26a_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType26a_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_InfoList_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->plmn_InfoList_r16.d; i2++) {
		_serSysEncPLMN_Info_r16(_buffer, _size, _lidx, &p->plmn_InfoList_r16.v[i2]);
	}
	HTON_32(&_buffer[*_lidx], p->bandListENDC_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->bandListENDC_r16.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->bandListENDC_r16.v[i2], _lidx);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqNBIOT_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqNBIOT_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq_r16, _lidx);
	{
		size_t _tmp = (size_t)p->carrierFreqOffset_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCarrierFreqNBIOT_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType27_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType27_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(_buffer, _size, _lidx, &p->carrierFreqListNBIOT_r16);
	_serSysEncOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType28_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType28_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->segmentNumber_r16, _lidx);
	{
		size_t _tmp = (size_t)p->segmentType_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->segmentContainer_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->segmentContainer_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->segmentContainer_r16.v[i2], _lidx);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPeriodicityStartPos_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PeriodicityStartPos_r16_Value* p, enum PeriodicityStartPos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PeriodicityStartPos_r16_periodicity10ms) {
		HTON_8(&_buffer[*_lidx], p->periodicity10ms, _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity20ms) {
		HTON_8(&_buffer[*_lidx], p->periodicity20ms, _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity40ms) {
		HTON_8(&_buffer[*_lidx], p->periodicity40ms, _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity80ms) {
		HTON_8(&_buffer[*_lidx], p->periodicity80ms, _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity160ms) {
		HTON_8(&_buffer[*_lidx], p->periodicity160ms, _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare3) {
		HTON_8(&_buffer[*_lidx], p->spare3, _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare2) {
		HTON_8(&_buffer[*_lidx], p->spare2, _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare1) {
		HTON_8(&_buffer[*_lidx], p->spare1, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPeriodicityStartPos_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PeriodicityStartPos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPeriodicityStartPos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value* p, enum ResourceReservationConfigDL_r16_resourceReservationFreq_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap1dot4) {
		for (size_t i2 = 0; i2 < 6; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap1dot4[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap3) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap3[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap5) {
		for (size_t i2 = 0; i2 < 13; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap5[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap10) {
		for (size_t i2 = 0; i2 < 17; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap10[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap15) {
		for (size_t i2 = 0; i2 < 19; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap15[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap20) {
		for (size_t i2 = 0; i2 < 25; i2++) {
			HTON_8(&_buffer[*_lidx], p->rbg_Bitmap20[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigDL_r16_resourceReservationFreq_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_slotBitmap_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ResourceReservationConfigDL_r16_slotBitmap_r16_Value* p, enum ResourceReservationConfigDL_r16_slotBitmap_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigDL_r16_slotBitmap_r16_slotPattern10ms) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			HTON_8(&_buffer[*_lidx], p->slotPattern10ms[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_slotBitmap_r16_slotPattern40ms) {
		for (size_t i2 = 0; i2 < 80; i2++) {
			HTON_8(&_buffer[*_lidx], p->slotPattern40ms[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_slotBitmap_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigDL_r16_slotBitmap_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncResourceReservationConfigDL_r16_slotBitmap_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncB7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigDL_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPeriodicityStartPos_r16(_buffer, _size, _lidx, &p->periodicityStartPos_r16);
	_serSysEncResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationFreq_r16);
	_serSysEncResourceReservationConfigDL_r16_slotBitmap_r16(_buffer, _size, _lidx, &p->slotBitmap_r16);
	_serSysEncB7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap1_r16);
	_serSysEncB7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncResourceReservationConfigDL_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigUL_r16_slotBitmap_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ResourceReservationConfigUL_r16_slotBitmap_r16_Value* p, enum ResourceReservationConfigUL_r16_slotBitmap_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigUL_r16_slotBitmap_r16_slotPattern10ms) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			HTON_8(&_buffer[*_lidx], p->slotPattern10ms[i2], _lidx);
		}
	}
	if (d == ResourceReservationConfigUL_r16_slotBitmap_r16_slotPattern40ms) {
		for (size_t i2 = 0; i2 < 80; i2++) {
			HTON_8(&_buffer[*_lidx], p->slotPattern40ms[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigUL_r16_slotBitmap_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigUL_r16_slotBitmap_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncResourceReservationConfigUL_r16_slotBitmap_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncResourceReservationConfigUL_r16_slotBitmap_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigUL_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigUL_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPeriodicityStartPos_r16(_buffer, _size, _lidx, &p->periodicityStartPos_r16);
	_serSysEncResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional(_buffer, _size, _lidx, &p->slotBitmap_r16);
	_serSysEncB7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap1_r16);
	_serSysEncB7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncResourceReservationConfigUL_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType29_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType29_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationConfigCommonDL_r16);
	_serSysEncResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationConfigCommonUL_r16);
	_serSysEncOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformation_r8_IEs_sib_TypeAndInfo_s_Value* p, enum SystemInformation_r8_IEs_sib_TypeAndInfo_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib2) {
		_serSysEncSystemInformationBlockType2(_buffer, _size, _lidx, &p->sib2);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib3) {
		_serSysEncSystemInformationBlockType3(_buffer, _size, _lidx, &p->sib3);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib4) {
		_serSysEncSystemInformationBlockType4(_buffer, _size, _lidx, &p->sib4);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib5) {
		_serSysEncSystemInformationBlockType5(_buffer, _size, _lidx, &p->sib5);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib6) {
		_serSysEncSystemInformationBlockType6(_buffer, _size, _lidx, &p->sib6);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib7) {
		_serSysEncSystemInformationBlockType7(_buffer, _size, _lidx, &p->sib7);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib8) {
		_serSysEncSystemInformationBlockType8(_buffer, _size, _lidx, &p->sib8);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib9) {
		_serSysEncSystemInformationBlockType9(_buffer, _size, _lidx, &p->sib9);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib10) {
		_serSysEncSystemInformationBlockType10(_buffer, _size, _lidx, &p->sib10);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib11) {
		_serSysEncSystemInformationBlockType11(_buffer, _size, _lidx, &p->sib11);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib12_v920) {
		_serSysEncSystemInformationBlockType12_r9(_buffer, _size, _lidx, &p->sib12_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib13_v920) {
		_serSysEncSystemInformationBlockType13_r9(_buffer, _size, _lidx, &p->sib13_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib14_v1130) {
		_serSysEncSystemInformationBlockType14_r11(_buffer, _size, _lidx, &p->sib14_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib15_v1130) {
		_serSysEncSystemInformationBlockType15_r11(_buffer, _size, _lidx, &p->sib15_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib16_v1130) {
		_serSysEncSystemInformationBlockType16_r11(_buffer, _size, _lidx, &p->sib16_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib17_v1250) {
		_serSysEncSystemInformationBlockType17_r12(_buffer, _size, _lidx, &p->sib17_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib18_v1250) {
		_serSysEncSystemInformationBlockType18_r12(_buffer, _size, _lidx, &p->sib18_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib19_v1250) {
		_serSysEncSystemInformationBlockType19_r12(_buffer, _size, _lidx, &p->sib19_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib20_v1310) {
		_serSysEncSystemInformationBlockType20_r13(_buffer, _size, _lidx, &p->sib20_v1310);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib21_v1430) {
		_serSysEncSystemInformationBlockType21_r14(_buffer, _size, _lidx, &p->sib21_v1430);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib24_v1530) {
		_serSysEncSystemInformationBlockType24_r15(_buffer, _size, _lidx, &p->sib24_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib25_v1530) {
		_serSysEncSystemInformationBlockType25_r15(_buffer, _size, _lidx, &p->sib25_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26_v1530) {
		_serSysEncSystemInformationBlockType26_r15(_buffer, _size, _lidx, &p->sib26_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26a_v1610) {
		_serSysEncSystemInformationBlockType26a_r16(_buffer, _size, _lidx, &p->sib26a_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib27_v1610) {
		_serSysEncSystemInformationBlockType27_r16(_buffer, _size, _lidx, &p->sib27_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib28_v1610) {
		_serSysEncSystemInformationBlockType28_r16(_buffer, _size, _lidx, &p->sib28_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib29_v1610) {
		_serSysEncSystemInformationBlockType29_r16(_buffer, _size, _lidx, &p->sib29_v1610);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_r8_IEs_sib_TypeAndInfo_s(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_r8_IEs_sib_TypeAndInfo_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_v8a0_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_v8a0_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformation_v8a0_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_v8a0_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_v8a0_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformation_v8a0_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_r8_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_r8_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->sib_TypeAndInfo.d, _lidx);
	for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
		_serSysEncSystemInformation_r8_IEs_sib_TypeAndInfo_s(_buffer, _size, _lidx, &p->sib_TypeAndInfo.v[i1]);
	}
	_serSysEncSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockPos_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockPos_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->assistanceDataSIB_Element_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->assistanceDataSIB_Element_r15.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->assistanceDataSIB_Element_r15.v[i2], _lidx);
	}
	_serSysEncOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value* p, enum PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_1_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_2_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_3_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_4_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_5_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_6_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_7_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib1_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_1_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_2_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_3_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_4_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_5_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_6_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_7_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_8_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_8_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_9_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_9_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_10_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_10_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_11_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_11_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_12_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_12_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_13_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_13_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_14_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_14_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_15_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_15_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_16_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_16_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_17_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_17_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_18_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_18_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_19_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib2_19_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib3_1_r15) {
		_serSysEncSystemInformationBlockPos_r15(_buffer, _size, _lidx, &p->posSib3_1_r15);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSystemInformation_r15_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSystemInformation_r15_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPosSystemInformation_r15_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSystemInformation_r15_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSystemInformation_r15_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->posSIB_TypeAndInfo_r15.d, _lidx);
	for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r15.d; i1++) {
		_serSysEncPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(_buffer, _size, _lidx, &p->posSIB_TypeAndInfo_r15.v[i1]);
	}
	_serSysEncOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncPosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value* p, enum SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_posSystemInformation_r15) {
		_serSysEncPosSystemInformation_r15_IEs(_buffer, _size, _lidx, &p->posSystemInformation_r15);
	}
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture) {
		_serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture(_buffer, _size, _lidx, &p->criticalExtensionsFuture);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_criticalExtensions_criticalExtensionsFuture_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_criticalExtensions_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformation_criticalExtensions_Value* p, enum SystemInformation_criticalExtensions_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_criticalExtensions_systemInformation_r8) {
		_serSysEncSystemInformation_r8_IEs(_buffer, _size, _lidx, &p->systemInformation_r8);
	}
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15) {
		_serSysEncSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(_buffer, _size, _lidx, &p->criticalExtensionsFuture_r15);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation_criticalExtensions(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation_criticalExtensions* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformation_criticalExtensions_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformation_criticalExtensions(_buffer, _size, _lidx, &p->criticalExtensions);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 27; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_cellAccessRelatedInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_cellAccessRelatedInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_IdentityList.d, _lidx);
	for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
		_serSysEncPLMN_IdentityInfo(_buffer, _size, _lidx, &p->plmn_IdentityList.v[i1]);
	}
	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->trackingAreaCode[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 28; i1++) {
		HTON_8(&_buffer[*_lidx], p->cellIdentity[i1], _lidx);
	}
	{
		size_t _tmp = (size_t)p->cellBarred;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->intraFreqReselection;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->csg_Indication, _lidx);
	_serSysEncCSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional(_buffer, _size, _lidx, &p->csg_Identity);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_cellSelectionInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_cellSelectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serSysEncUint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_Max_SystemInformationBlockType1_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_Max_SystemInformationBlockType1_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->si_Periodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->sib_MappingInfo.d, _lidx);
	for (size_t i2 = 0; i2 < p->sib_MappingInfo.d; i2++) {
		{
			size_t _tmp = (size_t)p->sib_MappingInfo.v[i2];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_SystemInformationBlockType1_tdd_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_SystemInformationBlockType1_tdd_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_QualMin_r9, _lidx);
	_serSysEncUint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional(_buffer, _size, _lidx, &p->q_QualMinOffset_r9);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfo_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_QualMinWB_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfo_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional(_buffer, _size, _lidx, &p->category0Allowed_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_QualMinRSRQ_OnAllSymbols_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfo_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 10; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingInfo_BR_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingInfo_BR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->si_Narrowband_r13, _lidx);
	{
		size_t _tmp = (size_t)p->si_TBS_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncSchedulingInfo_BR_r13(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value* p, enum SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern10_r13) {
		for (size_t i1 = 0; i1 < 10; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframePattern10_r13[i1], _lidx);
		}
	}
	if (d == SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern40_r13) {
		for (size_t i1 = 0; i1 < 40; i1++) {
			HTON_8(&_buffer[*_lidx], p->subframePattern40_r13[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 10; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->si_WindowLength_BR_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->si_RepetitionPattern_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(_buffer, _size, _lidx, &p->schedulingInfoList_BR_r13);
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_DownlinkOrTddSubframeBitmapBR_r13);
	_serSysEncB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_UplinkSubframeBitmapBR_r13);
	HTON_8(&_buffer[*_lidx], p->startSymbolBR_r13, _lidx);
	{
		size_t _tmp = (size_t)p->si_HoppingConfigCommon_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(_buffer, _size, _lidx, &p->si_ValidityTime_r13);
	_serSysEncSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(_buffer, _size, _lidx, &p->systemInfoValueTagList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value* p, enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value* p, enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_FDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13) {
		{
			size_t _tmp = (size_t)p->interval_TDD_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_pdsch_HoppingNB_r13);
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional(_buffer, _size, _lidx, &p->interval_DLHoppingConfigCommonModeA_r13);
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional(_buffer, _size, _lidx, &p->interval_DLHoppingConfigCommonModeB_r13);
	_serSysEncUint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_pdsch_HoppingOffset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->specialSubframePatterns_v1430;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellAccessRelatedInfo_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellAccessRelatedInfo_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_IdentityList_r14.d, _lidx);
	for (size_t i2 = 0; i2 < p->plmn_IdentityList_r14.d; i2++) {
		_serSysEncPLMN_IdentityInfo(_buffer, _size, _lidx, &p->plmn_IdentityList_r14.v[i2]);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->trackingAreaCode_r14[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 28; i2++) {
		HTON_8(&_buffer[*_lidx], p->cellIdentity_r14[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCellAccessRelatedInfo_r14(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1450(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1450* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->specialSubframePatterns_v1450;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_Config_v1450(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value* p, enum SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigEnabled) {
		HTON_8(&_buffer[*_lidx], p->crs_IntfMitigEnabled, _lidx);
	}
	if (d == SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs) {
		{
			size_t _tmp = (size_t)p->crs_IntfMitigNumPRBs;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse_CRS_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPLMN_IdentityInfo_v1530(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGNSS_ID_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GNSS_ID_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->gnss_id_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncGNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct GNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncGNSS_ID_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSBAS_ID_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SBAS_ID_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sbas_id_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSBAS_ID_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSIB_Type_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSIB_Type_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional(_buffer, _size, _lidx, &p->encrypted_r15);
	_serSysEncGNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional(_buffer, _size, _lidx, &p->gnss_id_r15);
	_serSysEncSBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional(_buffer, _size, _lidx, &p->sbas_id_r15);
	{
		size_t _tmp = (size_t)p->posSibType_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSchedulingInfo_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSchedulingInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->posSI_Periodicity_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->posSIB_MappingInfo_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r15.d; i2++) {
		_serSysEncPosSIB_Type_r15(_buffer, _size, _lidx, &p->posSIB_MappingInfo_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPosSchedulingInfo_r15(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value* p, enum PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_plmn_Identity_r15) {
		_serSysEncPLMN_Identity(_buffer, _size, _lidx, &p->plmn_Identity_r15);
	}
	if (d == PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_plmn_Index_r15) {
		HTON_8(&_buffer[*_lidx], p->plmn_Index_r15, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(_buffer, _size, _lidx, &p->plmn_Identity_5GC_r15);
	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse_CRS_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellIdentity_5GC_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CellIdentity_5GC_r15_Value* p, enum CellIdentity_5GC_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CellIdentity_5GC_r15_cellIdentity_r15) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			HTON_8(&_buffer[*_lidx], p->cellIdentity_r15[i2], _lidx);
		}
	}
	if (d == CellIdentity_5GC_r15_cellId_Index_r15) {
		HTON_8(&_buffer[*_lidx], p->cellId_Index_r15, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellIdentity_5GC_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellIdentity_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCellIdentity_5GC_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellAccessRelatedInfo_5GC_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellAccessRelatedInfo_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_IdentityList_r15.d, _lidx);
	for (size_t i2 = 0; i2 < p->plmn_IdentityList_r15.d; i2++) {
		_serSysEncPLMN_IdentityInfo_r15(_buffer, _size, _lidx, &p->plmn_IdentityList_r15.v[i2]);
	}
	_serSysEncRAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional(_buffer, _size, _lidx, &p->ran_AreaCode_r15);
	for (size_t i2 = 0; i2 < 24; i2++) {
		HTON_8(&_buffer[*_lidx], p->trackingAreaCode_5GC_r15[i2], _lidx);
	}
	_serSysEncCellIdentity_5GC_r15(_buffer, _size, _lidx, &p->cellIdentity_5GC_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cellBarred_5GC_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->cellBarred_5GC_CRS_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->cellAccessRelatedInfoList_5GC_r15.d, _lidx);
	for (size_t i1 = 0; i1 < p->cellAccessRelatedInfoList_5GC_r15.d; i1++) {
		_serSysEncCellAccessRelatedInfo_5GC_r15(_buffer, _size, _lidx, &p->cellAccessRelatedInfoList_5GC_r15.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional(_buffer, _size, _lidx, &p->cp_CIoT_5GS_Optimisation_r16);
	_serSysEncPLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional(_buffer, _size, _lidx, &p->up_CIoT_5GS_Optimisation_r16);
	_serSysEncPLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncPLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPLMN_IdentityInfo_v1610(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional(_buffer, _size, _lidx, &p->eDRX_Allowed_5GC_r16);
	_serSysEncSystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional(_buffer, _size, _lidx, &p->transmissionInControlChRegion_r16);
	_serSysEncSystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional(_buffer, _size, _lidx, &p->campingAllowedInCE_r16);
	_serSysEncPLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(_buffer, _size, _lidx, &p->plmn_IdentityList_v1610);
	_serSysEncSystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1610_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1540_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1540_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional(_buffer, _size, _lidx, &p->si_posOffset_r15);
	_serSysEncSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1540_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional(_buffer, _size, _lidx, &p->hsdn_Cell_r15);
	_serSysEncCellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);
	_serSysEncSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional(_buffer, _size, _lidx, &p->crs_IntfMitigConfig_r15);
	{
		size_t _tmp = (size_t)p->cellBarred_CRS_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(_buffer, _size, _lidx, &p->plmn_IdentityList_v1530);
	_serSysEncPosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(_buffer, _size, _lidx, &p->posSchedulingInfoList_r15);
	_serSysEncSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(_buffer, _size, _lidx, &p->cellAccessRelatedInfo_5GC_r15);
	_serSysEncSystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport5GC_r15);
	_serSysEncSystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support5GC_r15);
	_serSysEncSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1530_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1450_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1450_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1450);
	_serSysEncSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1450_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1430_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1430_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support_r14);
	_serSysEncTDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1430);
	_serSysEncCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(_buffer, _size, _lidx, &p->cellAccessRelatedInfoList_r14);
	_serSysEncSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1430_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1360_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1360_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);
	_serSysEncSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1360_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1350_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1350_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);
	_serSysEncSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1350_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional(_buffer, _size, _lidx, &p->freqHoppingParametersDL_r13);
	_serSysEncSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1320_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncB10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional(_buffer, _size, _lidx, &p->hyperSFN_r13);
	_serSysEncSystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional(_buffer, _size, _lidx, &p->eDRX_Allowed_r13);
	_serSysEncCellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(_buffer, _size, _lidx, &p->bandwidthReducedAccessRelatedInfo_r13);
	_serSysEncSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1310_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1250_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1250_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250(_buffer, _size, _lidx, &p->cellAccessRelatedInfo_v1250);
	_serSysEncCellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v1250);
	_serSysEncSystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional(_buffer, _size, _lidx, &p->freqBandIndicatorPriority_r12);
	_serSysEncSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1250_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1130_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1130_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);
	_serSysEncCellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v1130);
	_serSysEncSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v1130_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v920_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v920_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport_r9);
	_serSysEncCellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v920);
	_serSysEncSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v920_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v890_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v890_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSystemInformationBlockType1_v890_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemInformationBlockType1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemInformationBlockType1* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSystemInformationBlockType1_cellAccessRelatedInfo(_buffer, _size, _lidx, &p->cellAccessRelatedInfo);
	_serSysEncSystemInformationBlockType1_cellSelectionInfo(_buffer, _size, _lidx, &p->cellSelectionInfo);
	_serSysEncP_Max_SystemInformationBlockType1_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	HTON_8(&_buffer[*_lidx], p->freqBandIndicator, _lidx);
	HTON_32(&_buffer[*_lidx], p->schedulingInfoList.d, _lidx);
	for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
		_serSysEncSchedulingInfo(_buffer, _size, _lidx, &p->schedulingInfoList.v[i1]);
	}
	_serSysEncTDD_Config_SystemInformationBlockType1_tdd_Config_Optional(_buffer, _size, _lidx, &p->tdd_Config);
	{
		size_t _tmp = (size_t)p->si_WindowLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->systemInfoValueTag, _lidx);
	_serSysEncSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_c1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union BCCH_DL_SCH_MessageType_c1_Value* p, enum BCCH_DL_SCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serSysEncSystemInformation(_buffer, _size, _lidx, &p->systemInformation);
	}
	if (d == BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serSysEncSystemInformationBlockType1(_buffer, _size, _lidx, &p->systemInformationBlockType1);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_c1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncBCCH_DL_SCH_MessageType_c1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union BCCH_DL_SCH_MessageType_Value* p, enum BCCH_DL_SCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_c1) {
		_serSysEncBCCH_DL_SCH_MessageType_c1(_buffer, _size, _lidx, &p->c1);
	}
	if (d == BCCH_DL_SCH_MessageType_messageClassExtension) {
		_serSysEncBCCH_DL_SCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncBCCH_DL_SCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBCCH_DL_SCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSI_List_Type_SIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncBCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSegmentedSI_List_Type_SegmentedSIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1].d, _lidx);
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serSysEncBCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBCCH_BCH_Message_BcchInfo_Type_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serSysEncBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(_buffer, _size, _lidx, &p->SIB1);
	_serSysEncSI_List_Type_SIs_Optional(_buffer, _size, _lidx, &p->SIs);
	_serSysEncSegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchInfo_Type_BcchInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcchInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncNull_Type_BcchConfig_Type_StopSib1Transmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Null_Type_BcchConfig_Type_StopSib1Transmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBcchToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysEncBcchToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serSysEncBcchInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, &p->BcchInfo);
	_serSysEncNull_Type_BcchConfig_Type_StopSib1Transmission_Optional(_buffer, _size, _lidx, &p->StopSib1Transmission);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcchConfig_Type_BcchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BcchConfig_Type_BcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDciDlInfoCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Config_v1310_PCCH_Config_v13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Config_v1310_PCCH_Config_v13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);
	_serSysEncPCCH_Config_v1310_PCCH_Config_v13_Optional(_buffer, _size, _lidx, &p->PCCH_Config_v13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcchConfig_Type_PcchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PcchConfig_Type_PcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCA_CellInitialConfig_Type_CA_CellInitialConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CA_CellInitialConfig_Type_CA_CellInitialConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRToPbchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRToPbchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->EnableMIB_Repetition, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRToPbchConfig_Type_Pbch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcch_BRToPbchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSib1_BRSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sib1_BRSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->SchedulingInfoSIB1_BR_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSib1_BRSchedul_Type_Sib1_BRSchedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sib1_BRSchedul_Type_Sib1_BRSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSib1_BRSchedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBandwidthReducedAccessRelatedInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const BandwidthReducedAccessRelatedInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->si_WindowLength_BR_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->si_RepetitionPattern_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(_buffer, _size, _lidx, &p->schedulingInfoList_BR_r13);
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_DownlinkOrTddSubframeBitmapBR_r13);
	_serSysEncB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_UplinkSubframeBitmapBR_r13);
	HTON_8(&_buffer[*_lidx], p->startSymbolBR_r13, _lidx);
	{
		size_t _tmp = (size_t)p->si_HoppingConfigCommon_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(_buffer, _size, _lidx, &p->si_ValidityTime_r13);
	_serSysEncSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(_buffer, _size, _lidx, &p->systemInfoValueTagList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBandwidthReducedAccessRelatedInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SI_SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRToPdschConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSib1_BRSchedul_Type_Sib1_BRSchedul_Optional(_buffer, _size, _lidx, &p->Sib1_BRSchedul);
	_serSysEncBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(_buffer, _size, _lidx, &p->SiSchedul);
	_serSysEncSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(_buffer, _size, _lidx, &p->SubframeOffsetList);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRToPdschConfig_Type_Pdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcch_BRToPdschConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_BR_r13_c1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union BCCH_DL_SCH_MessageType_BR_r13_c1_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformation_BR_r13) {
		_serSysEncSystemInformation(_buffer, _size, _lidx, &p->systemInformation_BR_r13);
	}
	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformationBlockType1_BR_r13) {
		_serSysEncSystemInformationBlockType1(_buffer, _size, _lidx, &p->systemInformationBlockType1_BR_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_BR_r13_c1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType_BR_r13_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncBCCH_DL_SCH_MessageType_BR_r13_c1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_BR_r13_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_BR_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union BCCH_DL_SCH_MessageType_BR_r13_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1) {
		_serSysEncBCCH_DL_SCH_MessageType_BR_r13_c1(_buffer, _size, _lidx, &p->c1);
	}
	if (d == BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension) {
		_serSysEncBCCH_DL_SCH_MessageType_BR_r13_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_MessageType_BR_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_MessageType_BR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncBCCH_DL_SCH_MessageType_BR_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_Message_BR(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_Message_BR* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBCCH_DL_SCH_MessageType_BR_r13(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysEncBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBR_SI_List_Type_SIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BR_SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBR_SegmentedSI_List_Type_SegmentedSIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1].d, _lidx);
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serSysEncBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serSysEncBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(_buffer, _size, _lidx, &p->SIB1);
	_serSysEncBR_SI_List_Type_SIs_Optional(_buffer, _size, _lidx, &p->SIs);
	_serSysEncBR_SegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRInfo_Type_BcchInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcch_BRInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncNull_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Null_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBcch_BRToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysEncBcch_BRToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serSysEncBcch_BRInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, &p->BcchInfo);
	_serSysEncNull_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional(_buffer, _size, _lidx, &p->StopSib1Transmission);

	return SIDL_STATUS_OK;
}

static int _serSysEncBcch_BRConfig_Type_BRBcchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Bcch_BRConfig_Type_BRBcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBcch_BRConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->subframeStartPosition_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->laa_SCellSubframeConfig_r13[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncLAA_SCellConfiguration_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfigLAA_UL_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfigLAA_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingCellId_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->cif_InSchedulingCell_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCrossCarrierSchedulingConfigLAA_UL_r14(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfigLAA_UL_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value* p, enum LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup) {
		_serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncLBT_Config_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union LBT_Config_r14_Value* p, enum LBT_Config_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == LBT_Config_r14_maxEnergyDetectionThreshold_r14) {
		HTON_8(&_buffer[*_lidx], p->maxEnergyDetectionThreshold_r14, _lidx);
	}
	if (d == LBT_Config_r14_energyDetectionThresholdOffset_r14) {
		HTON_8(&_buffer[*_lidx], p->energyDetectionThresholdOffset_r14, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncLBT_Config_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LBT_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncLBT_Config_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncLBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncLBT_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductions_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductions_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL1_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL2_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL3_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL4_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL5_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductions_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCCH_CandidateReductions_r13_Value* p, enum PDCCH_CandidateReductions_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCCH_CandidateReductions_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCCH_CandidateReductions_r13_setup) {
		_serSysEncPDCCH_CandidateReductions_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductions_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductions_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCCH_CandidateReductions_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCCH_CandidateReductions_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductionsLAA_UL_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL1_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL2_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL3_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL4_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pdcch_candidateReductionAL5_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCCH_CandidateReductionsLAA_UL_r14_Value* p, enum PDCCH_CandidateReductionsLAA_UL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCCH_CandidateReductionsLAA_UL_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCCH_CandidateReductionsLAA_UL_r14_setup) {
		_serSysEncPDCCH_CandidateReductionsLAA_UL_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductionsLAA_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional(_buffer, _size, _lidx, &p->maxNumberOfSchedSubframes_Format0B_r14);
	_serSysEncPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional(_buffer, _size, _lidx, &p->maxNumberOfSchedSubframes_Format4B_r14);
	_serSysEncPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional(_buffer, _size, _lidx, &p->skipMonitoringDCI_Format0A_r14);
	_serSysEncPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional(_buffer, _size, _lidx, &p->skipMonitoringDCI_Format4A_r14);
	_serSysEncPDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format0A_r14);
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format4A_r14);
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format0B_r14);
	_serSysEncPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format4B_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCCH_ConfigLAA_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional(_buffer, _size, _lidx, &p->srs_SubframeIndication_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_v1430_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup) {
		_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_UL_r14);
	_serSysEncLBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional(_buffer, _size, _lidx, &p->lbt_Config_r14);
	_serSysEncPDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional(_buffer, _size, _lidx, &p->pdcch_ConfigLAA_r14);
	_serSysEncLAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional(_buffer, _size, _lidx, &p->absenceOfAnyOtherTechnology_r14);
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicatedAperiodic_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncLAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncLAA_SCellConfiguration_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBasicCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BasicCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCellConfigCapability_Type_ConfigCapability_Optional(_buffer, _size, _lidx, &p->ConfigCapability);
	_serSysEncStaticCellInfo_Type_StaticCellInfo_Optional(_buffer, _size, _lidx, &p->StaticCellInfo);
	_serSysEncPhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(_buffer, _size, _lidx, &p->PhysicalLayerConfigDL);
	_serSysEncInitialCellPower_Type_InitialCellPower_Optional(_buffer, _size, _lidx, &p->InitialCellPower);
	_serSysEncBcchConfig_Type_BcchConfig_Optional(_buffer, _size, _lidx, &p->BcchConfig);
	_serSysEncPcchConfig_Type_PcchConfig_Optional(_buffer, _size, _lidx, &p->PcchConfig);
	_serSysEncCA_CellInitialConfig_Type_CA_CellInitialConfig_Optional(_buffer, _size, _lidx, &p->CA_CellInitialConfig);
	_serSysEncBcch_BRConfig_Type_BRBcchConfig_Optional(_buffer, _size, _lidx, &p->BRBcchConfig);
	_serSysEncLAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional(_buffer, _size, _lidx, &p->LAA_SCellConfiguration);
	_serSysEncLAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional(_buffer, _size, _lidx, &p->LAA_SCellConfiguration_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncBasicCellConfig_Type_Basic_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BasicCellConfig_Type_Basic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncBasicCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncC_RNTI_C_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct C_RNTI_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_ConfigInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->rootSequenceIndex, _lidx);
	_serSysEncPRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional(_buffer, _size, _lidx, &p->prach_ConfigInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value* p, enum PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13) {
		{
			size_t _tmp = (size_t)p->fdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13) {
		{
			size_t _tmp = (size_t)p->tdd_r13;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPRACH_ParametersCE_r13(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdsPrachInfoList_r13);
	_serSysEncPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_startSF_CSS_RA_r13);
	_serSysEncUint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->prach_HoppingOffset_r13);
	_serSysEncPRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(_buffer, _size, _lidx, &p->prach_ParametersListCE_r13);
	_serSysEncUint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional(_buffer, _size, _lidx, &p->initial_CE_level_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1310_prach_Config_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1310_prach_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_v1430_prach_Config_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_v1430_prach_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPRACH_Config(_buffer, _size, _lidx, &p->prach_Config);
	_serSysEncPRACH_Config_v1310_prach_Config_v1310_Optional(_buffer, _size, _lidx, &p->prach_Config_v1310);
	_serSysEncPRACH_Config_v1430_prach_Config_v1430_Optional(_buffer, _size, _lidx, &p->prach_Config_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PRACH_Config_Type_Value* p, enum PRACH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_Config_Type_R8andLater) {
		_serSysEncPRACH_Config_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPRACH_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPRACH_Config_Type_Prach_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PRACH_Config_Type_Prach_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPRACH_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigCommon(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serSysEncPUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigCommon_Type_Value* p, enum PUCCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigCommon_Type_R8andLater) {
		_serSysEncPUCCH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigCommon_Type_Common_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_ackNackRepetition_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_ackNackRepetition_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->repetitionFactor;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_Rep, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_ackNackRepetition_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_ackNackRepetition_Value* p, enum PUCCH_ConfigDedicated_ackNackRepetition_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_ackNackRepetition_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_ackNackRepetition_setup) {
		_serSysEncPUCCH_ConfigDedicated_ackNackRepetition_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_ackNackRepetition(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_ackNackRepetition* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_ackNackRepetition_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_ackNackRepetition(_buffer, _size, _lidx, &p->ackNackRepetition);
	_serSysEncPUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional(_buffer, _size, _lidx, &p->tdd_AckNackFeedbackMode);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->n3PUCCH_AN_ListP1_r13.d, _lidx);
	for (size_t i1 = 0; i1 < p->n3PUCCH_AN_ListP1_r13.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->n3PUCCH_AN_ListP1_r13.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Format3_Conf_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Format3_Conf_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(_buffer, _size, _lidx, &p->n3PUCCH_AN_List_r13);
	_serSysEncPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r10.d, _lidx);
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r10.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r10.v[i1].d, _lidx);
		for (size_t i2 = 0; i2 < p->n1PUCCH_AN_CS_List_r10.v[i1].d; i2++) {
			HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r10.v[i1].v[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup) {
		_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_CS_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_format3_r10) {
		_serSysEncPUCCH_Format3_Conf_r13(_buffer, _size, _lidx, &p->format3_r10);
	}
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10) {
		_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(_buffer, _size, _lidx, &p->channelSelection_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(_buffer, _size, _lidx, &p->pucch_Format_r10);
	_serSysEncPUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format1a1b_r10);
	_serSysEncPUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional(_buffer, _size, _lidx, &p->simultaneousPUCCH_PUSCH_r10);
	_serSysEncUint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_RepP1_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->n1PUCCH_AN_CS_ListP1_r11.d, _lidx);
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_ListP1_r11.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_CS_ListP1_r11.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value* p, enum PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup) {
		_serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nPUCCH_Identity_r11, _lidx);
	HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value* p, enum PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup) {
		_serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_CS_v1130);
	_serSysEncPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional(_buffer, _size, _lidx, &p->nPUCCH_Param_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nkaPUCCH_AN_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value* p, enum PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup) {
		_serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12(_buffer, _size, _lidx, &p->nkaPUCCH_Param_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated(_buffer, _size, _lidx, &p->pucch_ConfigDedicated);
	_serSysEncPUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, &p->pucch_ConfigDedicated_v1020);
	_serSysEncPUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(_buffer, _size, _lidx, &p->pucch_ConfigDedicated_v1130);
	_serSysEncPUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional(_buffer, _size, _lidx, &p->pucch_ConfigDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->repetitionFactor_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_Rep_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value* p, enum PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_ackNackRepetition_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->n3PUCCH_AN_ListP1_r13.d, _lidx);
	for (size_t i1 = 0; i1 < p->n3PUCCH_AN_ListP1_r13.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->n3PUCCH_AN_ListP1_r13.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(_buffer, _size, _lidx, &p->n3PUCCH_AN_List_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r13.d, _lidx);
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r13.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r13.v[i1].d, _lidx);
		for (size_t i2 = 0; i2 < p->n1PUCCH_AN_CS_List_r13.v[i1].d; i2++) {
			HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_CS_List_r13.v[i1].v[i2], _lidx);
		}
	}
	HTON_32(&_buffer[*_lidx], p->dummy1.d, _lidx);
	for (size_t i1 = 0; i1 < p->dummy1.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->dummy1.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_CS_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncFormat4_resource_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Format4_resource_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->startingPRB_format4_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->numberOfPRB_format4_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Format4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncFormat4_resource_r13(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 4; i1++) {
		_serSysEncFormat4_resource_r13(_buffer, _size, _lidx, &p->format4_resourceConfiguration_r13[i1]);
	}
	_serSysEncFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(_buffer, _size, _lidx, &p->format4_MultiCSI_resourceConfiguration_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncFormat5_resource_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Format5_resource_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->startingPRB_format5_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->cdm_index_format5_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncFormat5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Format5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncFormat5_resource_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 4; i1++) {
		_serSysEncFormat5_resource_r13(_buffer, _size, _lidx, &p->format5_resourceConfiguration_r13[i1]);
	}
	_serSysEncFormat5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional(_buffer, _size, _lidx, &p->format5_MultiCSI_resourceConfiguration_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_pucch_Format_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(_buffer, _size, _lidx, &p->format3_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(_buffer, _size, _lidx, &p->channelSelection_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(_buffer, _size, _lidx, &p->format4_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13(_buffer, _size, _lidx, &p->format5_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nPUCCH_Identity_r13, _lidx);
	HTON_16(&_buffer[*_lidx], p->n1PUCCH_AN_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value* p, enum PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nkaPUCCH_AN_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value* p, enum PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pucch_NumRepetitionCE_format1_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pucch_NumRepetitionCE_format2_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pucch_NumRepetitionCE_format1_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pucch_NumRepetitionCE_format2_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA(_buffer, _size, _lidx, &p->modeA);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB(_buffer, _size, _lidx, &p->modeB);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup) {
		_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_r13_ackNackRepetition_r13(_buffer, _size, _lidx, &p->ackNackRepetition_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional(_buffer, _size, _lidx, &p->tdd_AckNackFeedbackMode_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(_buffer, _size, _lidx, &p->pucch_Format_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format1a1b_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional(_buffer, _size, _lidx, &p->simultaneousPUCCH_PUSCH_r13);
	_serSysEncUint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_RepP1_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional(_buffer, _size, _lidx, &p->nPUCCH_Param_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional(_buffer, _size, _lidx, &p->nkaPUCCH_Param_r13);
	HTON_8(&_buffer[*_lidx], p->spatialBundlingPUCCH_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->spatialBundlingPUSCH_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->harq_TimingTDD_r13, _lidx);
	_serSysEncPUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional(_buffer, _size, _lidx, &p->codebooksizeDetermination_r13);
	_serSysEncUint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional(_buffer, _size, _lidx, &p->maximumPayloadCoderate_r13);
	_serSysEncPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_R13andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_R13andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigDedicated_r13(_buffer, _size, _lidx, &p->pucch_ConfigDedicated_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUCCH_ConfigDedicated_Type_Value* p, enum PUCCH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_Type_R8andLater) {
		_serSysEncPUCCH_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == PUCCH_ConfigDedicated_Type_R13andLater) {
		_serSysEncPUCCH_ConfigDedicated_R13andLater_Type(_buffer, _size, _lidx, &p->R13andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUCCH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_ConfigDedicated_Type_Dedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_ConfigDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUCCH_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serSysEncPUCCH_ConfigDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUCCH_Configuration_Type_Pucch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUCCH_Configuration_Type_Pucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUCCH_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigCommon_v1270(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigCommon(_buffer, _size, _lidx, &p->pusch_ConfigCommon);
	_serSysEncPUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1270);
	_serSysEncPUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigCommon_Type_Value* p, enum PUSCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigCommon_Type_R8andLater) {
		_serSysEncPUSCH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigCommon_Type_Common_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020_betaOffsetMC_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_MC_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_MC_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_MC_r10, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r10);
	_serSysEncPUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional(_buffer, _size, _lidx, &p->groupHoppingDisabled_r10);
	_serSysEncPUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional(_buffer, _size, _lidx, &p->dmrs_WithOCC_Activated_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nPUSCH_Identity_r11, _lidx);
	HTON_16(&_buffer[*_lidx], p->nDMRS_CSH_Identity_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value* p, enum PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup) {
		_serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11(_buffer, _size, _lidx, &p->pusch_DMRS_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_MC_SubframeSet2_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_MC_SubframeSet2_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_MC_SubframeSet2_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_SubframeSet2_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_SubframeSet2_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_SubframeSet2_r12, _lidx);
	_serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value* p, enum PUSCH_ConfigDedicated_v1250_uciOnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_v1250_uciOnPUSCH_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup) {
		_serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated_v1250_uciOnPUSCH(_buffer, _size, _lidx, &p->uciOnPUSCH);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated(_buffer, _size, _lidx, &p->pusch_ConfigDedicated);
	_serSysEncPUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1020);
	_serSysEncPUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1130);
	_serSysEncPUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_betaOffsetMC_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_betaOffsetMC_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_MC_r13, _lidx);
	_serSysEncUint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_MC_r13);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_MC_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_MC_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_r13_betaOffsetMC_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->nPUSCH_Identity_r13, _lidx);
	HTON_16(&_buffer[*_lidx], p->nDMRS_CSH_Identity_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value* p, enum PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup) {
		_serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_MC_SubframeSet2_r13, _lidx);
	_serSysEncUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_MC_SubframeSet2_r13);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_MC_SubframeSet2_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_MC_SubframeSet2_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_SubframeSet2_r13, _lidx);
	_serSysEncUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_SubframeSet2_r13);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_SubframeSet2_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_SubframeSet2_r13, _lidx);
	_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigDedicated_r13_uciOnPUSCH_Value* p, enum PUSCH_ConfigDedicated_r13_uciOnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_r13_uciOnPUSCH_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup) {
		_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_uciOnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->betaOffset_ACK_Index_r13, _lidx);
	_serSysEncUint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_r13);
	HTON_8(&_buffer[*_lidx], p->betaOffset_RI_Index_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->betaOffset_CQI_Index_r13, _lidx);
	_serSysEncPUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r13);
	_serSysEncPUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional(_buffer, _size, _lidx, &p->groupHoppingDisabled_r13);
	_serSysEncPUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional(_buffer, _size, _lidx, &p->dmrs_WithOCC_Activated_r13);
	_serSysEncPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional(_buffer, _size, _lidx, &p->pusch_DMRS_r11);
	_serSysEncPUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional(_buffer, _size, _lidx, &p->uciOnPUSCH);
	_serSysEncPUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional(_buffer, _size, _lidx, &p->pusch_HoppingConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_PUSCH_UpPTS_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncTDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional(_buffer, _size, _lidx, &p->symPUSCH_UpPTS_r14);
	_serSysEncTDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional(_buffer, _size, _lidx, &p->dmrs_LessUpPTS_Config_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TDD_PUSCH_UpPTS_r14_Value* p, enum TDD_PUSCH_UpPTS_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TDD_PUSCH_UpPTS_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == TDD_PUSCH_UpPTS_r14_setup) {
		_serSysEncTDD_PUSCH_UpPTS_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_PUSCH_UpPTS_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTDD_PUSCH_UpPTS_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncTDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTDD_PUSCH_UpPTS_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_setup_tpc_SubframeSet_Configured_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->subframeSet1_DCI_Format0_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeSet1_DCI_Format4_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeSet2_DCI_Format0_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeSet2_DCI_Format4_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->dci_Format0_r14, _lidx);
	HTON_8(&_buffer[*_lidx], p->dci_Format4_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Enable256QAM_r14_setup_Value* p, enum Enable256QAM_r14_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14) {
		_serSysEncEnable256QAM_r14_setup_tpc_SubframeSet_Configured_r14(_buffer, _size, _lidx, &p->tpc_SubframeSet_Configured_r14);
	}
	if (d == Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14) {
		_serSysEncEnable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14(_buffer, _size, _lidx, &p->tpc_SubframeSet_NotConfigured_r14);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Enable256QAM_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEnable256QAM_r14_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Enable256QAM_r14_Value* p, enum Enable256QAM_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Enable256QAM_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == Enable256QAM_r14_setup) {
		_serSysEncEnable256QAM_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Enable256QAM_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEnable256QAM_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEnable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Enable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEnable256QAM_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional(_buffer, _size, _lidx, &p->ce_PUSCH_NB_MaxTBS_r14);
	_serSysEncPUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional(_buffer, _size, _lidx, &p->ce_PUSCH_MaxBandwidth_r14);
	_serSysEncTDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional(_buffer, _size, _lidx, &p->tdd_PUSCH_UpPTS_r14);
	HTON_8(&_buffer[*_lidx], p->ul_DMRS_IFDMA_r14, _lidx);
	_serSysEncEnable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional(_buffer, _size, _lidx, &p->enable256QAM_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_R13andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_R13andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigDedicated_r13(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_r13);
	_serSysEncPUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PUSCH_ConfigDedicated_Type_Value* p, enum PUSCH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_Type_R8andLater) {
		_serSysEncPUSCH_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == PUSCH_ConfigDedicated_Type_R13andLater) {
		_serSysEncPUSCH_ConfigDedicated_R13andLater_Type(_buffer, _size, _lidx, &p->R13andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPUSCH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_ConfigDedicated_Type_Dedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_ConfigDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPUSCH_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serSysEncPUSCH_ConfigDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysEncPUSCH_Configuration_Type_Pusch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PUSCH_Configuration_Type_Pusch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPUSCH_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_TimingAdvanceConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SS_TimingAdvanceConfig_Type_Value* p, enum SS_TimingAdvanceConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SS_TimingAdvanceConfig_Type_InitialValue) {
		HTON_16(&_buffer[*_lidx], p->InitialValue, _lidx);
	}
	if (d == SS_TimingAdvanceConfig_Type_Relative) {
		HTON_8(&_buffer[*_lidx], p->Relative, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_TimingAdvanceConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_TimingAdvanceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSS_TimingAdvanceConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_TimingAdvanceConfig_Type_TimingAdvance_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_TimingAdvanceConfig_Type_TimingAdvance_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSS_TimingAdvanceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigCommon_Type_Value* p, enum SoundingRS_UL_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigCommon_Type_R8) {
		_serSysEncSoundingRS_UL_ConfigCommon(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->srs_Bandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->srs_HoppingBandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->freqDomainPosition, _lidx);
	HTON_8(&_buffer[*_lidx], p->duration, _lidx);
	HTON_16(&_buffer[*_lidx], p->srs_ConfigIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->transmissionComb, _lidx);
	{
		size_t _tmp = (size_t)p->cyclicShift;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigDedicated_Value* p, enum SoundingRS_UL_ConfigDedicated_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicated_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicated_setup) {
		_serSysEncSoundingRS_UL_ConfigDedicated_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigDedicated_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSoundingRS_UL_ConfigDedicated(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->srs_AntennaPort_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSoundingRS_UL_ConfigDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSRS_ConfigAp_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SRS_ConfigAp_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->srs_AntennaPortAp_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->srs_BandwidthAp_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->freqDomainPositionAp_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->transmissionCombAp_r10, _lidx);
	{
		size_t _tmp = (size_t)p->cyclicShiftAp_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->srs_ConfigApDCI_Format0_r10);
	_serSysEncSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->srs_ConfigApDCI_Format1a2b2c_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup) {
		_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_ConfigIndexAp_r10, _lidx);
	_serSysEncSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(_buffer, _size, _lidx, &p->srs_ConfigApDCI_Format4_r10);
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional(_buffer, _size, _lidx, &p->srs_ActivateAp_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigDedicatedAperiodic_r10_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup) {
		_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicated);
	_serSysEncSoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicated_v1020);
	_serSysEncSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicatedAperiodic_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SoundingRS_UL_ConfigDedicated_Type_Value* p, enum SoundingRS_UL_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicated_Type_R8andLater) {
		_serSysEncSoundingRS_UL_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSoundingRS_UL_ConfigDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SoundingRS_UL_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSoundingRS_UL_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSRS_UL_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SRS_UL_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSoundingRS_UL_ConfigCommon_Type(_buffer, _size, _lidx, &p->Common);
	_serSysEncSoundingRS_UL_ConfigDedicated_Type(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysEncSRS_UL_Config_Type_SRS_UL_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SRS_UL_Config_Type_SRS_UL_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSRS_UL_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->sr_PUCCH_ResourceIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->sr_ConfigIndex, _lidx);
	{
		size_t _tmp = (size_t)p->dsr_TransMax;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SchedulingRequestConfig_Value* p, enum SchedulingRequestConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingRequestConfig_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SchedulingRequestConfig_setup) {
		_serSysEncSchedulingRequestConfig_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSchedulingRequestConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional(_buffer, _size, _lidx, &p->sr_PUCCH_ResourceIndexP1_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSchedulingRequestConfig_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSchedulingRequestConfig(_buffer, _size, _lidx, &p->schedulingRequestConfig);
	_serSysEncSchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional(_buffer, _size, _lidx, &p->schedulingRequestConfig_v1020);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SchedulingRequestConfig_Type_Value* p, enum SchedulingRequestConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingRequestConfig_Type_R8andLater) {
		_serSysEncSchedulingRequestConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSchedulingRequestConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingRequestConfig_Type_SR_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingRequestConfig_Type_SR_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSchedulingRequestConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->k, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value* p, enum CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_widebandCQI) {
		HTON_8(&_buffer[*_lidx], p->widebandCQI, _lidx);
	}
	if (d == CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI) {
		_serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI(_buffer, _size, _lidx, &p->subbandCQI);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cqi_PUCCH_ResourceIndex, _lidx);
	HTON_16(&_buffer[*_lidx], p->cqi_pmi_ConfigIndex, _lidx);
	_serSysEncCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic);
	_serSysEncUint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex);
	HTON_8(&_buffer[*_lidx], p->simultaneousAckNackAndCQI, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodic_Value* p, enum CQI_ReportPeriodic_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportPeriodic_setup) {
		_serSysEncCQI_ReportPeriodic_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodic_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportPeriodic(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional(_buffer, _size, _lidx, &p->cqi_ReportModeAperiodic);
	HTON_8(&_buffer[*_lidx], p->nomPDSCH_RS_EPRE_Offset, _lidx);
	_serSysEncCQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodic);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional(_buffer, _size, _lidx, &p->cqi_Mask_r9);
	_serSysEncCQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r9);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportConfig(_buffer, _size, _lidx, &p->cqi_ReportConfig);
	_serSysEncCQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional(_buffer, _size, _lidx, &p->cqi_ReportConfig_v920);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->trigger1_r10[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->trigger2_r10[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cqi_ReportModeAperiodic_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional(_buffer, _size, _lidx, &p->aperiodicCSI_Trigger_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportAperiodic_r10_Value* p, enum CQI_ReportAperiodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportAperiodic_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportAperiodic_r10_setup) {
		_serSysEncCQI_ReportAperiodic_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportAperiodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportAperiodic_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional(_buffer, _size, _lidx, &p->csi_ReportMode_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->k, _lidx);
	{
		size_t _tmp = (size_t)p->periodicityFactor_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value* p, enum CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10) {
		_serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10(_buffer, _size, _lidx, &p->widebandCQI_r10);
	}
	if (d == CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10) {
		_serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10(_buffer, _size, _lidx, &p->subbandCQI_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cqi_pmi_ConfigIndex2_r10, _lidx);
	_serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex2_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value* p, enum CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup) {
		_serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cqi_PUCCH_ResourceIndex_r10, _lidx);
	_serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional(_buffer, _size, _lidx, &p->cqi_PUCCH_ResourceIndexP1_r10);
	HTON_16(&_buffer[*_lidx], p->cqi_pmi_ConfigIndex, _lidx);
	_serSysEncCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic_r10);
	_serSysEncUint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex);
	HTON_8(&_buffer[*_lidx], p->simultaneousAckNackAndCQI, _lidx);
	_serSysEncCQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional(_buffer, _size, _lidx, &p->cqi_Mask_r9);
	_serSysEncCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional(_buffer, _size, _lidx, &p->csi_ConfigIndex_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodic_r10_Value* p, enum CQI_ReportPeriodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportPeriodic_r10_setup) {
		_serSysEncCQI_ReportPeriodic_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportPeriodic_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMeasSubframePattern_r10(_buffer, _size, _lidx, &p->csi_MeasSubframeSet1_r10);
	_serSysEncMeasSubframePattern_r10(_buffer, _size, _lidx, &p->csi_MeasSubframeSet2_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value* p, enum CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup) {
		_serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodic_r10);
	HTON_8(&_buffer[*_lidx], p->nomPDSCH_RS_EPRE_Offset, _lidx);
	_serSysEncCQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodic_r10);
	_serSysEncCQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r9);
	_serSysEncCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional(_buffer, _size, _lidx, &p->csi_SubframePatternConfig_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional(_buffer, _size, _lidx, &p->csi_ReportMode_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->k, _lidx);
	{
		size_t _tmp = (size_t)p->periodicityFactor_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value* p, enum CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11) {
		_serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11(_buffer, _size, _lidx, &p->widebandCQI_r11);
	}
	if (d == CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11) {
		_serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11(_buffer, _size, _lidx, &p->subbandCQI_r11);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cqi_pmi_ConfigIndex2_r11, _lidx);
	_serSysEncUint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex2_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value* p, enum CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup) {
		_serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRI_ReportConfig_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRI_ReportConfig_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->cri_ConfigIndex_r13, _lidx);
	_serSysEncCRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional(_buffer, _size, _lidx, &p->cri_ConfigIndex2_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRI_ReportConfig_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CRI_ReportConfig_r13_Value* p, enum CRI_ReportConfig_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CRI_ReportConfig_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CRI_ReportConfig_r13_setup) {
		_serSysEncCRI_ReportConfig_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCRI_ReportConfig_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRI_ReportConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCRI_ReportConfig_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCRI_ReportConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExt_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExt_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->cqi_ReportPeriodicProcExtId_r11, _lidx);
	HTON_16(&_buffer[*_lidx], p->cqi_pmi_ConfigIndex_r11, _lidx);
	_serSysEncCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic_r11);
	_serSysEncUint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex_r11);
	_serSysEncCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional(_buffer, _size, _lidx, &p->csi_ConfigIndex_r11);
	_serSysEncCRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional(_buffer, _size, _lidx, &p->cri_ReportConfig_r13);
	_serSysEncCQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional(_buffer, _size, _lidx, &p->periodicityFactorWB_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCQI_ReportPeriodicProcExt_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportPeriodic_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportPeriodic_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional(_buffer, _size, _lidx, &p->simultaneousAckNackAndCQI_Format3_r11);
	_serSysEncCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodicProcExtToReleaseList_r11);
	_serSysEncCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodicProcExtToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_Config_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_IM_ConfigId_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->resourceConfig_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeConfig_r11, _lidx);
	_serSysEncBool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->interferenceMeasRestriction_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCSI_IM_Config_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p_C_r11, _lidx);
	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction_r11.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction_r11.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction_r11.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBothProc_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBothProc_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional(_buffer, _size, _lidx, &p->ri_Ref_CSI_ProcessId_r11);
	_serSysEncCQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportBothProc_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodicProc_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodicProc_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->cqi_ReportModeAperiodic_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->trigger01_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger10_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger11_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportAperiodicProc_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_Process_r11_csi_IM_ConfigIdList_r12_Value* p, enum CSI_Process_r11_csi_IM_ConfigIdList_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_csi_IM_ConfigIdList_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_Process_r11_csi_IM_ConfigIdList_r12_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_csi_IM_ConfigIdList_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_r12_setup) {
		_serSysEncCQI_ReportAperiodicProc_r11(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodicProc_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodicProc_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->trigger001_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger010_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger011_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger100_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger101_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger110_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->trigger111_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc_v1310_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc_v1310_setup) {
		_serSysEncCQI_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_setup) {
		_serSysEncCQI_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc2_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction1_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction1_r13.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction1_r13.v[i3], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction2_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction2_r13.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction2_r13.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction3_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction3_r13.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction3_r13.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction_r13.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction_r13.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction_r13.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union P_C_AndCBSR_r13_cbsr_Selection_r13_Value* p, enum P_C_AndCBSR_r13_cbsr_Selection_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13) {
		_serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(_buffer, _size, _lidx, &p->nonPrecoded_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13) {
		_serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(_buffer, _size, _lidx, &p->beamformedK1a_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13) {
		_serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(_buffer, _size, _lidx, &p->beamformedKN_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r13_cbsr_Selection_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p_C_r13, _lidx);
	_serSysEncP_C_AndCBSR_r13_cbsr_Selection_r13(_buffer, _size, _lidx, &p->cbsr_Selection_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncP_C_AndCBSR_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_ResourceConfig_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_ResourceConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->resourceConfig_r13, _lidx);
	_serSysEncNZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysEncNZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->nzp_resourceConfigList_r13.d, _lidx);
	for (size_t i2 = 0; i2 < p->nzp_resourceConfigList_r13.d; i2++) {
		_serSysEncNZP_ResourceConfig_r13(_buffer, _size, _lidx, &p->nzp_resourceConfigList_r13.v[i2]);
	}
	_serSysEncCSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional(_buffer, _size, _lidx, &p->cdmType_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigNZP_EMIMO_r13_Value* p, enum CSI_RS_ConfigNZP_EMIMO_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_EMIMO_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigNZP_EMIMO_r13_setup) {
		_serSysEncCSI_RS_ConfigNZP_EMIMO_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigNZP_EMIMO_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_EMIMO_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(_buffer, _size, _lidx, &p->p_C_AndCBSRList_r13);
	{
		size_t _tmp = (size_t)p->codebookConfigN1_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->codebookConfigN2_r13;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional(_buffer, _size, _lidx, &p->codebookOverSamplingRateConfig_O1_r13);
	_serSysEncCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional(_buffer, _size, _lidx, &p->codebookOverSamplingRateConfig_O2_r13);
	HTON_8(&_buffer[*_lidx], p->codebookConfig_r13, _lidx);
	_serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(_buffer, _size, _lidx, &p->csi_IM_ConfigIdList_r13);
	_serSysEncCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZP_EMIMO_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2].d, _lidx);
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			_serSysEncP_C_AndCBSR_r13(_buffer, _size, _lidx, &p->v.v[i2].v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZPIdListExt_r13);
	_serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(_buffer, _size, _lidx, &p->csi_IM_ConfigIdList_r13);
	_serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(_buffer, _size, _lidx, &p->p_C_AndCBSR_PerResourceConfigList_r13);
	_serSysEncBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(_buffer, _size, _lidx, &p->ace_For4Tx_PerResourceConfigList_r13);
	_serSysEncCSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledBeamformed_r13);
	_serSysEncCSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->channelMeasRestriction_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_r13_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_r13_setup_Value* p, enum CSI_RS_ConfigEMIMO_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_r13_setup_nonPrecoded_r13) {
		_serSysEncCSI_RS_ConfigNonPrecoded_r13(_buffer, _size, _lidx, &p->nonPrecoded_r13);
	}
	if (d == CSI_RS_ConfigEMIMO_r13_setup_beamformed_r13) {
		_serSysEncCSI_RS_ConfigBeamformed_r13(_buffer, _size, _lidx, &p->beamformed_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_r13_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_r13_Value* p, enum CSI_RS_ConfigEMIMO_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_r13_setup) {
		_serSysEncCSI_RS_ConfigEMIMO_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->nzp_resourceConfigListExt_r14.d, _lidx);
	for (size_t i2 = 0; i2 < p->nzp_resourceConfigListExt_r14.d; i2++) {
		_serSysEncNZP_ResourceConfig_r13(_buffer, _size, _lidx, &p->nzp_resourceConfigListExt_r14.v[i2]);
	}
	_serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional(_buffer, _size, _lidx, &p->cdmType_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_EMIMO_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_NZP_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_NZP_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncNZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysEncNZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZP_EMIMO_v1430);
	{
		size_t _tmp = (size_t)p->codebookConfigN1_v1430;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->codebookConfigN2_v1430;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->nzp_ResourceConfigTM9_Original_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_Activation_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_Activation_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->csi_RS_NZP_mode_r14;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->activatedResources_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_Activation_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZP_ApList_r14);
	_serSysEncCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional(_buffer, _size, _lidx, &p->nzp_ResourceConfigOriginal_v1430);
	_serSysEncCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional(_buffer, _size, _lidx, &p->csi_RS_NZP_Activation_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1430_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1430_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1430_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1430_setup_nonPrecoded_v1430) {
		_serSysEncCSI_RS_ConfigNonPrecoded_v1430(_buffer, _size, _lidx, &p->nonPrecoded_v1430);
	}
	if (d == CSI_RS_ConfigEMIMO_v1430_setup_beamformed_v1430) {
		_serSysEncCSI_RS_ConfigBeamformed_v1430(_buffer, _size, _lidx, &p->beamformed_v1430);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1430_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1430_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1430_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1430_Value* p, enum CSI_RS_ConfigEMIMO_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1430_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1430_setup) {
		_serSysEncCSI_RS_ConfigEMIMO_v1430_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2].d, _lidx);
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			_serSysEncP_C_AndCBSR_r13(_buffer, _size, _lidx, &p->v.v[i2].v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_Activation_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigBeamformed_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigBeamformed_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZPIdListExt_r14);
	_serSysEncCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(_buffer, _size, _lidx, &p->csi_IM_ConfigIdList_r14);
	_serSysEncP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(_buffer, _size, _lidx, &p->p_C_AndCBSR_PerResourceConfigList_r14);
	_serSysEncBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(_buffer, _size, _lidx, &p->ace_For4Tx_PerResourceConfigList_r14);
	_serSysEncCSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledBeamformed_r14);
	_serSysEncCSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional(_buffer, _size, _lidx, &p->channelMeasRestriction_r14);
	_serSysEncCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZP_ApList_r14);
	_serSysEncCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional(_buffer, _size, _lidx, &p->nzp_ResourceConfigOriginal_v1430);
	_serSysEncCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional(_buffer, _size, _lidx, &p->csi_RS_NZP_Activation_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO2_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO2_r14_Value* p, enum CSI_RS_ConfigEMIMO2_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO2_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO2_r14_setup) {
		_serSysEncCSI_RS_ConfigBeamformed_r14(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO2_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO2_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO2_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO2_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_Hybrid_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional(_buffer, _size, _lidx, &p->periodicityOffsetIndex_r14);
	_serSysEncCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(_buffer, _size, _lidx, &p->eMIMO_Type2_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_Hybrid_r14_Value* p, enum CSI_RS_ConfigEMIMO_Hybrid_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_Hybrid_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_Hybrid_r14_setup) {
		_serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_Hybrid_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigNZP_EMIMO_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_v1480(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_v1480* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZP_EMIMO_v1480);
	_serSysEncCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional(_buffer, _size, _lidx, &p->codebookConfigN1_v1480);
	_serSysEncCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional(_buffer, _size, _lidx, &p->codebookConfigN2_r1480);
	_serSysEncCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->nzp_ResourceConfigTM9_Original_v1480);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1480_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1480_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1480_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1480_setup_nonPrecoded_v1480) {
		_serSysEncCSI_RS_ConfigNonPrecoded_v1480(_buffer, _size, _lidx, &p->nonPrecoded_v1480);
	}
	if (d == CSI_RS_ConfigEMIMO_v1480_setup_beamformed_v1480) {
		_serSysEncCSI_RS_ConfigBeamformed_v1430(_buffer, _size, _lidx, &p->beamformed_v1480);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1480_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1480_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1480_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1480_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1480_Value* p, enum CSI_RS_ConfigEMIMO_v1480_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1480_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1480_setup) {
		_serSysEncCSI_RS_ConfigEMIMO_v1480_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1480(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1480* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1480_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO_v1480(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p_C_r15, _lidx);
	HTON_32(&_buffer[*_lidx], p->codebookSubsetRestriction4_r15.d, _lidx);
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction4_r15.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->codebookSubsetRestriction4_r15.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct P_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysEncP_C_AndCBSR_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigNonPrecoded_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigNonPrecoded_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(_buffer, _size, _lidx, &p->p_C_AndCBSRList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1530_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1530_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1530_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1530_setup_nonPrecoded_v1530) {
		_serSysEncCSI_RS_ConfigNonPrecoded_v1530(_buffer, _size, _lidx, &p->nonPrecoded_v1530);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1530_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1530_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1530_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1530_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CSI_RS_ConfigEMIMO_v1530_Value* p, enum CSI_RS_ConfigEMIMO_v1530_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1530_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1530_setup) {
		_serSysEncCSI_RS_ConfigEMIMO_v1530_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1530(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCSI_RS_ConfigEMIMO_v1530_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_RS_ConfigEMIMO_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_Process_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_Process_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_ProcessId_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->csi_RS_ConfigNZPId_r11, _lidx);
	HTON_8(&_buffer[*_lidx], p->csi_IM_ConfigId_r11, _lidx);
	HTON_32(&_buffer[*_lidx], p->p_C_AndCBSRList_r11.d, _lidx);
	for (size_t i2 = 0; i2 < p->p_C_AndCBSRList_r11.d; i2++) {
		_serSysEncP_C_AndCBSR_r11(_buffer, _size, _lidx, &p->p_C_AndCBSRList_r11.v[i2]);
	}
	_serSysEncCQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportBothProc_r11);
	_serSysEncUint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodicProcId_r11);
	_serSysEncCQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc_r11);
	_serSysEncCSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledFor4TXProc_r12);
	_serSysEncCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigIdList_r12);
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc2_r12);
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc_v1310);
	_serSysEncCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc2_v1310);
	_serSysEncCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(_buffer, _size, _lidx, &p->eMIMO_Type_r13);
	_serSysEncCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(_buffer, _size, _lidx, &p->dummy);
	_serSysEncCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(_buffer, _size, _lidx, &p->eMIMO_Hybrid_r14);
	_serSysEncBool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional(_buffer, _size, _lidx, &p->advancedCodebookEnabled_r14);
	_serSysEncCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(_buffer, _size, _lidx, &p->eMIMO_Type_v1480);
	_serSysEncBool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional(_buffer, _size, _lidx, &p->feCOMP_CSI_Enabled_v1530);
	_serSysEncCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(_buffer, _size, _lidx, &p->eMIMO_Type_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncCSI_Process_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBoth_r11(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBoth_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToReleaseList_r11);
	_serSysEncCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToAddModList_r11);
	_serSysEncCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(_buffer, _size, _lidx, &p->csi_ProcessToReleaseList_r11);
	_serSysEncCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(_buffer, _size, _lidx, &p->csi_ProcessToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportPeriodic_v1130(_buffer, _size, _lidx, &p->cqi_ReportPeriodic_v1130);
	_serSysEncCQI_ReportBoth_r11(_buffer, _size, _lidx, &p->cqi_ReportBoth_r11);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 10; i1++) {
		HTON_8(&_buffer[*_lidx], p->csi_MeasSubframeSets_r12[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value* p, enum CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup) {
		_serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigExt_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigExt_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_IM_ConfigId_v1250, _lidx);
	HTON_8(&_buffer[*_lidx], p->resourceConfig_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->subframeConfig_r12, _lidx);
	_serSysEncBool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->interferenceMeasRestriction_r13);
	_serSysEncCSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigId_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysEncCSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCSI_IM_ConfigExt_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBoth_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBoth_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToReleaseListExt_r12);
	_serSysEncCSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToAddModListExt_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportBoth_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->trigger_SubframeSetIndicator_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->trigger1_SubframeSetIndicator_r12[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->trigger2_SubframeSetIndicator_r12[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_v1250_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_v1250_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250(_buffer, _size, _lidx, &p->aperiodicCSI_Trigger_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_v1250_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportAperiodic_v1250_Value* p, enum CQI_ReportAperiodic_v1250_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportAperiodic_v1250_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == CQI_ReportAperiodic_v1250_setup) {
		_serSysEncCQI_ReportAperiodic_v1250_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportAperiodic_v1250_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportAperiodic_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional(_buffer, _size, _lidx, &p->csi_SubframePatternConfig_r12);
	_serSysEncCQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportBoth_v1250);
	_serSysEncCQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodic_v1250);
	_serSysEncCQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional(_buffer, _size, _lidx, &p->altCQI_Table_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_R10andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_R10andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCQI_ReportConfig_r10(_buffer, _size, _lidx, &p->cqi_ReportConfig_r10);
	_serSysEncCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(_buffer, _size, _lidx, &p->cqi_ReportConfig_v1130);
	_serSysEncCQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportConfig_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CQI_ReportConfig_Type_Value* p, enum CQI_ReportConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_Type_R8andLater) {
		_serSysEncCQI_ReportConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == CQI_ReportConfig_Type_R10andLater) {
		_serSysEncCQI_ReportConfig_R10andLater_Type(_buffer, _size, _lidx, &p->R10andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCQI_ReportConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCQI_ReportConfig_Type_CQI_ReportConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CQI_ReportConfig_Type_CQI_ReportConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCQI_ReportConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommon_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommonSCell_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommonSCell_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->deltaPreambleMsg3_r11, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommonSCell_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommonPSCell_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommonPSCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format3_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaF_PUCCH_Format1bCS_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_NominalPUCCH_r12, _lidx);
	_serSysEncDeltaFList_PUCCH(_buffer, _size, _lidx, &p->deltaFList_PUCCH_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommonPSCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUplinkPowerControlCommon(_buffer, _size, _lidx, &p->uplinkPowerControlCommon);
	_serSysEncUplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1020);
	_serSysEncUplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommonSCell_v1130);
	_serSysEncUplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommonPSCell_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UplinkPowerControlCommon_Type_Value* p, enum UplinkPowerControlCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlCommon_Type_R8andLater) {
		_serSysEncUplinkPowerControlCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkPowerControlCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncFilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p0_UE_PUSCH, _lidx);
	{
		size_t _tmp = (size_t)p->deltaMCS_Enabled;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->accumulationEnabled, _lidx);
	HTON_8(&_buffer[*_lidx], p->p0_UE_PUCCH, _lidx);
	HTON_8(&_buffer[*_lidx], p->pSRS_Offset, _lidx);
	_serSysEncFilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional(_buffer, _size, _lidx, &p->filterCoefficient);

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaTxD_OffsetListPUCCH_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaTxD_OffsetListPUCCH_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaTxD_OffsetPUCCH_Format1_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaTxD_OffsetPUCCH_Format1a1b_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaTxD_OffsetPUCCH_Format22a2b_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->deltaTxD_OffsetPUCCH_Format3_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDeltaTxD_OffsetListPUCCH_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1020(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional(_buffer, _size, _lidx, &p->deltaTxD_OffsetListPUCCH_r10);
	_serSysEncUint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional(_buffer, _size, _lidx, &p->pSRS_OffsetAp_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaTxD_OffsetListPUCCH_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaTxD_OffsetListPUCCH_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->deltaTxD_OffsetPUCCH_Format1bCS_r11;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDeltaTxD_OffsetListPUCCH_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1130(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional(_buffer, _size, _lidx, &p->pSRS_Offset_v1130);
	_serSysEncUint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional(_buffer, _size, _lidx, &p->pSRS_OffsetAp_v1130);
	_serSysEncDeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional(_buffer, _size, _lidx, &p->deltaTxD_OffsetListPUCCH_v1130);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlDedicated_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 10; i1++) {
		HTON_8(&_buffer[*_lidx], p->tpc_SubframeSet_r12[i1], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_NominalPUSCH_SubframeSet2_r12, _lidx);
	{
		size_t _tmp = (size_t)p->alpha_SubframeSet2_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_UE_PUSCH_SubframeSet2_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value* p, enum UplinkPowerControlDedicated_v1250_set2PowerControlParameter_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlDedicated_v1250_set2PowerControlParameter_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == UplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup) {
		_serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1250_set2PowerControlParameter* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUplinkPowerControlDedicated_v1250_set2PowerControlParameter(_buffer, _size, _lidx, &p->set2PowerControlParameter);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUplinkPowerControlDedicated(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated);
	_serSysEncUplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1020);
	_serSysEncSCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional(_buffer, _size, _lidx, &p->pathlossReferenceLinking);
	_serSysEncUplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1130);
	_serSysEncUplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UplinkPowerControlDedicated_Type_Value* p, enum UplinkPowerControlDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlDedicated_Type_R8andLater) {
		_serSysEncUplinkPowerControlDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkPowerControlDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkPowerControlDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysicalLayerConfigUL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysicalLayerConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPRACH_Config_Type_Prach_Optional(_buffer, _size, _lidx, &p->Prach);
	_serSysEncPUCCH_Configuration_Type_Pucch_Optional(_buffer, _size, _lidx, &p->Pucch);
	_serSysEncPUSCH_Configuration_Type_Pusch_Optional(_buffer, _size, _lidx, &p->Pusch);
	_serSysEncSS_TimingAdvanceConfig_Type_TimingAdvance_Optional(_buffer, _size, _lidx, &p->TimingAdvance);
	_serSysEncSRS_UL_Config_Type_SRS_UL_Config_Optional(_buffer, _size, _lidx, &p->SRS_UL_Config);
	_serSysEncSchedulingRequestConfig_Type_SR_Config_Optional(_buffer, _size, _lidx, &p->SR_Config);
	_serSysEncCQI_ReportConfig_Type_CQI_ReportConfig_Optional(_buffer, _size, _lidx, &p->CQI_ReportConfig);
	_serSysEncUplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional(_buffer, _size, _lidx, &p->UplinkPowerControlCommon);
	_serSysEncUplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional(_buffer, _size, _lidx, &p->UplinkPowerControlDedicated);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPhysicalLayerConfigUL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_ConfigCommon_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_ConfigCommon(_buffer, _size, _lidx, &p->rach_ConfigCommon);
	_serSysEncRACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RACH_ConfigCommon_Type_Value* p, enum RACH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RACH_ConfigCommon_Type_R8andLater) {
		_serSysEncRACH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRACH_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigCommon_Type_RACH_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ra_PreambleIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->ra_PRACH_MaskIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RACH_ConfigDedicated_Type_Value* p, enum RACH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RACH_ConfigDedicated_Type_R8) {
		_serSysEncRACH_ConfigDedicated(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRACH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRACH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRAR_RapIdCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RAR_RapIdCtrl_Type_Value* p, enum RAR_RapIdCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RAR_RapIdCtrl_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
	}
	if (d == RAR_RapIdCtrl_Type_Unmatched) {
		HTON_8(&_buffer[*_lidx], p->Unmatched, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRAR_RapIdCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RAR_RapIdCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRAR_RapIdCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkGrant_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->HoppingFlag[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 10; i3++) {
		HTON_8(&_buffer[*_lidx], p->RB_Allocation[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		HTON_8(&_buffer[*_lidx], p->ModAndCodScheme[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->TPC_Command[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->UL_Delay[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->CQI_Req[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTempC_RNTI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TempC_RNTI_Type_Value* p, enum TempC_RNTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TempC_RNTI_Type_SameAsC_RNTI) {
		HTON_8(&_buffer[*_lidx], p->SameAsC_RNTI, _lidx);
	}
	if (d == TempC_RNTI_Type_Explicit) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			HTON_8(&_buffer[*_lidx], p->Explicit[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTempC_RNTI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TempC_RNTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTempC_RNTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkGrantCE_ModeA_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkGrantCE_ModeA_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 4; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_NB_Index[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_ResAllocation[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_Repetitions[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->MCS[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->TPC_Command[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->CSI_Req[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->UL_Delay[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_4_MPDCCH_NB_Index[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkGrantCE_ModeB_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkGrantCE_ModeB_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_NB_Index[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_ResAllocation[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_PUSCH_Repetitions[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->TBS[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3_4_MPDCCH_NB_Index[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkGrantCE_Mode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkGrantCE_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUplinkGrantCE_ModeA_Type(_buffer, _size, _lidx, &p->CE_ModeA);
	_serSysEncUplinkGrantCE_ModeB_Type(_buffer, _size, _lidx, &p->CE_ModeB);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkGrantCE_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponseParameters_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RandomAccessResponseParameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);
	_serSysEncUplinkGrant_Type(_buffer, _size, _lidx, &p->InitialGrant);
	HTON_16(&_buffer[*_lidx], p->TimingAdvance, _lidx);
	_serSysEncTempC_RNTI_Type(_buffer, _size, _lidx, &p->TempC_RNTI);
	_serSysEncUplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional(_buffer, _size, _lidx, &p->InitialGrantCE_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponse_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RandomAccessResponse_Type_Value* p, enum RandomAccessResponse_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessResponse_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == RandomAccessResponse_Type_List) {
		HTON_32(&_buffer[*_lidx], p->List.d, _lidx);
		for (size_t i2 = 0; i2 < p->List.d; i2++) {
			_serSysEncRandomAccessResponseParameters_Type(_buffer, _size, _lidx, &p->List.v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponse_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RandomAccessResponse_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRandomAccessResponse_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessBackoffIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RandomAccessBackoffIndicator_Type_Value* p, enum RandomAccessBackoffIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessBackoffIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == RandomAccessBackoffIndicator_Type_Index) {
		HTON_8(&_buffer[*_lidx], p->Index, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessBackoffIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RandomAccessBackoffIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRandomAccessBackoffIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponseCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RandomAccessResponseCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciDlInfoCommon_Type(_buffer, _size, _lidx, &p->DciInfo);
	_serSysEncRandomAccessResponse_Type(_buffer, _size, _lidx, &p->Rar);
	_serSysEncRandomAccessBackoffIndicator_Type(_buffer, _size, _lidx, &p->BackoffInd);

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponseConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RandomAccessResponseConfig_Type_Value* p, enum RandomAccessResponseConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessResponseConfig_Type_Ctrl) {
		_serSysEncRandomAccessResponseCtrl_Type(_buffer, _size, _lidx, &p->Ctrl);
	}
	if (d == RandomAccessResponseConfig_Type_Ctrl_CRC_Error) {
		_serSysEncRandomAccessResponseCtrl_Type(_buffer, _size, _lidx, &p->Ctrl_CRC_Error);
	}
	if (d == RandomAccessResponseConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRandomAccessResponseConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RandomAccessResponseConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRandomAccessResponseConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolution_ContainedId_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ContentionResolution_ContainedId_Type_Value* p, enum ContentionResolution_ContainedId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolution_ContainedId_Type_XorMask) {
		HTON_32(&_buffer[*_lidx], p->XorMask.d, _lidx);
		for (size_t i2 = 0; i2 < p->XorMask.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->XorMask.v[i2], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedId_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolution_ContainedId_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ContentionResolution_ContainedId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncContentionResolution_ContainedId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolution_ContainedDlschSdu_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ContentionResolution_ContainedDlschSdu_Type_Value* p, enum ContentionResolution_ContainedDlschSdu_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolution_ContainedDlschSdu_Type_RlcPduCCCH) {
		HTON_32(&_buffer[*_lidx], p->RlcPduCCCH.d, _lidx);
		for (size_t i2 = 0; i2 < p->RlcPduCCCH.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->RlcPduCCCH.v[i2], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedDlschSdu_Type_PdcpSduDCCH) {
		HTON_32(&_buffer[*_lidx], p->PdcpSduDCCH.d, _lidx);
		for (size_t i2 = 0; i2 < p->PdcpSduDCCH.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->PdcpSduDCCH.v[i2], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedDlschSdu_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolution_ContainedDlschSdu_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ContentionResolution_ContainedDlschSdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncContentionResolution_ContainedDlschSdu_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncTCRNTI_ContentionResolutionMacPdu_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TCRNTI_ContentionResolutionMacPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncContentionResolution_ContainedId_Type(_buffer, _size, _lidx, &p->ContainedId);
	_serSysEncContentionResolution_ContainedDlschSdu_Type(_buffer, _size, _lidx, &p->ContainedRlcPdu);

	return SIDL_STATUS_OK;
}

static int _serSysEncTCRNTI_ContentionResolutionCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TCRNTI_ContentionResolutionCtrl_Type_Value* p, enum TCRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu) {
		_serSysEncTCRNTI_ContentionResolutionMacPdu_Type(_buffer, _size, _lidx, &p->MacPdu);
	}
	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu_CRC_Error) {
		_serSysEncTCRNTI_ContentionResolutionMacPdu_Type(_buffer, _size, _lidx, &p->MacPdu_CRC_Error);
	}
	if (d == TCRNTI_ContentionResolutionCtrl_Type_NoContResolID) {
		HTON_8(&_buffer[*_lidx], p->NoContResolID, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTCRNTI_ContentionResolutionCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TCRNTI_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTCRNTI_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncImcs_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Imcs_Type_Value* p, enum Imcs_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Imcs_Type_Value) {
		HTON_8(&_buffer[*_lidx], p->Value, _lidx);
	}
	if (d == Imcs_Type_NotUsed) {
		HTON_8(&_buffer[*_lidx], p->NotUsed, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncImcs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Imcs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncImcs_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRetransmissionAsynchronous_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RetransmissionAsynchronous_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->RedundencyVer, _lidx);
	HTON_32(&_buffer[*_lidx], p->SubframeOffset, _lidx);
	HTON_8(&_buffer[*_lidx], p->RepetitionNumber, _lidx);
	HTON_8(&_buffer[*_lidx], p->DCISubframeRepetitionNumber, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_TransRetransmission_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UL_TransRetransmission_Type_Value* p, enum UL_TransRetransmission_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_TransRetransmission_Type_NewTransmission) {
		HTON_8(&_buffer[*_lidx], p->NewTransmission, _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionAdaptive) {
		HTON_8(&_buffer[*_lidx], p->ReTransmissionAdaptive, _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionNonAdaptive) {
		HTON_8(&_buffer[*_lidx], p->ReTransmissionNonAdaptive, _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionNonAdaptiveFixedRV) {
		HTON_8(&_buffer[*_lidx], p->ReTransmissionNonAdaptiveFixedRV, _lidx);
	}
	if (d == UL_TransRetransmission_Type_RetransmissionAsynchronous) {
		_serSysEncRetransmissionAsynchronous_Type(_buffer, _size, _lidx, &p->RetransmissionAsynchronous);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_TransRetransmission_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_TransRetransmission_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUL_TransRetransmission_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncFreqDomainSchedulExplicit_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct FreqDomainSchedulExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->FirstRbIndex, _lidx);
	HTON_32(&_buffer[*_lidx], p->Nprb, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcchDciFormat_Type_Format_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcchDciFormat_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncInt32_t_HarqProcessId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_HarqProcessId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncB1_Type_PUSCH_TriggerA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B1_Type_PUSCH_TriggerA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB4_Type_TimingOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B4_Type_TimingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 4; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNumSchedSubframes_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NumSchedSubframes_Type_Value* p, enum NumSchedSubframes_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NumSchedSubframes_Type_MaxTwoSubframes) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->MaxTwoSubframes[i2], _lidx);
		}
	}
	if (d == NumSchedSubframes_Type_MaxFourSubframes) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			HTON_8(&_buffer[*_lidx], p->MaxFourSubframes[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncNumSchedSubframes_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NumSchedSubframes_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncNumSchedSubframes_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncNumSchedSubframes_Type_NumberOfScheduledSubframes_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NumSchedSubframes_Type_NumberOfScheduledSubframes_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncNumSchedSubframes_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciUlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciUlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncImcs_Type(_buffer, _size, _lidx, &p->Imcs);
	HTON_32(&_buffer[*_lidx], p->TransRetransmissionList.d, _lidx);
	for (size_t i2 = 0; i2 < p->TransRetransmissionList.d; i2++) {
		_serSysEncUL_TransRetransmission_Type(_buffer, _size, _lidx, &p->TransRetransmissionList.v[i2]);
	}
	_serSysEncFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	_serSysEncPdcchDciFormat_Type_Format_Optional(_buffer, _size, _lidx, &p->Format);
	_serSysEncInt32_t_HarqProcessId_Optional(_buffer, _size, _lidx, &p->HarqProcessId);
	_serSysEncRepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysEncDCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);
	_serSysEncB1_Type_PUSCH_TriggerA_Optional(_buffer, _size, _lidx, &p->PUSCH_TriggerA);
	_serSysEncB4_Type_TimingOffset_Optional(_buffer, _size, _lidx, &p->TimingOffset);
	_serSysEncNumSchedSubframes_Type_NumberOfScheduledSubframes_Optional(_buffer, _size, _lidx, &p->NumberOfScheduledSubframes);

	return SIDL_STATUS_OK;
}

static int _serSysEncCRNTI_ContentionResolutionCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CRNTI_ContentionResolutionCtrl_Type_Value* p, enum CRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CRNTI_ContentionResolutionCtrl_Type_AutomaticGrant) {
		_serSysEncDciUlInfo_Type(_buffer, _size, _lidx, &p->AutomaticGrant);
	}
	if (d == CRNTI_ContentionResolutionCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCRNTI_ContentionResolutionCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CRNTI_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCRNTI_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolutionCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ContentionResolutionCtrl_Type_Value* p, enum ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolutionCtrl_Type_TCRNTI_Based) {
		_serSysEncTCRNTI_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, &p->TCRNTI_Based);
	}
	if (d == ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serSysEncCRNTI_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, &p->CRNTI_Based);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncContentionResolutionCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRachProcedure_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RachProcedure_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRandomAccessResponseConfig_Type(_buffer, _size, _lidx, &p->RAResponse);
	_serSysEncContentionResolutionCtrl_Type(_buffer, _size, _lidx, &p->ContentionResolutionCtrl);

	return SIDL_STATUS_OK;
}

static int _serSysEncRachProcedureList_Type_RachProcedureList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RachProcedureList_Type_RachProcedureList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncRachProcedure_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRachProcedureConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RachProcedureConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(_buffer, _size, _lidx, &p->RACH_ConfigCommon);
	_serSysEncRACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->RACH_ConfigDedicated);
	_serSysEncRachProcedureList_Type_RachProcedureList_Optional(_buffer, _size, _lidx, &p->RachProcedureList);

	return SIDL_STATUS_OK;
}

static int _serSysEncRachProcedureConfig_Type_RachProcedureConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRachProcedureConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_setup_gapOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasGapConfig_setup_gapOffset_Value* p, enum MeasGapConfig_setup_gapOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_setup_gapOffset_gp0) {
		HTON_8(&_buffer[*_lidx], p->gp0, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp1) {
		HTON_8(&_buffer[*_lidx], p->gp1, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp2_r14) {
		HTON_8(&_buffer[*_lidx], p->gp2_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp3_r14) {
		HTON_8(&_buffer[*_lidx], p->gp3_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg0_r14) {
		HTON_8(&_buffer[*_lidx], p->gp_ncsg0_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg1_r14) {
		HTON_8(&_buffer[*_lidx], p->gp_ncsg1_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg2_r14) {
		HTON_8(&_buffer[*_lidx], p->gp_ncsg2_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg3_r14) {
		HTON_8(&_buffer[*_lidx], p->gp_ncsg3_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform1_r14) {
		HTON_16(&_buffer[*_lidx], p->gp_nonUniform1_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform2_r14) {
		HTON_16(&_buffer[*_lidx], p->gp_nonUniform2_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform3_r14) {
		HTON_16(&_buffer[*_lidx], p->gp_nonUniform3_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform4_r14) {
		HTON_16(&_buffer[*_lidx], p->gp_nonUniform4_r14, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp4_r15) {
		HTON_8(&_buffer[*_lidx], p->gp4_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp5_r15) {
		HTON_8(&_buffer[*_lidx], p->gp5_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp6_r15) {
		HTON_8(&_buffer[*_lidx], p->gp6_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp7_r15) {
		HTON_8(&_buffer[*_lidx], p->gp7_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp8_r15) {
		HTON_8(&_buffer[*_lidx], p->gp8_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp9_r15) {
		HTON_8(&_buffer[*_lidx], p->gp9_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp10_r15) {
		HTON_8(&_buffer[*_lidx], p->gp10_r15, _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp11_r15) {
		HTON_8(&_buffer[*_lidx], p->gp11_r15, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_setup_gapOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapConfig_setup_gapOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasGapConfig_setup_gapOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapConfig_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMeasGapConfig_setup_gapOffset(_buffer, _size, _lidx, &p->gapOffset);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasGapConfig_Value* p, enum MeasGapConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == MeasGapConfig_setup) {
		_serSysEncMeasGapConfig_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasGapConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_mgta_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_mgta_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMeasGapConfig(_buffer, _size, _lidx, &p->measGapConfig);
	_serSysEncBool_mgta_Optional(_buffer, _size, _lidx, &p->mgta);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasGapConfig_Type_Value* p, enum MeasGapConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_Type_R8andLater) {
		_serSysEncMeasGapConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasGapConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasGapCtrl_Type_Value* p, enum MeasGapCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == MeasGapCtrl_Type_Config) {
		_serSysEncMeasGapConfig_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasGapCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasGapCtrl_Type_MeasGapCtrl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasGapCtrl_Type_MeasGapCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasGapCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMIMO_PrecodingBits_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MIMO_PrecodingBits_Type_Value* p, enum MIMO_PrecodingBits_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MIMO_PrecodingBits_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == MIMO_PrecodingBits_Type_Bit2) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->Bit2[i1], _lidx);
		}
	}
	if (d == MIMO_PrecodingBits_Type_Bit3) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			HTON_8(&_buffer[*_lidx], p->Bit3[i1], _lidx);
		}
	}
	if (d == MIMO_PrecodingBits_Type_Bit6) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			HTON_8(&_buffer[*_lidx], p->Bit6[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMIMO_PrecodingBits_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MIMO_PrecodingBits_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMIMO_PrecodingBits_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMIMO_DciDlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MIMO_DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(_buffer, _size, _lidx, &p->RedundancyVersionList_2ndCW);
	for (size_t i1 = 0; i1 < 1; i1++) {
		HTON_8(&_buffer[*_lidx], p->CodeWordSwapFlag[i1], _lidx);
	}
	_serSysEncMIMO_PrecodingBits_Type(_buffer, _size, _lidx, &p->PrecodingBits);

	return SIDL_STATUS_OK;
}

static int _serSysEncMIMO_DciDlInfo_Type_MimoInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MIMO_DciDlInfo_Type_MimoInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMIMO_DciDlInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRepetitionNumber_Type_RepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RepetitionNumber_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfoExplicit_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfoExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncImcs_Type(_buffer, _size, _lidx, &p->Imcs_1stCW);
	_serSysEncImcs_Type(_buffer, _size, _lidx, &p->Imcs_2ndCW);
	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ResourceAllocType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	HTON_32(&_buffer[*_lidx], p->RedundancyVersionList.d, _lidx);
	for (size_t i1 = 0; i1 < p->RedundancyVersionList.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->RedundancyVersionList.v[i1], _lidx);
	}
	_serSysEncMIMO_DciDlInfo_Type_MimoInfo_Optional(_buffer, _size, _lidx, &p->MimoInfo);
	_serSysEncRepetitionNumber_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysEncDCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DciDlInfo_Type_Value* p, enum DciDlInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DciDlInfo_Type_Auto) {
		_serSysEncDciDlInfoCommon_Type(_buffer, _size, _lidx, &p->Auto);
	}
	if (d == DciDlInfo_Type_Explicit) {
		_serSysEncDciDlInfoExplicit_Type(_buffer, _size, _lidx, &p->Explicit);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDciDlInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciDlInfo_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciDlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDciDlInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_codebookSubsetRestriction_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoDedicated_codebookSubsetRestriction_Value* p, enum AntennaInfoDedicated_codebookSubsetRestriction_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm3) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->n2TxAntenna_tm3[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm3) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			HTON_8(&_buffer[*_lidx], p->n4TxAntenna_tm3[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm4) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			HTON_8(&_buffer[*_lidx], p->n2TxAntenna_tm4[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4) {
		for (size_t i1 = 0; i1 < 64; i1++) {
			HTON_8(&_buffer[*_lidx], p->n4TxAntenna_tm4[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm5) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			HTON_8(&_buffer[*_lidx], p->n2TxAntenna_tm5[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm5) {
		for (size_t i1 = 0; i1 < 16; i1++) {
			HTON_8(&_buffer[*_lidx], p->n4TxAntenna_tm5[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm6) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			HTON_8(&_buffer[*_lidx], p->n2TxAntenna_tm6[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm6) {
		for (size_t i1 = 0; i1 < 16; i1++) {
			HTON_8(&_buffer[*_lidx], p->n4TxAntenna_tm6[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_codebookSubsetRestriction(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_codebookSubsetRestriction* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_codebookSubsetRestriction_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_codebookSubsetRestriction(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_ue_TransmitAntennaSelection_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoDedicated_ue_TransmitAntennaSelection_Value* p, enum AntennaInfoDedicated_ue_TransmitAntennaSelection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_ue_TransmitAntennaSelection_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == AntennaInfoDedicated_ue_TransmitAntennaSelection_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_ue_TransmitAntennaSelection(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_ue_TransmitAntennaSelection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_ue_TransmitAntennaSelection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->transmissionMode;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional(_buffer, _size, _lidx, &p->codebookSubsetRestriction);
	_serSysEncAntennaInfoDedicated_ue_TransmitAntennaSelection(_buffer, _size, _lidx, &p->ue_TransmitAntennaSelection);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value* p, enum AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n2TxAntenna_tm8_r9) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			HTON_8(&_buffer[*_lidx], p->n2TxAntenna_tm8_r9[i1], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n4TxAntenna_tm8_r9) {
		for (size_t i1 = 0; i1 < 32; i1++) {
			HTON_8(&_buffer[*_lidx], p->n4TxAntenna_tm8_r9[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v920(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional(_buffer, _size, _lidx, &p->codebookSubsetRestriction_v920);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v920_antennaInfo_v920_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v920_antennaInfo_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoDedicated(_buffer, _size, _lidx, &p->antennaInfo);
	_serSysEncAntennaInfoDedicated_v920_antennaInfo_v920_Optional(_buffer, _size, _lidx, &p->antennaInfo_v920);

	return SIDL_STATUS_OK;
}

static int _serSysEncBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value* p, enum AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_r10_ue_TransmitAntennaSelection(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_r10_ue_TransmitAntennaSelection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->transmissionMode_r10;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(_buffer, _size, _lidx, &p->codebookSubsetRestriction_r10);
	_serSysEncAntennaInfoDedicated_r10_ue_TransmitAntennaSelection(_buffer, _size, _lidx, &p->ue_TransmitAntennaSelection);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoUL_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoUL_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional(_buffer, _size, _lidx, &p->transmissionModeUL_r10);
	_serSysEncAntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional(_buffer, _size, _lidx, &p->fourAntennaPortActivated_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoUL_r10_antennaInfoUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoUL_r10_antennaInfoUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoUL_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v10i0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v10i0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional(_buffer, _size, _lidx, &p->maxLayersMIMO_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_v10i0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->alternativeCodebookEnabledFor4TX_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v1430(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional(_buffer, _size, _lidx, &p->ce_UE_TxAntennaSelection_config_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_R10andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_R10andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAntennaInfoDedicated_r10(_buffer, _size, _lidx, &p->antennaInfo);
	_serSysEncAntennaInfoUL_r10_antennaInfoUL_Optional(_buffer, _size, _lidx, &p->antennaInfoUL);
	_serSysEncAntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v10i0);
	_serSysEncAntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v1250);
	_serSysEncAntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AntennaInfoDedicated_Type_Value* p, enum AntennaInfoDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_Type_R8andLater) {
		_serSysEncAntennaInfoDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == AntennaInfoDedicated_Type_R10andLater) {
		_serSysEncAntennaInfoDedicated_R10andLater_Type(_buffer, _size, _lidx, &p->R10andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAntennaInfoDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAntennaInfoDedicated_Type_AntennaInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AntennaInfoDedicated_Type_AntennaInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAntennaInfoDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncHarqProcessConfigDL_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union HarqProcessConfigDL_Type_Value* p, enum HarqProcessConfigDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == HarqProcessConfigDL_Type_AllProcesses) {
		HTON_8(&_buffer[*_lidx], p->AllProcesses, _lidx);
	}
	if (d == HarqProcessConfigDL_Type_SpecificSubset) {
		HTON_32(&_buffer[*_lidx], p->SpecificSubset.d, _lidx);
		for (size_t i1 = 0; i1 < p->SpecificSubset.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->SpecificSubset.v[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncHarqProcessConfigDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HarqProcessConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncHarqProcessConfigDL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncHarqProcessConfigDL_Type_HarqProcessConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct HarqProcessConfigDL_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncHarqProcessConfigDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfigDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciDlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);
	_serSysEncAntennaInfoDedicated_Type_AntennaInfo_Optional(_buffer, _size, _lidx, &p->AntennaInfo);
	_serSysEncHarqProcessConfigDL_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfigDL_Type_DL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfigDL_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCcchDcchDtchConfigDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDciUlInfo_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DciUlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDciUlInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPucchHoppingBits_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PucchHoppingBits_Type_Value* p, enum PucchHoppingBits_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PucchHoppingBits_Type_OneBit) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->OneBit[i1], _lidx);
		}
	}
	if (d == PucchHoppingBits_Type_TwoBits) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->TwoBits[i1], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPucchHoppingBits_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PucchHoppingBits_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPucchHoppingBits_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkHoppingResourceParameters_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkHoppingResourceParameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPucchHoppingBits_Type(_buffer, _size, _lidx, &p->PucchHopping);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkHoppingControl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UplinkHoppingControl_Type_Value* p, enum UplinkHoppingControl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkHoppingControl_Type_Deactivated) {
		HTON_8(&_buffer[*_lidx], p->Deactivated, _lidx);
	}
	if (d == UplinkHoppingControl_Type_Activated) {
		_serSysEncUplinkHoppingResourceParameters_Type(_buffer, _size, _lidx, &p->Activated);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkHoppingControl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkHoppingControl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkHoppingControl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkHoppingControl_Type_Hopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkHoppingControl_Type_Hopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkHoppingControl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncTransmissionRepetition_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TransmissionRepetition_Type_Value* p, enum TransmissionRepetition_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionRepetition_Type_Continuous) {
		HTON_8(&_buffer[*_lidx], p->Continuous, _lidx);
	}
	if (d == TransmissionRepetition_Type_NumOfCycles) {
		HTON_32(&_buffer[*_lidx], p->NumOfCycles, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTransmissionRepetition_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TransmissionRepetition_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTransmissionRepetition_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkTimeAlignment_AutoSynch_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkTimeAlignment_AutoSynch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->TimingAdvance, _lidx);
	HTON_16(&_buffer[*_lidx], p->TA_Period, _lidx);
	_serSysEncTransmissionRepetition_Type(_buffer, _size, _lidx, &p->TA_Repetition);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkTimeAlignment_Synch_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UplinkTimeAlignment_Synch_Type_Value* p, enum UplinkTimeAlignment_Synch_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkTimeAlignment_Synch_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == UplinkTimeAlignment_Synch_Type_Auto) {
		_serSysEncUplinkTimeAlignment_AutoSynch_Type(_buffer, _size, _lidx, &p->Auto);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkTimeAlignment_Synch_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkTimeAlignment_Synch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUplinkTimeAlignment_Synch_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUplinkTimeAlignment_Synch_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncULGrant_Period_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ULGrant_Period_Type_Value* p, enum ULGrant_Period_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ULGrant_Period_Type_OnlyOnce) {
		HTON_8(&_buffer[*_lidx], p->OnlyOnce, _lidx);
	}
	if (d == ULGrant_Period_Type_Duration) {
		HTON_32(&_buffer[*_lidx], p->Duration, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncULGrant_Period_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ULGrant_Period_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncULGrant_Period_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPeriodicGrant_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PeriodicGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncULGrant_Period_Type(_buffer, _size, _lidx, &p->Period);
	_serSysEncTransmissionRepetition_Type(_buffer, _size, _lidx, &p->NoOfRepetitions);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_GrantConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UL_GrantConfig_Type_Value* p, enum UL_GrantConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_GrantConfig_Type_OnSR_Reception) {
		HTON_8(&_buffer[*_lidx], p->OnSR_Reception, _lidx);
	}
	if (d == UL_GrantConfig_Type_Periodic) {
		_serSysEncPeriodicGrant_Type(_buffer, _size, _lidx, &p->Periodic);
	}
	if (d == UL_GrantConfig_Type_PeriodicOnSR_Reception) {
		_serSysEncPeriodicGrant_Type(_buffer, _size, _lidx, &p->PeriodicOnSR_Reception);
	}
	if (d == UL_GrantConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_GrantConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_GrantConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUL_GrantConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_GrantConfig_Type_UL_GrantConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_GrantConfig_Type_UL_GrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUL_GrantConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfigUL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDciUlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);
	_serSysEncUplinkHoppingControl_Type_Hopping_Optional(_buffer, _size, _lidx, &p->Hopping);
	_serSysEncUplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(_buffer, _size, _lidx, &p->PUCCH_Synch);
	_serSysEncUL_GrantConfig_Type_UL_GrantConfig_Optional(_buffer, _size, _lidx, &p->UL_GrantConfig);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfigUL_Type_UL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfigUL_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCcchDcchDtchConfigUL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_setup_longDRX_CycleStartOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DRX_Config_setup_longDRX_CycleStartOffset_Value* p, enum DRX_Config_setup_longDRX_CycleStartOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf10) {
		HTON_8(&_buffer[*_lidx], p->sf10, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf20) {
		HTON_8(&_buffer[*_lidx], p->sf20, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf32) {
		HTON_8(&_buffer[*_lidx], p->sf32, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf40) {
		HTON_8(&_buffer[*_lidx], p->sf40, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf64) {
		HTON_8(&_buffer[*_lidx], p->sf64, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf80) {
		HTON_8(&_buffer[*_lidx], p->sf80, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf128) {
		HTON_8(&_buffer[*_lidx], p->sf128, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf160) {
		HTON_8(&_buffer[*_lidx], p->sf160, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf256) {
		HTON_8(&_buffer[*_lidx], p->sf256, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf320) {
		HTON_16(&_buffer[*_lidx], p->sf320, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf512) {
		HTON_16(&_buffer[*_lidx], p->sf512, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf640) {
		HTON_16(&_buffer[*_lidx], p->sf640, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf1024) {
		HTON_16(&_buffer[*_lidx], p->sf1024, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf1280) {
		HTON_16(&_buffer[*_lidx], p->sf1280, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf2048) {
		HTON_16(&_buffer[*_lidx], p->sf2048, _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf2560) {
		HTON_16(&_buffer[*_lidx], p->sf2560, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_setup_longDRX_CycleStartOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_setup_longDRX_CycleStartOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDRX_Config_setup_longDRX_CycleStartOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_setup_shortDRX(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_setup_shortDRX* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->shortDRX_Cycle;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->drxShortCycleTimer, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_setup_shortDRX_shortDRX_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_setup_shortDRX_shortDRX_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDRX_Config_setup_shortDRX(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->onDurationTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->drx_InactivityTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->drx_RetransmissionTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDRX_Config_setup_longDRX_CycleStartOffset(_buffer, _size, _lidx, &p->longDRX_CycleStartOffset);
	_serSysEncDRX_Config_setup_shortDRX_shortDRX_Optional(_buffer, _size, _lidx, &p->shortDRX);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DRX_Config_Value* p, enum DRX_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == DRX_Config_setup) {
		_serSysEncDRX_Config_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDRX_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_R8_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_R8_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDRX_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional(_buffer, _size, _lidx, &p->onDurationTimer_v1310);
	_serSysEncDRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional(_buffer, _size, _lidx, &p->drx_RetransmissionTimer_v1310);
	_serSysEncDRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional(_buffer, _size, _lidx, &p->drx_ULRetransmissionTimer_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_MainConfig_drx_Config_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MAC_MainConfig_drx_Config_r13_Value* p, enum MAC_MainConfig_drx_Config_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_drx_Config_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == MAC_MainConfig_drx_Config_r13_setup) {
		_serSysEncDRX_Config_r13(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const DRX_Config_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMAC_MainConfig_drx_Config_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_r13_Type_R13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_r13_Type_R13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDRX_Config_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value* p, enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_sf5120) {
		HTON_8(&_buffer[*_lidx], p->sf5120, _lidx);
	}
	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_sf10240) {
		HTON_8(&_buffer[*_lidx], p->sf10240, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value* p, enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup) {
		_serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEDRX_CycleStartOffset_r13_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const EDRX_CycleStartOffset_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEDRX_CycleStartOffset_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDRX_Config_R8_Optional(_buffer, _size, _lidx, &p->R8);
	_serSysEncDRX_Config_r13_Type_R13_Optional(_buffer, _size, _lidx, &p->R13);
	_serSysEncEDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional(_buffer, _size, _lidx, &p->EDRX_CycleStartOffset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DRX_Config_Type_Value* p, enum DRX_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_Type_R8andLater) {
		_serSysEncDRX_Config_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDRX_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DRX_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDRX_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDrxCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DrxCtrl_Type_Value* p, enum DrxCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DrxCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == DrxCtrl_Type_Config) {
		_serSysEncDRX_Config_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDrxCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DrxCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDrxCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDrxCtrl_Type_DrxCtrl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DrxCtrl_Type_DrxCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDrxCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncE_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct E_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncTTI_BundlingConfig_R8andLater_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TTI_BundlingConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->TTI_BundlingEnabled, _lidx);
	_serSysEncE_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional(_buffer, _size, _lidx, &p->E_HARQ_Pattern);

	return SIDL_STATUS_OK;
}

static int _serSysEncTTI_BundlingConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TTI_BundlingConfig_Type_Value* p, enum TTI_BundlingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TTI_BundlingConfig_Type_R8) {
		HTON_8(&_buffer[*_lidx], p->R8, _lidx);
	}
	if (d == TTI_BundlingConfig_Type_R8andLater) {
		_serSysEncTTI_BundlingConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncTTI_BundlingConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TTI_BundlingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncTTI_BundlingConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncTTI_BundlingConfig_Type_TtiBundling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TTI_BundlingConfig_Type_TtiBundling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTTI_BundlingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_CifPresence_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_CifPresence_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMeasGapCtrl_Type_MeasGapCtrl_Optional(_buffer, _size, _lidx, &p->MeasGapCtrl);
	_serSysEncCcchDcchDtchConfigDL_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);
	_serSysEncCcchDcchDtchConfigUL_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serSysEncDrxCtrl_Type_DrxCtrl_Optional(_buffer, _size, _lidx, &p->DrxCtrl);
	_serSysEncTTI_BundlingConfig_Type_TtiBundling_Optional(_buffer, _size, _lidx, &p->TtiBundling);
	_serSysEncBool_CifPresence_Optional(_buffer, _size, _lidx, &p->CifPresence);

	return SIDL_STATUS_OK;
}

static int _serSysEncCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCcchDcchDtchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePatternPCell_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MeasSubframePatternPCell_r10_Value* p, enum MeasSubframePatternPCell_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePatternPCell_r10_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == MeasSubframePatternPCell_r10_setup) {
		_serSysEncMeasSubframePattern_r10(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePatternPCell_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasSubframePatternPCell_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMeasSubframePatternPCell_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMeasSubframePatternPCell_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->cif_Presence_r10, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingCellId_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->pdsch_Start_r10, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value* p, enum CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10) {
		_serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10(_buffer, _size, _lidx, &p->own_r10);
	}
	if (d == CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10) {
		_serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10(_buffer, _size, _lidx, &p->other_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10(_buffer, _size, _lidx, &p->schedulingCellInfo_r10);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCrossCarrierSchedulingConfig_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->cif_Presence_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingCellId_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->pdsch_Start_r13, _lidx);
	HTON_8(&_buffer[*_lidx], p->cif_InSchedulingCell_r13, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value* p, enum CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13) {
		_serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13(_buffer, _size, _lidx, &p->own_r13);
	}
	if (d == CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13) {
		_serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13(_buffer, _size, _lidx, &p->other_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13(_buffer, _size, _lidx, &p->schedulingCellInfo_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCrossCarrierSchedulingConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierScheduledCellsList_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierScheduledCellsList_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_r10);
	_serSysEncCrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCrossCarrierScheduledCellsList_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPrimaryCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PrimaryCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->AssociatedScellList.d, _lidx);
	for (size_t i1 = 0; i1 < p->AssociatedScellList.d; i1++) {
		{
			size_t _tmp = (size_t)p->AssociatedScellList.v[i1];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	_serSysEncMeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional(_buffer, _size, _lidx, &p->MeasSubframePatternPCell);
	_serSysEncCrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional(_buffer, _size, _lidx, &p->CrossCarrierScheduledCellsList);

	return SIDL_STATUS_OK;
}

static int _serSysEncScell_Capability_Type_Scell_Capability_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Scell_Capability_Type_Scell_Capability_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncScellDeactivationTimer_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ScellDeactivationTimer_Type_Value* p, enum ScellDeactivationTimer_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ScellDeactivationTimer_Type_NumberOfRadioFrames) {
		{
			size_t _tmp = (size_t)p->NumberOfRadioFrames;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == ScellDeactivationTimer_Type_Infinity) {
		HTON_8(&_buffer[*_lidx], p->Infinity, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncScellDeactivationTimer_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ScellDeactivationTimer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncScellDeactivationTimer_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncScellDeactivationTimer_Type_ScellDeactivationTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ScellDeactivationTimer_Type_ScellDeactivationTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncScellDeactivationTimer_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossSchedulingCarrierInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const CrossSchedulingCarrierInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingCellId_r10, _lidx);
	HTON_8(&_buffer[*_lidx], p->pdsch_Start_r10, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingCarrierConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SchedulingCarrierConfig_Type_Value* p, enum SchedulingCarrierConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingCarrierConfig_Type_Own) {
		_serSysEncCrossCarrierScheduledCellsList_Type(_buffer, _size, _lidx, &p->Own);
	}
	if (d == SchedulingCarrierConfig_Type_CrossScheduled) {
		_serSysEncCrossSchedulingCarrierInfo_Type(_buffer, _size, _lidx, &p->CrossScheduled);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSchedulingCarrierConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SchedulingCarrierConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSchedulingCarrierConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CrossCarrierSchedulingConfig_Type_Value* p, enum CrossCarrierSchedulingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_Type_Config) {
		_serSysEncSchedulingCarrierConfig_Type(_buffer, _size, _lidx, &p->Config);
	}
	if (d == CrossCarrierSchedulingConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCrossCarrierSchedulingConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCrossCarrierSchedulingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSTAG_Id_r11_STAG_Id_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct STAG_Id_r11_STAG_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcell_Mode_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Pcell_Mode_Type_Value* p, enum Pcell_Mode_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pcell_Mode_Type_FDD) {
		HTON_8(&_buffer[*_lidx], p->FDD, _lidx);
	}
	if (d == Pcell_Mode_Type_TDD) {
		{
			size_t _tmp = (size_t)p->TDD;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPcell_Mode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Pcell_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPcell_Mode_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Pcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPcell_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecondaryCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecondaryCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->AssociatedPcellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->SCellIndex, _lidx);
	_serSysEncScell_Capability_Type_Scell_Capability_Optional(_buffer, _size, _lidx, &p->Scell_Capability);
	_serSysEncScellDeactivationTimer_Type_ScellDeactivationTimer_Optional(_buffer, _size, _lidx, &p->ScellDeactivationTimer);
	_serSysEncCrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional(_buffer, _size, _lidx, &p->CrossCarrierSchedulingConfig);
	_serSysEncSTAG_Id_r11_STAG_Id_Optional(_buffer, _size, _lidx, &p->STAG_Id);
	_serSysEncPcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional(_buffer, _size, _lidx, &p->Pcell_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysEncCrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCrossCarrierSchedulingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Pcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPcell_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPSCellInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PSCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->AssociatedPcellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->SCellIndex, _lidx);
	HTON_32(&_buffer[*_lidx], p->AssociatedScellList.d, _lidx);
	for (size_t i1 = 0; i1 < p->AssociatedScellList.d; i1++) {
		{
			size_t _tmp = (size_t)p->AssociatedScellList.v[i1];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	_serSysEncCrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional(_buffer, _size, _lidx, &p->CrossCarrierSchedulingConfig);
	_serSysEncPcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional(_buffer, _size, _lidx, &p->Pcell_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysEncServingCellConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ServingCellConfig_Type_Value* p, enum ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ServingCellConfig_Type_PCell) {
		_serSysEncPrimaryCellInfo_Type(_buffer, _size, _lidx, &p->PCell);
	}
	if (d == ServingCellConfig_Type_SCell) {
		_serSysEncSecondaryCellInfo_Type(_buffer, _size, _lidx, &p->SCell);
	}
	if (d == ServingCellConfig_Type_PSCell) {
		_serSysEncPSCellInfo_Type(_buffer, _size, _lidx, &p->PSCell);
	}
	if (d == ServingCellConfig_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncServingCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncServingCellConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncServingCellConfig_Type_ServingCellConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncC_RNTI_SL_RNTI_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct C_RNTI_SL_RNTI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncN_PSCCH_Type_N_PSCCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct N_PSCCH_Type_N_PSCCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 6; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_Sci0Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_Sci0Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUplinkHoppingControl_Type(_buffer, _size, _lidx, &p->Hopping);
	_serSysEncFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	HTON_8(&_buffer[*_lidx], p->Itrp, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_Sci0Config_Type_SL_Sheduling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_Sci0Config_Type_SL_Sheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_Sci0Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSci0SchedulingConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sci0SchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncC_RNTI_SL_RNTI_r12_Optional(_buffer, _size, _lidx, &p->SL_RNTI_r12);
	_serSysEncN_PSCCH_Type_N_PSCCH_Optional(_buffer, _size, _lidx, &p->N_PSCCH);
	_serSysEncSL_Sci0Config_Type_SL_Sheduling_Optional(_buffer, _size, _lidx, &p->SL_Sheduling);

	return SIDL_STATUS_OK;
}

static int _serSysEncC_RNTI_SL_V_RNTI_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct C_RNTI_SL_V_RNTI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB3_Type_CarrierIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B3_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBIT_STRING_LowestIndexOfChannelAllocation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct BIT_STRING_LowestIndexOfChannelAllocation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB2_Type_SL_Index_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_Type_SL_Index_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB3_Type_SL_SPS_ConfigurationIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B3_Type_SL_SPS_ConfigurationIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncB1_Type_SL_SPS_ActivationRelease_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B1_Type_SL_SPS_ActivationRelease_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_Sci1Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_Sci1Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->FreqResourceAllocation.d, _lidx);
	for (size_t i1 = 0; i1 < p->FreqResourceAllocation.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->FreqResourceAllocation.v[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 4; i1++) {
		HTON_8(&_buffer[*_lidx], p->TimeGap[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SL_Sci1Config_Type_SL_SCI1_Scheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSL_Sci1Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSci1SchedulingConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Sci1SchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncC_RNTI_SL_V_RNTI_r12_Optional(_buffer, _size, _lidx, &p->SL_V_RNTI_r12);
	_serSysEncB3_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serSysEncBIT_STRING_LowestIndexOfChannelAllocation_Optional(_buffer, _size, _lidx, &p->LowestIndexOfChannelAllocation);
	_serSysEncB2_Type_SL_Index_Optional(_buffer, _size, _lidx, &p->SL_Index);
	_serSysEncB3_Type_SL_SPS_ConfigurationIndex_Optional(_buffer, _size, _lidx, &p->SL_SPS_ConfigurationIndex);
	_serSysEncB1_Type_SL_SPS_ActivationRelease_Optional(_buffer, _size, _lidx, &p->SL_SPS_ActivationRelease);
	_serSysEncSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(_buffer, _size, _lidx, &p->SL_SCI1_Scheduling);

	return SIDL_STATUS_OK;
}

static int _serSysEncSciSchedulingConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SciSchedulingConfig_Type_Value* p, enum SciSchedulingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SciSchedulingConfig_Type_SCI0) {
		_serSysEncSci0SchedulingConfig_Type(_buffer, _size, _lidx, &p->SCI0);
	}
	if (d == SciSchedulingConfig_Type_SCI1) {
		_serSysEncSci1SchedulingConfig_Type(_buffer, _size, _lidx, &p->SCI1);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSciSchedulingConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SciSchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSciSchedulingConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSciSchedulingConfig_Type_SciSchedulingConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SciSchedulingConfig_Type_SciSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSciSchedulingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfig_r12_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfig_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 16; i1++) {
		HTON_8(&_buffer[*_lidx], p->eimta_RNTI_r12[i1], _lidx);
	}
	{
		size_t _tmp = (size_t)p->eimta_CommandPeriodicity_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 10; i1++) {
		HTON_8(&_buffer[*_lidx], p->eimta_CommandSubframeSet_r12[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfig_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EIMTA_MainConfig_r12_Value* p, enum EIMTA_MainConfig_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfig_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EIMTA_MainConfig_r12_setup) {
		_serSysEncEIMTA_MainConfig_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfig_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEIMTA_MainConfig_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->subframeConfigList_r12.d, _lidx);
	for (size_t i1 = 0; i1 < p->subframeConfigList_r12.d; i1++) {
		_serSysEncMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->subframeConfigList_r12.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value* p, enum EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup) {
		_serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfigServCell_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->eimta_UL_DL_ConfigIndex_r12, _lidx);
	{
		size_t _tmp = (size_t)p->eimta_HARQ_ReferenceConfig_r12;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union EIMTA_MainConfigServCell_r12_Value* p, enum EIMTA_MainConfigServCell_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfigServCell_r12_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == EIMTA_MainConfigServCell_r12_setup) {
		_serSysEncEIMTA_MainConfigServCell_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_MainConfigServCell_r12(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_MainConfigServCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncEIMTA_MainConfigServCell_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEIMTA_MainConfig_r12(_buffer, _size, _lidx, &p->EIMTA_MainConfig_r12);
	_serSysEncEIMTA_MainConfigServCell_r12(_buffer, _size, _lidx, &p->EIMTA_MainConfigServCell_r12);

	return SIDL_STATUS_OK;
}

static int _serSysEncEIMTA_Config_Type_EIMTA_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EIMTA_Config_Type_EIMTA_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEIMTA_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPhysicalConfigDedicated_ce_Mode_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PhysicalConfigDedicated_ce_Mode_r13_Value* p, enum PhysicalConfigDedicated_ce_Mode_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PhysicalConfigDedicated_ce_Mode_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PhysicalConfigDedicated_ce_Mode_r13_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCE_Mode_r13_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const CE_Mode_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPhysicalConfigDedicated_ce_Mode_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCE_Mode_r13_Type_CE_Mode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CE_Mode_r13_Type_CE_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncCE_Mode_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncActiveCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ActiveCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncC_RNTI_C_RNTI_Optional(_buffer, _size, _lidx, &p->C_RNTI);
	_serSysEncPhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(_buffer, _size, _lidx, &p->PhysicalLayerConfigUL);
	_serSysEncRachProcedureConfig_Type_RachProcedureConfig_Optional(_buffer, _size, _lidx, &p->RachProcedureConfig);
	_serSysEncCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(_buffer, _size, _lidx, &p->CcchDcchDtchConfig);
	_serSysEncServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, &p->ServingCellConfig);
	_serSysEncSciSchedulingConfig_Type_SciSchedulingConfig_Optional(_buffer, _size, _lidx, &p->SciSchedulingConfig);
	_serSysEncEIMTA_Config_Type_EIMTA_Config_Optional(_buffer, _size, _lidx, &p->EIMTA_Config);
	_serSysEncCE_Mode_r13_Type_CE_Mode_Optional(_buffer, _size, _lidx, &p->CE_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysEncActiveCellConfig_Type_Active_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ActiveCellConfig_Type_Active_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncActiveCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncBasicCellConfig_Type_Basic_Optional(_buffer, _size, _lidx, &p->Basic);
	_serSysEncActiveCellConfig_Type_Active_Optional(_buffer, _size, _lidx, &p->Active);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellConfigRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union CellConfigRequest_Type_Value* p, enum CellConfigRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CellConfigRequest_Type_AddOrReconfigure) {
		_serSysEncCellConfigInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
	}
	if (d == CellConfigRequest_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncCellConfigRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellConfigRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncCellConfigRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncAttenuation_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Attenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAttenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncTimingInfo_Type_TimingInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimingInfo_Type_TimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncCellAttenuationConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellAttenuationConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);
	_serSysEncTimingInfo_Type_TimingInfo_Optional(_buffer, _size, _lidx, &p->TimingInfo);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_discardTimer_e_discardTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_discardTimer_e_discardTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_rlc_AM(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_rlc_AM* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->statusReportRequired, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_rlc_AM_rlc_AM_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_rlc_AM_rlc_AM_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_rlc_AM(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_rlc_UM(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_rlc_UM* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pdcp_SN_Size;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_rlc_UM_rlc_UM_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_rlc_UM_rlc_UM_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_rlc_UM(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_headerCompression_rohc_profiles(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_headerCompression_rohc_profiles* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->profile0x0001, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0002, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0003, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0004, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0006, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0101, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0102, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0103, _lidx);
	HTON_8(&_buffer[*_lidx], p->profile0x0104, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_headerCompression_rohc(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_headerCompression_rohc* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional(_buffer, _size, _lidx, &p->maxCID);
	_serSysEncPDCP_Config_headerCompression_rohc_profiles(_buffer, _size, _lidx, &p->profiles);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_headerCompression_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_headerCompression_Value* p, enum PDCP_Config_headerCompression_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_headerCompression_notUsed) {
		HTON_8(&_buffer[*_lidx], p->notUsed, _lidx);
	}
	if (d == PDCP_Config_headerCompression_rohc) {
		_serSysEncPDCP_Config_headerCompression_rohc(_buffer, _size, _lidx, &p->rohc);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_headerCompression(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_headerCompression* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_headerCompression_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_DataSplitThreshold_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_ul_DataSplitThreshold_r13_Value* p, enum PDCP_Config_ul_DataSplitThreshold_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_ul_DataSplitThreshold_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCP_Config_ul_DataSplitThreshold_r13_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_DataSplitThreshold_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_DataSplitThreshold_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_ul_DataSplitThreshold_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_ul_DataSplitThreshold_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_TypeForPolling_r13);
	_serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Type1_r13);
	_serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Type2_r13);
	_serSysEncPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Offset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_statusFeedback_r13_Value* p, enum PDCP_Config_statusFeedback_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_statusFeedback_r13_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCP_Config_statusFeedback_r13_setup) {
		_serSysEncPDCP_Config_statusFeedback_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_statusFeedback_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_statusFeedback_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_LWA_Config_r14_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_LWA_Config_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ul_LWA_DRB_ViaWLAN_r14, _lidx);
	_serSysEncPDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional(_buffer, _size, _lidx, &p->ul_LWA_DataSplitThreshold_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_LWA_Config_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_ul_LWA_Config_r14_Value* p, enum PDCP_Config_ul_LWA_Config_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_ul_LWA_Config_r14_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCP_Config_ul_LWA_Config_r14_setup) {
		_serSysEncPDCP_Config_ul_LWA_Config_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_LWA_Config_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_LWA_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_ul_LWA_Config_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_ul_LWA_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->profile0x0006_r14, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional(_buffer, _size, _lidx, &p->maxCID_r14);
	_serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14(_buffer, _size, _lidx, &p->profiles_r14);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_uplinkOnlyHeaderCompression_r14_Value* p, enum PDCP_Config_uplinkOnlyHeaderCompression_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_uplinkOnlyHeaderCompression_r14_notUsed_r14) {
		HTON_8(&_buffer[*_lidx], p->notUsed_r14, _lidx);
	}
	if (d == PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14) {
		_serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14(_buffer, _size, _lidx, &p->rohc_r14);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkOnlyHeaderCompression_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkDataCompression_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkDataCompression_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->bufferSize_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional(_buffer, _size, _lidx, &p->dictionary_r15);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_uplinkDataCompression_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_setup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_pdcp_DuplicationConfig_r15_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->pdcp_Duplication_r15;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_pdcp_DuplicationConfig_r15_Value* p, enum PDCP_Config_pdcp_DuplicationConfig_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_pdcp_DuplicationConfig_r15_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == PDCP_Config_pdcp_DuplicationConfig_r15_setup) {
		_serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_DuplicationConfig_r15(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_pdcp_DuplicationConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Config_pdcp_DuplicationConfig_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Common_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Common_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->ehc_CID_Length_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Downlink_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional(_buffer, _size, _lidx, &p->drb_ContinueEHC_DL_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Uplink_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->maxCID_EHC_UL_r16, _lidx);
	_serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional(_buffer, _size, _lidx, &p->drb_ContinueEHC_UL_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncEthernetHeaderCompression_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct EthernetHeaderCompression_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncEthernetHeaderCompression_r16_ehc_Common_r16(_buffer, _size, _lidx, &p->ehc_Common_r16);
	_serSysEncEthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional(_buffer, _size, _lidx, &p->ehc_Downlink_r16);
	_serSysEncEthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional(_buffer, _size, _lidx, &p->ehc_Uplink_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value* p, enum SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
	}
	if (d == SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_setup) {
		_serSysEncEthernetHeaderCompression_r16(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SetupRelease_PDCP_Config_ethernetHeaderCompression_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDCP_Config_discardTimer_e_discardTimer_Optional(_buffer, _size, _lidx, &p->discardTimer);
	_serSysEncPDCP_Config_rlc_AM_rlc_AM_Optional(_buffer, _size, _lidx, &p->rlc_AM);
	_serSysEncPDCP_Config_rlc_UM_rlc_UM_Optional(_buffer, _size, _lidx, &p->rlc_UM);
	_serSysEncPDCP_Config_headerCompression(_buffer, _size, _lidx, &p->headerCompression);
	_serSysEncPDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional(_buffer, _size, _lidx, &p->rn_IntegrityProtection_r10);
	_serSysEncPDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional(_buffer, _size, _lidx, &p->pdcp_SN_Size_v1130);
	_serSysEncBool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional(_buffer, _size, _lidx, &p->ul_DataSplitDRB_ViaSCG_r12);
	_serSysEncPDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional(_buffer, _size, _lidx, &p->t_Reordering_r12);
	_serSysEncPDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional(_buffer, _size, _lidx, &p->ul_DataSplitThreshold_r13);
	_serSysEncPDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional(_buffer, _size, _lidx, &p->pdcp_SN_Size_v1310);
	_serSysEncPDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional(_buffer, _size, _lidx, &p->statusFeedback_r13);
	_serSysEncPDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional(_buffer, _size, _lidx, &p->ul_LWA_Config_r14);
	_serSysEncPDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional(_buffer, _size, _lidx, &p->uplinkOnlyHeaderCompression_r14);
	_serSysEncPDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional(_buffer, _size, _lidx, &p->uplinkDataCompression_r15);
	_serSysEncPDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional(_buffer, _size, _lidx, &p->pdcp_DuplicationConfig_r15);
	_serSysEncSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional(_buffer, _size, _lidx, &p->ethernetHeaderCompression_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Config_Type_Value* p, enum PDCP_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_Type_R8) {
		_serSysEncPDCP_Config(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_RBConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_RBConfig_Type_Value* p, enum PDCP_RBConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_RBConfig_Type_Srb) {
		HTON_8(&_buffer[*_lidx], p->Srb, _lidx);
	}
	if (d == PDCP_RBConfig_Type_Drb) {
		_serSysEncPDCP_Config_Type(_buffer, _size, _lidx, &p->Drb);
	}
	if (d == PDCP_RBConfig_Type_Transparent) {
		HTON_8(&_buffer[*_lidx], p->Transparent, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_RBConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_RBConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_RBConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_RBConfig_Type_Rb_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_RBConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_RBConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_ROHC_Mode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_ROHC_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->SN_Size;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_NonROHC_Mode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_NonROHC_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->SN_Size;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_TestModeInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_TestModeInfo_Type_Value* p, enum PDCP_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_TestModeInfo_Type_PDCP_ROHC_Mode) {
		_serSysEncPDCP_ROHC_Mode_Type(_buffer, _size, _lidx, &p->PDCP_ROHC_Mode);
	}
	if (d == PDCP_TestModeInfo_Type_PDCP_NonROHC_Mode) {
		_serSysEncPDCP_NonROHC_Mode_Type(_buffer, _size, _lidx, &p->PDCP_NonROHC_Mode);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_TestModeInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_TestModeConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_TestModeConfig_Type_Value* p, enum PDCP_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_TestModeConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == PDCP_TestModeConfig_Type_Info) {
		_serSysEncPDCP_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_TestModeConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_TestModeConfig_Type_TestMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_ConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_ConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDCP_RBConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serSysEncPDCP_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Configuration_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_Configuration_Type_Value* p, enum PDCP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Configuration_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == PDCP_Configuration_Type_Config) {
		_serSysEncPDCP_ConfigInfo_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_Configuration_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_Configuration_Type_Pdcp_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_Configuration_Type_Pdcp_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPDCP_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_AM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t_PollRetransmit;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pollPDU;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pollByte;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->maxRetxThreshold;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_AM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UL_AM_RLC_Type_Value* p, enum UL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_AM_RLC_Type_R8) {
		_serSysEncUL_AM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_AM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_AM_RLC_Type_Tx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_AM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_AM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t_Reordering;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_StatusProhibit;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_AM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DL_AM_RLC_Type_Value* p, enum DL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DL_AM_RLC_Type_R8) {
		_serSysEncDL_AM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_AM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_AM_RLC_Type_Rx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_AM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_Config_v1250(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_Config_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ul_extended_RLC_LI_Field_r12, _lidx);
	HTON_8(&_buffer[*_lidx], p->dl_extended_RLC_LI_Field_r12, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_Config_v1250_ExtendedLI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_Config_v1250_ExtendedLI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRLC_Config_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RLC_AM_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RLC_AM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUL_AM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serSysEncDL_AM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);
	_serSysEncRLC_Config_v1250_ExtendedLI_Optional(_buffer, _size, _lidx, &p->ExtendedLI);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_UM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sn_FieldLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_UM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UL_UM_RLC_Type_Value* p, enum UL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_UM_RLC_Type_R8) {
		_serSysEncUL_UM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_UM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncUL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_UM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sn_FieldLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_Reordering;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_UM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DL_UM_RLC_Type_Value* p, enum DL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DL_UM_RLC_Type_R8) {
		_serSysEncDL_UM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_UM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncDL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RLC_UM_Bi_Directional_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RLC_UM_Bi_Directional_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serSysEncDL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serSysEncDL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncDL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RLC_UM_Uni_Directional_UL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RLC_UM_Uni_Directional_UL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncDL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncUL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncSS_RLC_UM_Uni_Directional_DL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SS_RLC_UM_Uni_Directional_DL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncUL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_RbConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RLC_RbConfig_Type_Value* p, enum RLC_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_RbConfig_Type_AM) {
		_serSysEncSS_RLC_AM_Type(_buffer, _size, _lidx, &p->AM);
	}
	if (d == RLC_RbConfig_Type_UM) {
		_serSysEncSS_RLC_UM_Bi_Directional_Type(_buffer, _size, _lidx, &p->UM);
	}
	if (d == RLC_RbConfig_Type_UM_OnlyUL) {
		_serSysEncSS_RLC_UM_Uni_Directional_UL_Type(_buffer, _size, _lidx, &p->UM_OnlyUL);
	}
	if (d == RLC_RbConfig_Type_UM_OnlyDL) {
		_serSysEncSS_RLC_UM_Uni_Directional_DL_Type(_buffer, _size, _lidx, &p->UM_OnlyDL);
	}
	if (d == RLC_RbConfig_Type_TM) {
		HTON_8(&_buffer[*_lidx], p->TM, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_RbConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRLC_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_RbConfig_Type_Rb_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_RbConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRLC_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_TestModeInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RLC_TestModeInfo_Type_Value* p, enum RLC_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_TestModeInfo_Type_AckProhibit) {
		{
			size_t _tmp = (size_t)p->AckProhibit;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == RLC_TestModeInfo_Type_NotACK_NextRLC_PDU) {
		{
			size_t _tmp = (size_t)p->NotACK_NextRLC_PDU;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}
	if (d == RLC_TestModeInfo_Type_ModifyVTS) {
		HTON_16(&_buffer[*_lidx], p->ModifyVTS, _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_UMDwith5BitSN) {
		HTON_8(&_buffer[*_lidx], p->TransparentMode_UMDwith5BitSN, _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_UMDwith10BitSN) {
		HTON_8(&_buffer[*_lidx], p->TransparentMode_UMDwith10BitSN, _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_AMD) {
		HTON_8(&_buffer[*_lidx], p->TransparentMode_AMD, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_TestModeInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRLC_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_TestModeConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RLC_TestModeConfig_Type_Value* p, enum RLC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_TestModeConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == RLC_TestModeConfig_Type_Info) {
		_serSysEncRLC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_TestModeConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRLC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_TestModeConfig_Type_TestMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRLC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRLC_RbConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serSysEncRLC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysEncRLC_Configuration_Type_Rlc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RLC_Configuration_Type_Rlc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncRLC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncLogicalChannelId_Type_LogicalChannelId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct LogicalChannelId_Type_LogicalChannelId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncNull_Type_LAA_UL_Allowed_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Null_Type_LAA_UL_Allowed_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_LogicalChannelConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_LogicalChannelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->Priority, _lidx);
	{
		size_t _tmp = (size_t)p->PrioritizedBitRate;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncNull_Type_LAA_UL_Allowed_Optional(_buffer, _size, _lidx, &p->LAA_UL_Allowed);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_LogicalChannelConfig_Type_LogicalChannel_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_LogicalChannelConfig_Type_LogicalChannel_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMAC_LogicalChannelConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_Test_DLLogChID_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_Test_DLLogChID_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->LogChId, _lidx);
	HTON_8(&_buffer[*_lidx], p->ConfigLchId, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_TestModeInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMAC_Test_DLLogChID_Type(_buffer, _size, _lidx, &p->DiffLogChId);
	{
		size_t _tmp = (size_t)p->No_HeaderManipulation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_TestModeConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union MAC_TestModeConfig_Type_Value* p, enum MAC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_TestModeConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == MAC_TestModeConfig_Type_Info) {
		_serSysEncMAC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_TestModeConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncMAC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_TestModeConfig_Type_TestMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMAC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncMAC_LogicalChannelConfig_Type_LogicalChannel_Optional(_buffer, _size, _lidx, &p->LogicalChannel);
	_serSysEncMAC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysEncMAC_Configuration_Type_Mac_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct MAC_Configuration_Type_Mac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncMAC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncBool_DiscardULData_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_DiscardULData_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearerConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPDCP_Configuration_Type_Pdcp_Optional(_buffer, _size, _lidx, &p->Pdcp);
	_serSysEncRLC_Configuration_Type_Rlc_Optional(_buffer, _size, _lidx, &p->Rlc);
	_serSysEncLogicalChannelId_Type_LogicalChannelId_Optional(_buffer, _size, _lidx, &p->LogicalChannelId);
	_serSysEncMAC_Configuration_Type_Mac_Optional(_buffer, _size, _lidx, &p->Mac);
	_serSysEncBool_DiscardULData_Optional(_buffer, _size, _lidx, &p->DiscardULData);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearerConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RadioBearerConfig_Type_Value* p, enum RadioBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RadioBearerConfig_Type_AddOrReconfigure) {
		_serSysEncRadioBearerConfigInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
	}
	if (d == RadioBearerConfig_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearerConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRadioBearerConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncRadioBearer_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RadioBearer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRadioBearerId_Type(_buffer, _size, _lidx, &p->Id);
	_serSysEncRadioBearerConfig_Type(_buffer, _size, _lidx, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpSQN_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpSQN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->Value, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_ActTime_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PDCP_ActTime_Type_Value* p, enum PDCP_ActTime_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_ActTime_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
	}
	if (d == PDCP_ActTime_Type_SQN) {
		_serSysEncPdcpSQN_Type(_buffer, _size, _lidx, &p->SQN);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPDCP_ActTime_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PDCP_ActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPDCP_ActTime_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecurityActTime_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecurityActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serSysEncPDCP_ActTime_Type(_buffer, _size, _lidx, &p->UL);
	_serSysEncPDCP_ActTime_Type(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serSysEncSecurityActTimeList_Type_ActTimeList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncSecurityActTime_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_IntegrityInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_IntegrityInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Algorithm;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KRRCint[i1], _lidx);
	}
	_serSysEncSecurityActTimeList_Type_ActTimeList_Optional(_buffer, _size, _lidx, &p->ActTimeList);

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_IntegrityInfo_Type_Integrity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAS_IntegrityInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_CipheringInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_CipheringInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Algorithm;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KRRCenc[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KUPenc[i1], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->ActTimeList.d, _lidx);
	for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
		_serSysEncSecurityActTime_Type(_buffer, _size, _lidx, &p->ActTimeList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_CipheringInfo_Type_Ciphering_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncAS_CipheringInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_SecStartRestart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_SecStartRestart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncAS_IntegrityInfo_Type_Integrity_Optional(_buffer, _size, _lidx, &p->Integrity);
	_serSysEncAS_CipheringInfo_Type_Ciphering_Optional(_buffer, _size, _lidx, &p->Ciphering);

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_Security_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union AS_Security_Type_Value* p, enum AS_Security_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AS_Security_Type_StartRestart) {
		_serSysEncAS_SecStartRestart_Type(_buffer, _size, _lidx, &p->StartRestart);
	}
	if (d == AS_Security_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncAS_Security_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct AS_Security_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncAS_Security_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncS_TMSI(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct S_TMSI* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 8; i2++) {
		HTON_8(&_buffer[*_lidx], p->mmec[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		HTON_8(&_buffer[*_lidx], p->m_TMSI[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingUE_Identity_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PagingUE_Identity_Value* p, enum PagingUE_Identity_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PagingUE_Identity_s_TMSI) {
		_serSysEncS_TMSI(_buffer, _size, _lidx, &p->s_TMSI);
	}
	if (d == PagingUE_Identity_imsi) {
		HTON_32(&_buffer[*_lidx], p->imsi.d, _lidx);
		for (size_t i2 = 0; i2 < p->imsi.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->imsi.v[i2], _lidx);
		}
	}
	if (d == PagingUE_Identity_ng_5G_S_TMSI_r15) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			HTON_8(&_buffer[*_lidx], p->ng_5G_S_TMSI_r15[i2], _lidx);
		}
	}
	if (d == PagingUE_Identity_fullI_RNTI_r15) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			HTON_8(&_buffer[*_lidx], p->fullI_RNTI_r15[i2], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingUE_Identity(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingUE_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPagingUE_Identity_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecord(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecord* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPagingUE_Identity(_buffer, _size, _lidx, &p->ue_Identity);
	{
		size_t _tmp = (size_t)p->cn_Domain;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecordList_Paging_pagingRecordList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecordList_Paging_pagingRecordList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPagingRecord(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_systemInfoModification_e_systemInfoModification_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_systemInfoModification_e_systemInfoModification_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_etws_Indication_e_etws_Indication_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_etws_Indication_e_etws_Indication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1530_IEs_accessType_e_accessType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1530_IEs_accessType_e_accessType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecord_v1610_accessType_r16_e_accessType_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecord_v1610_accessType_r16_e_accessType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecord_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecord_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPagingRecord_v1610_accessType_r16_e_accessType_r16_Optional(_buffer, _size, _lidx, &p->accessType_r16);
	_serSysEncPagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional(_buffer, _size, _lidx, &p->mt_EDT_r16);

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysEncPagingRecord_v1610(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1610_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1610_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(_buffer, _size, _lidx, &p->pagingRecordList_v1610);
	_serSysEncPaging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional(_buffer, _size, _lidx, &p->uac_ParamModification_r16);
	_serSysEncPaging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v1610_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1530_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1530_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPaging_v1530_IEs_accessType_e_accessType_Optional(_buffer, _size, _lidx, &p->accessType);
	_serSysEncPaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v1530_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1310_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1310_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPaging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional(_buffer, _size, _lidx, &p->redistributionIndication_r13);
	_serSysEncPaging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional(_buffer, _size, _lidx, &p->systemInfoModification_eDRX_r13);
	_serSysEncPaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v1310_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1130_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1130_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPaging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional(_buffer, _size, _lidx, &p->eab_ParamModification_r11);
	_serSysEncPaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v1130_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v920_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v920_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPaging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional(_buffer, _size, _lidx, &p->cmas_Indication_r9);
	_serSysEncPaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v920_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v890_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v890_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serSysEncPaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging_v890_IEs_Paging_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging_v890_IEs_Paging_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPaging_v890_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPaging(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Paging* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPagingRecordList_Paging_pagingRecordList_Optional(_buffer, _size, _lidx, &p->pagingRecordList);
	_serSysEncPaging_systemInfoModification_e_systemInfoModification_Optional(_buffer, _size, _lidx, &p->systemInfoModification);
	_serSysEncPaging_etws_Indication_e_etws_Indication_Optional(_buffer, _size, _lidx, &p->etws_Indication);
	_serSysEncPaging_v890_IEs_Paging_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_MessageType_c1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PCCH_MessageType_c1_Value* p, enum PCCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PCCH_MessageType_c1_paging) {
		_serSysEncPaging(_buffer, _size, _lidx, &p->paging);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_MessageType_c1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPCCH_MessageType_c1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_MessageType_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_MessageType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PCCH_MessageType_Value* p, enum PCCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PCCH_MessageType_c1) {
		_serSysEncPCCH_MessageType_c1(_buffer, _size, _lidx, &p->c1);
	}
	if (d == PCCH_MessageType_messageClassExtension) {
		_serSysEncPCCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_MessageType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPCCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPCCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PCCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPCCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysEncSubframeOffsetList_Type_SubframeOffsetList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPagingTrigger_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PagingTrigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncPCCH_Message(_buffer, _size, _lidx, &p->Paging);
	_serSysEncSubframeOffsetList_Type_SubframeOffsetList_Optional(_buffer, _size, _lidx, &p->SubframeOffsetList);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCountGetReq_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union PdcpCountGetReq_Type_Value* p, enum PdcpCountGetReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PdcpCountGetReq_Type_AllRBs) {
		HTON_8(&_buffer[*_lidx], p->AllRBs, _lidx);
	}
	if (d == PdcpCountGetReq_Type_SingleRB) {
		_serSysEncRadioBearerId_Type(_buffer, _size, _lidx, &p->SingleRB);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCountGetReq_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpCountGetReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPdcpCountGetReq_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCount_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpCount_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCount_Type_UL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpCount_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCount_Type_DL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpCount_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysEncPdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcpCountInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PdcpCountInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncRadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serSysEncPdcpCount_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serSysEncPdcpCount_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcp_CountReq_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Pdcp_CountReq_Type_Value* p, enum Pdcp_CountReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pdcp_CountReq_Type_Get) {
		_serSysEncPdcpCountGetReq_Type(_buffer, _size, _lidx, &p->Get);
	}
	if (d == Pdcp_CountReq_Type_Set) {
		HTON_32(&_buffer[*_lidx], p->Set.d, _lidx);
		for (size_t i1 = 0; i1 < p->Set.d; i1++) {
			_serSysEncPdcpCountInfo_Type(_buffer, _size, _lidx, &p->Set.v[i1]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcp_CountReq_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Pdcp_CountReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPdcp_CountReq_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_Category_v1020_Type_ue_Category_V1020_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_Category_v1020_Type_ue_Category_V1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_Category_v1170_Type_ue_Category_v1170_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_Category_v1170_Type_ue_Category_v1170_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_Category_v11a0_Type_ue_Category_v11a0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_Category_v11a0_Type_ue_Category_v11a0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_Category_v1250_Type_ue_Category_v1250_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_Category_v1250_Type_ue_Category_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysEncUE_CategoryInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_CategoryInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ue_Category, _lidx);
	_serSysEncUE_Category_v1020_Type_ue_Category_V1020_Optional(_buffer, _size, _lidx, &p->ue_Category_V1020);
	_serSysEncUE_Category_v1170_Type_ue_Category_v1170_Optional(_buffer, _size, _lidx, &p->ue_Category_v1170);
	_serSysEncUE_Category_v11a0_Type_ue_Category_v11a0_Optional(_buffer, _size, _lidx, &p->ue_Category_v11a0);
	_serSysEncUE_Category_v1250_Type_ue_Category_v1250_Optional(_buffer, _size, _lidx, &p->ue_Category_v1250);
	_serSysEncUE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_r12);
	_serSysEncUE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1260);
	_serSysEncUE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1310);
	_serSysEncUE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1330);
	_serSysEncUE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1350);
	_serSysEncUE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1460);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemRequest_Type_Value* p, enum SystemRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemRequest_Type_Cell) {
		_serSysEncCellConfigRequest_Type(_buffer, _size, _lidx, &p->Cell);
	}
	if (d == SystemRequest_Type_CellAttenuationList) {
		HTON_32(&_buffer[*_lidx], p->CellAttenuationList.d, _lidx);
		for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			_serSysEncCellAttenuationConfig_Type(_buffer, _size, _lidx, &p->CellAttenuationList.v[i1]);
		}
	}
	if (d == SystemRequest_Type_RadioBearerList) {
		HTON_32(&_buffer[*_lidx], p->RadioBearerList.d, _lidx);
		for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
			_serSysEncRadioBearer_Type(_buffer, _size, _lidx, &p->RadioBearerList.v[i1]);
		}
	}
	if (d == SystemRequest_Type_EnquireTiming) {
		HTON_8(&_buffer[*_lidx], p->EnquireTiming, _lidx);
	}
	if (d == SystemRequest_Type_AS_Security) {
		_serSysEncAS_Security_Type(_buffer, _size, _lidx, &p->AS_Security);
	}
	if (d == SystemRequest_Type_Paging) {
		_serSysEncPagingTrigger_Type(_buffer, _size, _lidx, &p->Paging);
	}
	if (d == SystemRequest_Type_PdcpCount) {
		_serSysEncPdcp_CountReq_Type(_buffer, _size, _lidx, &p->PdcpCount);
	}
	if (d == SystemRequest_Type_UE_Cat_Info) {
		_serSysEncUE_CategoryInfo_Type(_buffer, _size, _lidx, &p->UE_Cat_Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSYSTEM_CTRL_REQ(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SYSTEM_CTRL_REQ* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncReqAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serSysEncSystemRequest_Type(_buffer, _size, _lidx, &p->Request);

	return SIDL_STATUS_OK;
}

int serSysProcessEncClt(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SYSTEM_CTRL_REQ* FromSS)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSYSTEM_CTRL_REQ(_buffer, _size, _lidx, FromSS);

	return SIDL_STATUS_OK;
}

static int _serSysDecPmchLogicalChannel_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PmchLogicalChannel_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->Pmch_InfoIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->LogicalChannelIdentity, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMRB_Identity_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MRB_Identity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->Mbsfn_AreaId, &_buffer[*_lidx], _lidx);
	_serSysDecPmchLogicalChannel_Type(_buffer, _size, _lidx, &p->PmchLogicalChannel);

	return SIDL_STATUS_OK;
}

static int _serSysDecMCC_PLMN_Identity_mcc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MCC_PLMN_Identity_mcc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_Identity(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMCC_PLMN_Identity_mcc_Optional(_buffer, _size, _lidx, &p->mcc);
	NTOH_32(p->mnc.d, &_buffer[*_lidx], _lidx);
	p->mnc.v = serMalloc(_mem, p->mnc.d * sizeof(MCC_MNC_Digit));
	for (size_t i1 = 0; i1 < p->mnc.d; i1++) {
		NTOH_8(p->mnc.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTMGI_r9_plmn_Id_r9_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union TMGI_r9_plmn_Id_r9_Value* p, enum TMGI_r9_plmn_Id_r9_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TMGI_r9_plmn_Id_r9_plmn_Index_r9) {
		NTOH_8(p->plmn_Index_r9, &_buffer[*_lidx], _lidx);
	}
	if (d == TMGI_r9_plmn_Id_r9_explicitValue_r9) {
		_serSysDecPLMN_Identity(_buffer, _size, _lidx, _mem, &p->explicitValue_r9);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTMGI_r9_plmn_Id_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct TMGI_r9_plmn_Id_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TMGI_r9_plmn_Id_r9_Sel)_tmp;
	}
	_serSysDecTMGI_r9_plmn_Id_r9_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecTMGI_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct TMGI_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTMGI_r9_plmn_Id_r9(_buffer, _size, _lidx, _mem, &p->plmn_Id_r9);
	for (size_t i1 = 0; i1 < 3; i1++) {
		NTOH_8(p->serviceId_r9[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecO1_MBMSSessionInfo_r13_sessionId_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O1_MBMSSessionInfo_r13_sessionId_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMSSessionInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMSSessionInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTMGI_r9(_buffer, _size, _lidx, _mem, &p->tmgi_r13);
	_serSysDecO1_MBMSSessionInfo_r13_sessionId_r13_Optional(_buffer, _size, _lidx, &p->sessionId_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSC_MRB_Identity_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SC_MRB_Identity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMBMSSessionInfo_r13(_buffer, _size, _lidx, _mem, &p->MbmsSessionInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearerId_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union RadioBearerId_Type_Value* p, enum RadioBearerId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RadioBearerId_Type_Srb) {
		NTOH_8(p->Srb, &_buffer[*_lidx], _lidx);
	}
	if (d == RadioBearerId_Type_Drb) {
		NTOH_8(p->Drb, &_buffer[*_lidx], _lidx);
	}
	if (d == RadioBearerId_Type_Mrb) {
		_serSysDecMRB_Identity_Type(_buffer, _size, _lidx, &p->Mrb);
	}
	if (d == RadioBearerId_Type_ScMrb) {
		_serSysDecSC_MRB_Identity_Type(_buffer, _size, _lidx, _mem, &p->ScMrb);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearerId_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RadioBearerId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RadioBearerId_Type_Sel)_tmp;
	}
	_serSysDecRadioBearerId_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecQosFlow_Identification_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct QosFlow_Identification_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->PDU_SessionId, &_buffer[*_lidx], _lidx);
	NTOH_32(p->QFI, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRoutingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union RoutingInfo_Type_Value* p, enum RoutingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RoutingInfo_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == RoutingInfo_Type_RadioBearerId) {
		_serSysDecRadioBearerId_Type(_buffer, _size, _lidx, _mem, &p->RadioBearerId);
	}
	if (d == RoutingInfo_Type_QosFlow) {
		_serSysDecQosFlow_Identification_Type(_buffer, _size, _lidx, &p->QosFlow);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRoutingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RoutingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RoutingInfo_Type_Sel)_tmp;
	}
	_serSysDecRoutingInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemFrameNumberInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemFrameNumberInfo_Type_Value* p, enum SystemFrameNumberInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemFrameNumberInfo_Type_Number) {
		NTOH_16(p->Number, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemFrameNumberInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemFrameNumberInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemFrameNumberInfo_Type_Sel)_tmp;
	}
	_serSysDecSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSubFrameInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SubFrameInfo_Type_Value* p, enum SubFrameInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubFrameInfo_Type_Number) {
		NTOH_8(p->Number, &_buffer[*_lidx], _lidx);
	}
	if (d == SubFrameInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSubFrameInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubFrameInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SubFrameInfo_Type_Sel)_tmp;
	}
	_serSysDecSubFrameInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecHyperSystemFrameNumberInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, HyperSystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemFrameNumberInfo_Type_Sel)_tmp;
	}
	_serSysDecSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSlotOffset_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SlotOffset_Type_Value* p, enum SlotOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotOffset_Type_Numerology0) {
		NTOH_8(p->Numerology0, &_buffer[*_lidx], _lidx);
	}
	if (d == SlotOffset_Type_Numerology1) {
		NTOH_8(p->Numerology1, &_buffer[*_lidx], _lidx);
	}
	if (d == SlotOffset_Type_Numerology2) {
		NTOH_8(p->Numerology2, &_buffer[*_lidx], _lidx);
	}
	if (d == SlotOffset_Type_Numerology3) {
		NTOH_8(p->Numerology3, &_buffer[*_lidx], _lidx);
	}
	if (d == SlotOffset_Type_Numerology4) {
		NTOH_8(p->Numerology4, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSlotOffset_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SlotOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SlotOffset_Type_Sel)_tmp;
	}
	_serSysDecSlotOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSlotTimingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SlotTimingInfo_Type_Value* p, enum SlotTimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotTimingInfo_Type_SlotOffset) {
		_serSysDecSlotOffset_Type(_buffer, _size, _lidx, &p->SlotOffset);
	}
	if (d == SlotTimingInfo_Type_FirstSlot) {
		NTOH_8(p->FirstSlot, &_buffer[*_lidx], _lidx);
	}
	if (d == SlotTimingInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSlotTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SlotTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SlotTimingInfo_Type_Sel)_tmp;
	}
	_serSysDecSlotTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSubFrameTiming_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubFrameTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->SFN);
	_serSysDecSubFrameInfo_Type(_buffer, _size, _lidx, &p->Subframe);
	_serSysDecHyperSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->HSFN);
	_serSysDecSlotTimingInfo_Type(_buffer, _size, _lidx, &p->Slot);

	return SIDL_STATUS_OK;
}

static int _serSysDecTimingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TimingInfo_Type_Value* p, enum TimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TimingInfo_Type_SubFrame) {
		_serSysDecSubFrameTiming_Type(_buffer, _size, _lidx, &p->SubFrame);
	}
	if (d == TimingInfo_Type_Now) {
		NTOH_8(p->Now, &_buffer[*_lidx], _lidx);
	}
	if (d == TimingInfo_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TimingInfo_Type_Sel)_tmp;
	}
	_serSysDecTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecReqAspControlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReqAspControlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->CnfFlag, &_buffer[*_lidx], _lidx);
	NTOH_8(p->FollowOnFlag, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRlcBearerRouting_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RlcBearerRouting_Type_Value* p, enum RlcBearerRouting_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RlcBearerRouting_Type_EUTRA) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->EUTRA = (EUTRA_CellId_Type)_tmp;
		}
	}
	if (d == RlcBearerRouting_Type_NR) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->NR = (NR_CellId_Type)_tmp;
		}
	}
	if (d == RlcBearerRouting_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRlcBearerRouting_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RlcBearerRouting_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RlcBearerRouting_Type_Sel)_tmp;
	}
	_serSysDecRlcBearerRouting_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRlcBearerRouting_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecReqAspCommonPart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ReqAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (EUTRA_CellId_Type)_tmp;
	}
	_serSysDecRoutingInfo_Type(_buffer, _size, _lidx, _mem, &p->RoutingInfo);
	_serSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serSysDecReqAspControlInfo_Type(_buffer, _size, _lidx, &p->ControlInfo);
	_serSysDecRlcBearerRouting_Type_ReqAspCommonPart_Type_RlcBearerRouting_Optional(_buffer, _size, _lidx, &p->RlcBearerRouting);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellConfigCapability_Type_ConfigCapability_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellConfigCapability_Type_ConfigCapability_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CellConfigCapability_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subframeAssignment = (TDD_Config_subframeAssignment_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->specialSubframePatterns = (TDD_Config_specialSubframePatterns_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->specialSubframePatterns_v1130 = (TDD_Config_v1130_specialSubframePatterns_v1130_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1130_tdd_Config_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1130_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->R8);
	_serSysDecTDD_Config_v1130_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TDD_Config_Type_Value* p, enum TDD_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TDD_Config_Type_R8andLater) {
		_serSysDecTDD_Config_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TDD_Config_Type_Sel)_tmp;
	}
	_serSysDecTDD_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEUTRA_TDD_Info_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EUTRA_TDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_Type(_buffer, _size, _lidx, &p->Configuration);

	return SIDL_STATUS_OK;
}

static int _serSysDecEUTRA_HalfDuplexFDD_Info_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EUTRA_HalfDuplexFDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecEUTRA_RAT_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EUTRA_RAT_Type_Value* p, enum EUTRA_RAT_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EUTRA_RAT_Type_FDD) {
		NTOH_8(p->FDD, &_buffer[*_lidx], _lidx);
	}
	if (d == EUTRA_RAT_Type_TDD) {
		_serSysDecEUTRA_TDD_Info_Type(_buffer, _size, _lidx, &p->TDD);
	}
	if (d == EUTRA_RAT_Type_HalfDuplexFDD) {
		_serSysDecEUTRA_HalfDuplexFDD_Info_Type(_buffer, _size, _lidx, &p->HalfDuplexFDD);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEUTRA_RAT_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EUTRA_RAT_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EUTRA_RAT_Type_Sel)_tmp;
	}
	_serSysDecEUTRA_RAT_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellIdentity_eNB_CellId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellIdentity_eNB_CellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 28; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_TcOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_TcOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint8_t_TcOffset_Optional(_buffer, _size, _lidx, &p->TcOffset);
	NTOH_32(p->Tcell, &_buffer[*_lidx], _lidx);
	NTOH_16(p->SfnOffset, &_buffer[*_lidx], _lidx);
	NTOH_16(p->HsfnOffset, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCommonStaticCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CommonStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEUTRA_RAT_Type(_buffer, _size, _lidx, &p->RAT);
	NTOH_16(p->PhysicalCellId, &_buffer[*_lidx], _lidx);
	_serSysDecCellIdentity_eNB_CellId_Optional(_buffer, _size, _lidx, &p->eNB_CellId);
	NTOH_32(p->EutraBand, &_buffer[*_lidx], _lidx);
	_serSysDecCellTimingInfo_Type(_buffer, _size, _lidx, &p->CellTimingInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecDownlinkStaticCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DownlinkStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->Earfcn, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Bandwidth = (Dl_Bandwidth_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->RBSize = (EUTRA_RBSize_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CyclicPrefix = (EUTRA_CyclicPrefix_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkStaticCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkStaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->Earfcn, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Bandwidth = (Ul_Bandwidth_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CyclicPrefix = (EUTRA_CyclicPrefix_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkStaticCellInfo_Type_Uplink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkStaticCellInfo_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkStaticCellInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecStaticCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct StaticCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCommonStaticCellInfo_Type(_buffer, _size, _lidx, &p->Common);
	_serSysDecDownlinkStaticCellInfo_Type(_buffer, _size, _lidx, &p->Downlink);
	_serSysDecUplinkStaticCellInfo_Type_Uplink_Optional(_buffer, _size, _lidx, &p->Uplink);

	return SIDL_STATUS_OK;
}

static int _serSysDecStaticCellInfo_Type_StaticCellInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct StaticCellInfo_Type_StaticCellInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecStaticCellInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->antennaPortsCount = (AntennaInfoCommon_antennaPortsCount_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaInfoCommon_Type_Value* p, enum AntennaInfoCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoCommon_Type_R8) {
		_serSysDecAntennaInfoCommon(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoCommon_Type_Sel)_tmp;
	}
	_serSysDecAntennaInfoCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaPortInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaPortInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->PowerAttenuation, &_buffer[*_lidx], _lidx);
	NTOH_8(p->PropagationDelay, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaPortConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaPortConfig_Type_Value* p, enum AntennaPortConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaPortConfig_Type_AddOrReconfigure) {
		_serSysDecAntennaPortInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
	}
	if (d == AntennaPortConfig_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaPortConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaPortConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaPortConfig_Type_Sel)_tmp;
	}
	_serSysDecAntennaPortConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaPort_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaPort_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->Id, &_buffer[*_lidx], _lidx);
	_serSysDecAntennaPortConfig_Type(_buffer, _size, _lidx, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serSysDecDownlinkAntennaGroupConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DownlinkAntennaGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoCommon_Type(_buffer, _size, _lidx, &p->AntennaInfoCommon);
	NTOH_32(p->AntennaPort.d, &_buffer[*_lidx], _lidx);
	p->AntennaPort.v = serMalloc(_mem, p->AntennaPort.d * sizeof(struct AntennaPort_Type));
	for (size_t i1 = 0; i1 < p->AntennaPort.d; i1++) {
		_serSysDecAntennaPort_Type(_buffer, _size, _lidx, &p->AntennaPort.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DownlinkAntennaGroupConfig_Type_AntennaGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDownlinkAntennaGroupConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratio_Type_RA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratio_Type_RA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratio_Type_RB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratio_Type_RB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratio_Type_RA_Optional(_buffer, _size, _lidx, &p->RA);
	_serSysDecToRS_EPRE_Ratio_Type_RB_Optional(_buffer, _size, _lidx, &p->RB);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPbchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PbchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_PbchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPbchConfig_Type_Pbch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPbchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCfiValue_Type_CfiValue_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CfiValue_Type_CfiValue_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcfichConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PcfichConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCfiValue_Type_CfiValue_Optional(_buffer, _size, _lidx, &p->CfiValue);
	_serSysDecToRS_EPRE_Ratios_Type_PcfichConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcfichConfig_Type_Pcfich_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PcfichConfig_Type_Pcfich_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPcfichConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPHICH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PHICH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phich_Duration = (PHICH_Config_phich_Duration_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phich_Resource = (PHICH_Config_phich_Resource_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPHICH_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PHICH_Config_Type_Value* p, enum PHICH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PHICH_Config_Type_R8) {
		_serSysDecPHICH_Config(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPHICH_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PHICH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PHICH_Config_Type_Sel)_tmp;
	}
	_serSysDecPHICH_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPHICH_Config_Type_PhichConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PHICH_Config_Type_PhichConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPHICH_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhichConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhichConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPHICH_Config_Type_PhichConfig_Optional(_buffer, _size, _lidx, &p->PhichConfig);
	_serSysDecToRS_EPRE_Ratios_Type_PhichConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhichConfig_Type_Phich_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhichConfig_Type_Phich_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPhichConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_CommonSearchSpaceFormat_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_CommonSearchSpaceFormat_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_UeSpecificSearchSpaceFormat_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_UeSpecificSearchSpaceFormat_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCCE_StartIndex_DL_UL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CCE_StartIndex_DL_UL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->CCE_StartIndex_DL, &_buffer[*_lidx], _lidx);
	NTOH_32(p->CCE_StartIndex_UL, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchCandidate_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcchCandidate_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->RNTI[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->CCE_StartIndexList.d, &_buffer[*_lidx], _lidx);
	p->CCE_StartIndexList.v = serMalloc(_mem, p->CCE_StartIndexList.d * sizeof(struct CCE_StartIndex_DL_UL_Type));
	for (size_t i2 = 0; i2 < p->CCE_StartIndexList.d; i2++) {
		_serSysDecCCE_StartIndex_DL_UL_Type(_buffer, _size, _lidx, &p->CCE_StartIndexList.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchCandidateList_Type_PdcchCandidateList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcchCandidateList_Type_PdcchCandidateList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PdcchCandidate_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPdcchCandidate_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint8_t_CommonSearchSpaceFormat_Optional(_buffer, _size, _lidx, &p->CommonSearchSpaceFormat);
	_serSysDecUint8_t_UeSpecificSearchSpaceFormat_Optional(_buffer, _size, _lidx, &p->UeSpecificSearchSpaceFormat);
	_serSysDecPdcchCandidateList_Type_PdcchCandidateList_Optional(_buffer, _size, _lidx, _mem, &p->PdcchCandidateList);
	_serSysDecToRS_EPRE_Ratios_Type_PdcchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchConfig_Type_Pdcch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcchConfig_Type_Pdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPdcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_RachResponse_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_RachResponse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdschRelativeTxPower_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdschRelativeTxPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_RachResponse_Optional(_buffer, _size, _lidx, &p->RachResponse);
	_serSysDecToRS_EPRE_Ratios_Type_BcchOnPdsch_Optional(_buffer, _size, _lidx, &p->BcchOnPdsch);
	_serSysDecToRS_EPRE_Ratios_Type_PcchOnPdsch_Optional(_buffer, _size, _lidx, &p->PcchOnPdsch);
	_serSysDecToRS_EPRE_Ratios_Type_CcchOnPdsch_Optional(_buffer, _size, _lidx, &p->CcchOnPdsch);
	_serSysDecToRS_EPRE_Ratios_Type_DcchDtchOnPdsch_Optional(_buffer, _size, _lidx, &p->DcchDtchOnPdsch);
	_serSysDecToRS_EPRE_Ratios_Type_OcngOnPdsch_Optional(_buffer, _size, _lidx, &p->OcngOnPdsch);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdschRelativeTxPower_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdschRelativeTxPower_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPdschRelativeTxPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeA_r13_e_pdsch_maxNumRepetitionCEmodeA_r13_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeA_r13);
	_serSysDecPDSCH_ConfigCommon_v1310_pdsch_maxNumRepetitionCEmodeB_r13_e_pdsch_maxNumRepetitionCEmodeB_r13_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeB_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdschConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPdschRelativeTxPower_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serSysDecPDSCH_ConfigCommon_v1310_PDSCH_ConfigCommon_Optional(_buffer, _size, _lidx, &p->PDSCH_ConfigCommon);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdschConfig_Type_Pdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPdschConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPrimarySyncSignal_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PrimarySyncSignal_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_PrimarySyncSignal_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPrimarySyncSignal_Type_Pss_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PrimarySyncSignal_Type_Pss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPrimarySyncSignal_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecondarySyncSignal_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SecondarySyncSignal_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_SecondarySyncSignal_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecondarySyncSignal_Type_Sss_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SecondarySyncSignal_Type_Sss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSecondarySyncSignal_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10_csi_RS_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_r10_csi_RS_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->antennaPortsCount_r10 = (CSI_RS_Config_r10_csi_RS_r10_setup_antennaPortsCount_r10_e)_tmp;
	}
	NTOH_8(p->resourceConfig_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeConfig_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_C_r10, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10_csi_RS_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CSI_RS_Config_r10_csi_RS_r10_Value* p, enum CSI_RS_Config_r10_csi_RS_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_Config_r10_csi_RS_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_Config_r10_csi_RS_r10_setup) {
		_serSysDecCSI_RS_Config_r10_csi_RS_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10_csi_RS_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_r10_csi_RS_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_Config_r10_csi_RS_r10_Sel)_tmp;
	}
	_serSysDecCSI_RS_Config_r10_csi_RS_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_Config_r10_csi_RS_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecZeroTxPowerCSI_RS_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ZeroTxPowerCSI_RS_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->zeroTxPowerResourceConfigList_r12[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->zeroTxPowerSubframeConfig_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecZeroTxPowerCSI_RS_Conf_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ZeroTxPowerCSI_RS_Conf_r12_Value* p, enum ZeroTxPowerCSI_RS_Conf_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ZeroTxPowerCSI_RS_Conf_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == ZeroTxPowerCSI_RS_Conf_r12_setup) {
		_serSysDecZeroTxPowerCSI_RS_r12(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecZeroTxPowerCSI_RS_Conf_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ZeroTxPowerCSI_RS_Conf_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ZeroTxPowerCSI_RS_Conf_r12_Sel)_tmp;
	}
	_serSysDecZeroTxPowerCSI_RS_Conf_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecZeroTxPowerCSI_RS_Conf_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_Config_r10_csi_RS_r10_csi_RS_r10_Optional(_buffer, _size, _lidx, &p->csi_RS_r10);
	_serSysDecZeroTxPowerCSI_RS_Conf_r12_CSI_RS_Config_r10_zeroTxPowerCSI_RS_r10_Optional(_buffer, _size, _lidx, &p->zeroTxPowerCSI_RS_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_r10_CSI_RS_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_r10_CSI_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_Config_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig_subframeAllocation_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MBSFN_SubframeConfig_subframeAllocation_Value* p, enum MBSFN_SubframeConfig_subframeAllocation_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MBSFN_SubframeConfig_subframeAllocation_oneFrame) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			NTOH_8(p->oneFrame[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MBSFN_SubframeConfig_subframeAllocation_fourFrames) {
		for (size_t i3 = 0; i3 < 24; i3++) {
			NTOH_8(p->fourFrames[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig_subframeAllocation(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_SubframeConfig_subframeAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MBSFN_SubframeConfig_subframeAllocation_Sel)_tmp;
	}
	_serSysDecMBSFN_SubframeConfig_subframeAllocation_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_SubframeConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->radioframeAllocationPeriod = (MBSFN_SubframeConfig_radioframeAllocationPeriod_e)_tmp;
	}
	NTOH_8(p->radioframeAllocationOffset, &_buffer[*_lidx], _lidx);
	_serSysDecMBSFN_SubframeConfig_subframeAllocation(_buffer, _size, _lidx, &p->subframeAllocation);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->subframeConfigList.d, &_buffer[*_lidx], _lidx);
	p->subframeConfigList.v = serMalloc(_mem, p->subframeConfigList.d * sizeof(struct MBSFN_SubframeConfig));
	for (size_t i2 = 0; i2 < p->subframeConfigList.d; i2++) {
		_serSysDecMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->subframeConfigList.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value* p, enum CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup) {
		_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->qcl_ScramblingIdentity_r11, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->crs_PortsCount_r11 = (CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_crs_PortsCount_r11_e)_tmp;
	}
	_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NZP_FrequencyDensity_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value* p, enum MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_oneFrame_v1430) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			NTOH_8(p->oneFrame_v1430[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_fourFrames_v1430) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			NTOH_8(p->fourFrames_v1430[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig_v1430_subframeAllocation_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_SubframeConfig_v1430_subframeAllocation_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Sel)_tmp;
	}
	_serSysDecMBSFN_SubframeConfig_v1430_subframeAllocation_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfig_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_SubframeConfig_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMBSFN_SubframeConfig_v1430_subframeAllocation_v1430(_buffer, _size, _lidx, &p->subframeAllocation_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->subframeConfigList_v1430.d, &_buffer[*_lidx], _lidx);
	p->subframeConfigList_v1430.v = serMalloc(_mem, p->subframeConfigList_v1430.d * sizeof(struct MBSFN_SubframeConfig_v1430));
	for (size_t i2 = 0; i2 < p->subframeConfigList_v1430.d; i2++) {
		_serSysDecMBSFN_SubframeConfig_v1430(_buffer, _size, _lidx, &p->subframeConfigList_v1430.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value* p, enum CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup) {
		_serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_RS_ConfigNZPId_r11, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->antennaPortsCount_r11 = (CSI_RS_ConfigNZP_r11_antennaPortsCount_r11_e)_tmp;
	}
	NTOH_8(p->resourceConfig_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeConfig_r11, &_buffer[*_lidx], _lidx);
	NTOH_16(p->scramblingIdentity_r11, &_buffer[*_lidx], _lidx);
	_serSysDecCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(_buffer, _size, _lidx, _mem, &p->qcl_CRS_Info_r11);
	_serSysDecCSI_RS_ConfigNZPId_v1310_CSI_RS_ConfigNZP_r11_csi_RS_ConfigNZPId_v1310_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigNZPId_v1310);
	_serSysDecNZP_TransmissionComb_r14_CSI_RS_ConfigNZP_r11_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysDecNZP_FrequencyDensity_r14_e_CSI_RS_ConfigNZP_r11_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);
	_serSysDecCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_RS_ConfigNZP_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_RS_ConfigNZPId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigZP_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigZP_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_RS_ConfigZPId_r11, &_buffer[*_lidx], _lidx);
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->resourceConfigList_r11[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->subframeConfig_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_RS_ConfigZP_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCSI_RS_ConfigZP_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_RS_ConfigZPId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_Config_r10_CSI_RS_Config_Optional(_buffer, _size, _lidx, &p->CSI_RS_Config);
	_serSysDecCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(_buffer, _size, _lidx, _mem, &p->CSI_RS_ConfigNZPToAddModList);
	_serSysDecCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(_buffer, _size, _lidx, _mem, &p->CSI_RS_ConfigNZPToReleaseModList);
	_serSysDecCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(_buffer, _size, _lidx, _mem, &p->CSI_RS_ConfigZPToAddModList);
	_serSysDecCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(_buffer, _size, _lidx, _mem, &p->CSI_RS_ConfigZPToReleaseModList);
	_serSysDecToRS_EPRE_Ratios_Type_CSI_RS_Config_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_Type_CSI_RS_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_Config_Type_CSI_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPmchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PmchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_PmchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serSysDecPmchConfig_Type_Pmch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PmchConfig_Type_Pmch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPmchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecToRS_EPRE_Ratios_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchCandidateList_Type_ePdcchCandidateList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcchCandidateList_Type_ePdcchCandidateList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PdcchCandidate_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPdcchCandidate_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePattern_r10_subframePatternTDD_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasSubframePattern_r10_subframePatternTDD_r10_Value* p, enum MeasSubframePattern_r10_subframePatternTDD_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig1_5_r10) {
		for (size_t i1 = 0; i1 < 20; i1++) {
			NTOH_8(p->subframeConfig1_5_r10[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig0_r10) {
		for (size_t i1 = 0; i1 < 70; i1++) {
			NTOH_8(p->subframeConfig0_r10[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10_subframeConfig6_r10) {
		for (size_t i1 = 0; i1 < 60; i1++) {
			NTOH_8(p->subframeConfig6_r10[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePattern_r10_subframePatternTDD_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasSubframePattern_r10_subframePatternTDD_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasSubframePattern_r10_subframePatternTDD_r10_Sel)_tmp;
	}
	_serSysDecMeasSubframePattern_r10_subframePatternTDD_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePattern_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasSubframePattern_r10_Value* p, enum MeasSubframePattern_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePattern_r10_subframePatternFDD_r10) {
		for (size_t i1 = 0; i1 < 40; i1++) {
			NTOH_8(p->subframePatternFDD_r10[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MeasSubframePattern_r10_subframePatternTDD_r10) {
		_serSysDecMeasSubframePattern_r10_subframePatternTDD_r10(_buffer, _size, _lidx, &p->subframePatternTDD_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePattern_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasSubframePattern_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasSubframePattern_r10_Sel)_tmp;
	}
	_serSysDecMeasSubframePattern_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMeasSubframePattern_r10(_buffer, _size, _lidx, &p->subframePattern_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value* p, enum EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup) {
		_serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Sel)_tmp;
	}
	_serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(EPDCCH_SetConfigId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_SetConfig_r11_resourceBlockAssignment_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numberPRB_Pairs_r11 = (EPDCCH_SetConfig_r11_resourceBlockAssignment_r11_numberPRB_Pairs_r11_e)_tmp;
	}
	NTOH_32(p->resourceBlockAssignment_r11.d, &_buffer[*_lidx], _lidx);
	p->resourceBlockAssignment_r11.v = serMalloc(_mem, p->resourceBlockAssignment_r11.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->resourceBlockAssignment_r11.d; i2++) {
		NTOH_8(p->resourceBlockAssignment_r11.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value* p, enum EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Sel)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value* p, enum EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Sel)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value* p, enum EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_fdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->fdd_r13 = (EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_fdd_r13_e)_tmp;
		}
	}
	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_tdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->tdd_r13 = (EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_tdd_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Sel)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_mpdcch_config_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->csi_NumRepetitionCE_r13 = (EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_csi_NumRepetitionCE_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_pdsch_HoppingConfig_r13 = (EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_pdsch_HoppingConfig_r13_e)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_StartSF_UESS_r13(_buffer, _size, _lidx, &p->mpdcch_StartSF_UESS_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_NumRepetition_r13 = (EPDCCH_SetConfig_r11_mpdcch_config_r13_setup_mpdcch_NumRepetition_r13_e)_tmp;
	}
	NTOH_8(p->mpdcch_Narrowband_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EPDCCH_SetConfig_r11_mpdcch_config_r13_Value* p, enum EPDCCH_SetConfig_r11_mpdcch_config_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EPDCCH_SetConfig_r11_mpdcch_config_r13_setup) {
		_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_mpdcch_config_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_SetConfig_r11_mpdcch_config_r13_Sel)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfig_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_SetConfig_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->setConfigId_r11, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->transmissionType_r11 = (EPDCCH_SetConfig_r11_transmissionType_r11_e)_tmp;
	}
	_serSysDecEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(_buffer, _size, _lidx, _mem, &p->resourceBlockAssignment_r11);
	NTOH_16(p->dmrs_ScramblingSequenceInt_r11, &_buffer[*_lidx], _lidx);
	NTOH_16(p->pucch_ResourceStartOffset_r11, &_buffer[*_lidx], _lidx);
	_serSysDecPDSCH_RE_MappingQCL_ConfigId_r11_EPDCCH_SetConfig_r11_re_MappingQCL_ConfigId_r11_Optional(_buffer, _size, _lidx, &p->re_MappingQCL_ConfigId_r11);
	_serSysDecEPDCCH_SetConfig_r11_csi_RS_ConfigZPId2_r12_csi_RS_ConfigZPId2_r12_Optional(_buffer, _size, _lidx, &p->csi_RS_ConfigZPId2_r12);
	_serSysDecEPDCCH_SetConfig_r11_numberPRB_Pairs_v1310_numberPRB_Pairs_v1310_Optional(_buffer, _size, _lidx, &p->numberPRB_Pairs_v1310);
	_serSysDecEPDCCH_SetConfig_r11_mpdcch_config_r13_mpdcch_config_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_config_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct EPDCCH_SetConfig_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecEPDCCH_SetConfig_r11(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_Config_r11_config_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEPDCCH_Config_r11_config_r11_setup_subframePatternConfig_r11_subframePatternConfig_r11_Optional(_buffer, _size, _lidx, &p->subframePatternConfig_r11);
	_serSysDecUint8_t_EPDCCH_Config_r11_config_r11_setup_startSymbol_r11_Optional(_buffer, _size, _lidx, &p->startSymbol_r11);
	_serSysDecEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(_buffer, _size, _lidx, _mem, &p->setConfigToReleaseList_r11);
	_serSysDecEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(_buffer, _size, _lidx, _mem, &p->setConfigToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union EPDCCH_Config_r11_config_r11_Value* p, enum EPDCCH_Config_r11_config_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EPDCCH_Config_r11_config_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EPDCCH_Config_r11_config_r11_setup) {
		_serSysDecEPDCCH_Config_r11_config_r11_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_config_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_Config_r11_config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EPDCCH_Config_r11_config_r11_Sel)_tmp;
	}
	_serSysDecEPDCCH_Config_r11_config_r11_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEPDCCH_Config_r11_config_r11(_buffer, _size, _lidx, _mem, &p->config_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecEPDCCH_Config_r11_EPDCCH_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EPDCCH_Config_r11_EPDCCH_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEPDCCH_Config_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy_e_dummy_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_dummy_e_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (FreqHoppingParameters_r13_dummy_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy2_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union FreqHoppingParameters_r13_dummy2_Value* p, enum FreqHoppingParameters_r13_dummy2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_dummy2_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (FreqHoppingParameters_r13_dummy2_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == FreqHoppingParameters_r13_dummy2_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (FreqHoppingParameters_r13_dummy2_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_dummy2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum FreqHoppingParameters_r13_dummy2_Sel)_tmp;
	}
	_serSysDecFreqHoppingParameters_r13_dummy2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy2_dummy2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_dummy2_dummy2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13_dummy2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy3_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union FreqHoppingParameters_r13_dummy3_Value* p, enum FreqHoppingParameters_r13_dummy3_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_dummy3_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (FreqHoppingParameters_r13_dummy3_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == FreqHoppingParameters_r13_dummy3_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (FreqHoppingParameters_r13_dummy3_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy3(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_dummy3* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum FreqHoppingParameters_r13_dummy3_Sel)_tmp;
	}
	_serSysDecFreqHoppingParameters_r13_dummy3_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_dummy3_dummy3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_dummy3_dummy3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13_dummy3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value* p, enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Sel)_tmp;
	}
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value* p, enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Sel)_tmp;
	}
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_FreqHoppingParameters_r13_dummy4_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_FreqHoppingParameters_r13_dummy4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecFreqHoppingParameters_r13_dummy_e_dummy_Optional(_buffer, _size, _lidx, &p->dummy);
	_serSysDecFreqHoppingParameters_r13_dummy2_dummy2_Optional(_buffer, _size, _lidx, &p->dummy2);
	_serSysDecFreqHoppingParameters_r13_dummy3_dummy3_Optional(_buffer, _size, _lidx, &p->dummy3);
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeA_r13_interval_ULHoppingConfigCommonModeA_r13_Optional(_buffer, _size, _lidx, &p->interval_ULHoppingConfigCommonModeA_r13);
	_serSysDecFreqHoppingParameters_r13_interval_ULHoppingConfigCommonModeB_r13_interval_ULHoppingConfigCommonModeB_r13_Optional(_buffer, _size, _lidx, &p->interval_ULHoppingConfigCommonModeB_r13);
	_serSysDecUint8_t_FreqHoppingParameters_r13_dummy4_Optional(_buffer, _size, _lidx, &p->dummy4);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEpdcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EpdcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecToRS_EPRE_Ratios_Type_EpdcchConfig_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serSysDecPdcchCandidateList_Type_ePdcchCandidateList_Optional(_buffer, _size, _lidx, _mem, &p->ePdcchCandidateList);
	_serSysDecEPDCCH_Config_r11_EPDCCH_Config_Optional(_buffer, _size, _lidx, _mem, &p->EPDCCH_Config);
	_serSysDecFreqHoppingParameters_r13_mPDCCH_FreqHoppingParameters_r13_Optional(_buffer, _size, _lidx, &p->mPDCCH_FreqHoppingParameters_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecEpdcchConfig_Type_Epdcch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EpdcchConfig_Type_Epdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEpdcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value* p, enum MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms40_r12) {
		NTOH_8(p->ms40_r12, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms80_r12) {
		NTOH_8(p->ms80_r12, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_ms160_r12) {
		NTOH_8(p->ms160_r12, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDMTC_PeriodOffset_r12_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, DMTC_PeriodOffset_r12_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Sel)_tmp;
	}
	_serSysDecMeasDS_Config_r12_setup_dmtc_PeriodOffset_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDMTC_PeriodOffset_r12_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value* p, enum MeasDS_Config_r12_setup_ds_OccasionDuration_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasDS_Config_r12_setup_ds_OccasionDuration_r12_durationFDD_r12) {
		NTOH_8(p->durationFDD_r12, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasDS_Config_r12_setup_ds_OccasionDuration_r12_durationTDD_r12) {
		NTOH_8(p->durationTDD_r12, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDS_OccasionDuration_r12_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, DS_OccasionDuration_r12_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasDS_Config_r12_setup_ds_OccasionDuration_r12_Sel)_tmp;
	}
	_serSysDecMeasDS_Config_r12_setup_ds_OccasionDuration_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDS_OccasionDuration_r12_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDS_RS_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DS_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDMTC_PeriodOffset_r12_Type_DMTC_PeriodOffset_Optional(_buffer, _size, _lidx, &p->DMTC_PeriodOffset);
	_serSysDecDS_OccasionDuration_r12_Type_DS_OccasionDuration_r12_Optional(_buffer, _size, _lidx, &p->DS_OccasionDuration_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecDS_RS_Config_Type_DS_RS_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DS_RS_Config_Type_DS_RS_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDS_RS_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysicalLayerConfigDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysicalLayerConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(_buffer, _size, _lidx, _mem, &p->AntennaGroup);
	_serSysDecPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysDecPcfichConfig_Type_Pcfich_Optional(_buffer, _size, _lidx, &p->Pcfich);
	_serSysDecPhichConfig_Type_Phich_Optional(_buffer, _size, _lidx, &p->Phich);
	_serSysDecPdcchConfig_Type_Pdcch_Optional(_buffer, _size, _lidx, _mem, &p->Pdcch);
	_serSysDecPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serSysDecPrimarySyncSignal_Type_Pss_Optional(_buffer, _size, _lidx, &p->Pss);
	_serSysDecSecondarySyncSignal_Type_Sss_Optional(_buffer, _size, _lidx, &p->Sss);
	_serSysDecCSI_RS_Config_Type_CSI_RS_Config_Optional(_buffer, _size, _lidx, _mem, &p->CSI_RS_Config);
	_serSysDecPmchConfig_Type_Pmch_Optional(_buffer, _size, _lidx, &p->Pmch);
	_serSysDecEpdcchConfig_Type_Epdcch_Optional(_buffer, _size, _lidx, _mem, &p->Epdcch);
	_serSysDecDS_RS_Config_Type_DS_RS_Config_Optional(_buffer, _size, _lidx, &p->DS_RS_Config);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPhysicalLayerConfigDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAttenuation_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union Attenuation_Type_Value* p, enum Attenuation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Attenuation_Type_Value) {
		NTOH_8(p->Value, &_buffer[*_lidx], _lidx);
	}
	if (d == Attenuation_Type_Off) {
		NTOH_8(p->Off, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInitialAttenuation_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, InitialAttenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Attenuation_Type_Sel)_tmp;
	}
	_serSysDecAttenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecInitialCellPower_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InitialCellPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->MaxReferencePower, &_buffer[*_lidx], _lidx);
	_serSysDecInitialAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serSysDecInitialCellPower_Type_InitialCellPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InitialCellPower_Type_InitialCellPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecInitialCellPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchToPbchConfig_Type_Pbch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BcchToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqDomainSchedulCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqDomainSchedulCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->FirstRbIndex, &_buffer[*_lidx], _lidx);
	NTOH_32(p->MaxRbCnt, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfoCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfoCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (PdcchDciFormat_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ResourceAllocType = (PdcchResourceAllocation_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Modulation_1stCW = (Modulation_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Modulation_2ndCW = (Modulation_Type)_tmp;
	}
	_serSysDecFreqDomainSchedulCommon_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	NTOH_32(p->RedundancyVersionList.d, &_buffer[*_lidx], _lidx);
	p->RedundancyVersionList.v = serMalloc(_mem, p->RedundancyVersionList.d * sizeof(RedundancyVersion_Type));
	for (size_t i1 = 0; i1 < p->RedundancyVersionList.d; i1++) {
		NTOH_8(p->RedundancyVersionList.v[i1], &_buffer[*_lidx], _lidx);
	}
	_serSysDecRepetitionNumber_Type_DciDlInfoCommon_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysDecDCISubframeRepetitionNumber_Type_DciDlInfoCommon_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDciDlInfoCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSib1Schedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Sib1Schedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecSib1Schedul_Type_Sib1Schedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSib1Schedul_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSiWindowLength_Type_WindowLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SiWindowLength_Type_WindowLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SiWindowLength_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSI_Periodicity_r12_e_Periodicity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SI_Periodicity_r12_e_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SI_Periodicity_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDciDlInfoCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInt32_t_SubframeOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_SubframeOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSingleSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SingleSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);
	_serSysDecInt32_t_SubframeOffset_Optional(_buffer, _size, _lidx, &p->SubframeOffset);

	return SIDL_STATUS_OK;
}

static int _serSysDecSingleSiSchedul_Type_Window_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SingleSiSchedul_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSingleSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSI_Periodicity_r12_e_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serSysDecSingleSiSchedul_Type_Window_DynamicOptional(_buffer, _size, _lidx, _mem, &p->Window);

	return SIDL_STATUS_OK;
}

static int _serSysDecSiSchedulList_Type_SiList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SiSchedulList_Type_SiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SiSchedul_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSiSchedulList_Type_SegmentedSiList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SiSchedulList_Type_SegmentedSiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SiSchedul_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAllSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AllSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSiWindowLength_Type_WindowLength_Optional(_buffer, _size, _lidx, &p->WindowLength);
	_serSysDecSiSchedulList_Type_SiList_Optional(_buffer, _size, _lidx, _mem, &p->SiList);
	_serSysDecSiSchedulList_Type_SegmentedSiList_Optional(_buffer, _size, _lidx, _mem, &p->SegmentedSiList);

	return SIDL_STATUS_OK;
}

static int _serSysDecAllSiSchedul_Type_SiSchedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AllSiSchedul_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAllSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchToPdschConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSib1Schedul_Type_Sib1Schedul_Optional(_buffer, _size, _lidx, _mem, &p->Sib1Schedul);
	_serSysDecAllSiSchedul_Type_SiSchedul_Optional(_buffer, _size, _lidx, _mem, &p->SiSchedul);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchToPdschConfig_Type_Pdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcchToPdschConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMasterInformationBlock(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MasterInformationBlock* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dl_Bandwidth = (MasterInformationBlock_dl_Bandwidth_e)_tmp;
	}
	_serSysDecPHICH_Config(_buffer, _size, _lidx, &p->phich_Config);
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->systemFrameNumber[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->schedulingInfoSIB1_BR_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->systemInfoUnchanged_BR_r15, &_buffer[*_lidx], _lidx);
	for (size_t i1 = 0; i1 < 4; i1++) {
		NTOH_8(p->spare[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_BCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_BCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMasterInformationBlock(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_BCH_Message_BcchInfo_Type_MIB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_BCH_Message_BcchInfo_Type_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ac_BarringFactor = (AC_BarringConfig_ac_BarringFactor_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ac_BarringTime = (AC_BarringConfig_ac_BarringTime_e)_tmp;
	}
	for (size_t i2 = 0; i2 < 5; i2++) {
		NTOH_8(p->ac_BarringForSpecialAC[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_ac_BarringInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_ac_BarringInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ac_BarringForEmergency, &_buffer[*_lidx], _lidx);
	_serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Signalling_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Signalling);
	_serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringInfo_ac_BarringForMO_Data_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Data);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType2_ac_BarringInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sizeOfRA_PreamblesGroupA = (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_sizeOfRA_PreamblesGroupA_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->messageSizeGroupA = (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messageSizeGroupA_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->messagePowerOffsetGroupB = (RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_messagePowerOffsetGroupB_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_preambleInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_preambleInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numberOfRA_Preambles = (RACH_ConfigCommon_preambleInfo_numberOfRA_Preambles_e)_tmp;
	}
	_serSysDecRACH_ConfigCommon_preambleInfo_preamblesGroupAConfig_preamblesGroupAConfig_Optional(_buffer, _size, _lidx, &p->preamblesGroupAConfig);

	return SIDL_STATUS_OK;
}

static int _serSysDecPowerRampingParameters(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PowerRampingParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerRampingStep = (PowerRampingParameters_powerRampingStep_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->preambleInitialReceivedTargetPower = (PowerRampingParameters_preambleInitialReceivedTargetPower_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_ra_SupervisionInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_ra_SupervisionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->preambleTransMax = (PreambleTransMax_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_ResponseWindowSize = (RACH_ConfigCommon_ra_SupervisionInfo_ra_ResponseWindowSize_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mac_ContentionResolutionTimer = (RACH_ConfigCommon_ra_SupervisionInfo_mac_ContentionResolutionTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PreambleTransMax_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfo_r13_preambleMappingInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_CE_LevelInfo_r13_preambleMappingInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->firstPreamble_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->lastPreamble_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_CE_LevelInfo_r13_edt_Parameters_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->edt_LastPreamble_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->edt_SmallTBS_Enabled_r15, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->edt_TBS_r15 = (RACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_TBS_r15_e)_tmp;
	}
	_serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15_mac_ContentionResolutionTimer_r15_e_mac_ContentionResolutionTimer_r15_Optional(_buffer, _size, _lidx, &p->mac_ContentionResolutionTimer_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_CE_LevelInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_CE_LevelInfo_r13_preambleMappingInfo_r13(_buffer, _size, _lidx, &p->preambleMappingInfo_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_ResponseWindowSize_r13 = (RACH_CE_LevelInfo_r13_ra_ResponseWindowSize_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mac_ContentionResolutionTimer_r13 = (RACH_CE_LevelInfo_r13_mac_ContentionResolutionTimer_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->rar_HoppingConfig_r13 = (RACH_CE_LevelInfo_r13_rar_HoppingConfig_r13_e)_tmp;
	}
	_serSysDecRACH_CE_LevelInfo_r13_edt_Parameters_r15_edt_Parameters_r15_Optional(_buffer, _size, _lidx, &p->edt_Parameters_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct RACH_CE_LevelInfo_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecRACH_CE_LevelInfo_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RACH_ConfigCommon_edt_SmallTBS_Subset_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RACH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_ConfigCommon_preambleInfo(_buffer, _size, _lidx, &p->preambleInfo);
	_serSysDecPowerRampingParameters(_buffer, _size, _lidx, &p->powerRampingParameters);
	_serSysDecRACH_ConfigCommon_ra_SupervisionInfo(_buffer, _size, _lidx, &p->ra_SupervisionInfo);
	NTOH_8(p->maxHARQ_Msg3Tx, &_buffer[*_lidx], _lidx);
	_serSysDecPreambleTransMax_e_RACH_ConfigCommon_preambleTransMax_CE_r13_Optional(_buffer, _size, _lidx, &p->preambleTransMax_CE_r13);
	_serSysDecRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(_buffer, _size, _lidx, _mem, &p->rach_CE_LevelInfoList_r13);
	_serSysDecRACH_ConfigCommon_edt_SmallTBS_Subset_r15_e_edt_SmallTBS_Subset_r15_Optional(_buffer, _size, _lidx, &p->edt_SmallTBS_Subset_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->modificationPeriodCoeff = (BCCH_Config_modificationPeriodCoeff_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->defaultPagingCycle = (PCCH_Config_defaultPagingCycle_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nB = (PCCH_Config_nB_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ConfigInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->prach_ConfigIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->highSpeedFlag, &_buffer[*_lidx], _lidx);
	NTOH_8(p->zeroCorrelationZoneConfig, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prach_FreqOffset, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ConfigSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->rootSequenceIndex, &_buffer[*_lidx], _lidx);
	_serSysDecPRACH_ConfigInfo(_buffer, _size, _lidx, &p->prach_ConfigInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->referenceSignalPower, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_b, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_pusch_ConfigBasic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_pusch_ConfigBasic* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->n_SB, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->hoppingMode = (PUSCH_ConfigCommon_pusch_ConfigBasic_hoppingMode_e)_tmp;
	}
	NTOH_8(p->pusch_HoppingOffset, &_buffer[*_lidx], _lidx);
	NTOH_8(p->enable64QAM, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_ReferenceSignalsPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_ReferenceSignalsPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->groupHoppingEnabled, &_buffer[*_lidx], _lidx);
	NTOH_8(p->groupAssignmentPUSCH, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sequenceHoppingEnabled, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigCommon_pusch_ConfigBasic(_buffer, _size, _lidx, &p->pusch_ConfigBasic);
	_serSysDecUL_ReferenceSignalsPUSCH(_buffer, _size, _lidx, &p->ul_ReferenceSignalsPUSCH);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaPUCCH_Shift = (PUCCH_ConfigCommon_deltaPUCCH_Shift_e)_tmp;
	}
	NTOH_8(p->nRB_CQI, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nCS_AN, &_buffer[*_lidx], _lidx);
	NTOH_16(p->n1PUCCH_AN, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigCommon_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_BandwidthConfig = (SoundingRS_UL_ConfigCommon_setup_srs_BandwidthConfig_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_SubframeConfig = (SoundingRS_UL_ConfigCommon_setup_srs_SubframeConfig_e)_tmp;
	}
	NTOH_8(p->ackNackSRS_SimultaneousTransmission, &_buffer[*_lidx], _lidx);
	_serSysDecSoundingRS_UL_ConfigCommon_setup_srs_MaxUpPts_e_srs_MaxUpPts_Optional(_buffer, _size, _lidx, &p->srs_MaxUpPts);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SoundingRS_UL_ConfigCommon_Value* p, enum SoundingRS_UL_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SoundingRS_UL_ConfigCommon_setup) {
		_serSysDecSoundingRS_UL_ConfigCommon_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigCommon_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_PUCCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_PUCCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format1 = (DeltaFList_PUCCH_deltaF_PUCCH_Format1_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format1b = (DeltaFList_PUCCH_deltaF_PUCCH_Format1b_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format2 = (DeltaFList_PUCCH_deltaF_PUCCH_Format2_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format2a = (DeltaFList_PUCCH_deltaF_PUCCH_Format2a_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format2b = (DeltaFList_PUCCH_deltaF_PUCCH_Format2b_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p0_NominalPUSCH, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->alpha = (Alpha_r12_e)_tmp;
	}
	NTOH_8(p->p0_NominalPUCCH, &_buffer[*_lidx], _lidx);
	_serSysDecDeltaFList_PUCCH(_buffer, _size, _lidx, &p->deltaFList_PUCCH);
	NTOH_8(p->deltaPreambleMsg3, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format3_r10 = (UplinkPowerControlCommon_v1020_deltaF_PUCCH_Format3_r10_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format1bCS_r10 = (UplinkPowerControlCommon_v1020_deltaF_PUCCH_Format1bCS_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommon_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_v1250_txFailParams_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_v1250_txFailParams_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->connEstFailCount_r12 = (RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailCount_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->connEstFailOffsetValidity_r12 = (RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffsetValidity_r12_e)_tmp;
	}
	_serSysDecUint8_t_RACH_ConfigCommon_v1250_txFailParams_r12_connEstFailOffset_r12_Optional(_buffer, _size, _lidx, &p->connEstFailOffset_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_ConfigCommon_v1250_txFailParams_r12(_buffer, _size, _lidx, &p->txFailParams_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_ConfigCommon_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1270(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1270* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->enable64QAM_v1270 = (PUSCH_ConfigCommon_v1270_enable64QAM_v1270_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigCommon_v1270(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_Config_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->modificationPeriodCoeff_v1310 = (BCCH_Config_v1310_modificationPeriodCoeff_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PCCH_Config_v1310_nB_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Config_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->paging_narrowBands_r13, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_NumRepetition_Paging_r13 = (PCCH_Config_v1310_mpdcch_NumRepetition_Paging_r13_e)_tmp;
	}
	_serSysDecPCCH_Config_v1310_nB_v1310_e_nB_v1310_Optional(_buffer, _size, _lidx, &p->nB_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFreqHoppingParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeA_r13_e_pusch_maxNumRepetitionCEmodeA_r13_Optional(_buffer, _size, _lidx, &p->pusch_maxNumRepetitionCEmodeA_r13);
	_serSysDecPUSCH_ConfigCommon_v1310_pusch_maxNumRepetitionCEmodeB_r13_e_pusch_maxNumRepetitionCEmodeB_r13_Optional(_buffer, _size, _lidx, &p->pusch_maxNumRepetitionCEmodeB_r13);
	_serSysDecUint8_t_PUSCH_ConfigCommon_v1310_pusch_HoppingOffset_v1310_Optional(_buffer, _size, _lidx, &p->pusch_HoppingOffset_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value* p, enum PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->fdd_r13 = (PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13_e)_tmp;
		}
	}
	if (d == PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->tdd_r13 = (PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Sel)_tmp;
	}
	_serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PRACH_ParametersCE_r13_prach_StartingSubframe_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ParametersCE_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ParametersCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->prach_ConfigIndex_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prach_FreqOffset_r13, &_buffer[*_lidx], _lidx);
	_serSysDecPRACH_ParametersCE_r13_prach_StartingSubframe_r13_e_prach_StartingSubframe_r13_Optional(_buffer, _size, _lidx, &p->prach_StartingSubframe_r13);
	_serSysDecPRACH_ParametersCE_r13_maxNumPreambleAttemptCE_r13_e_maxNumPreambleAttemptCE_r13_Optional(_buffer, _size, _lidx, &p->maxNumPreambleAttemptCE_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numRepetitionPerPreambleAttempt_r13 = (PRACH_ParametersCE_r13_numRepetitionPerPreambleAttempt_r13_e)_tmp;
	}
	NTOH_32(p->mpdcch_NarrowbandsToMonitor_r13.d, &_buffer[*_lidx], _lidx);
	p->mpdcch_NarrowbandsToMonitor_r13.v = serMalloc(_mem, p->mpdcch_NarrowbandsToMonitor_r13.d * sizeof(uint8_t));
	for (size_t i3 = 0; i3 < p->mpdcch_NarrowbandsToMonitor_r13.d; i3++) {
		NTOH_8(p->mpdcch_NarrowbandsToMonitor_r13.v[i3], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_NumRepetition_RA_r13 = (PRACH_ParametersCE_r13_mpdcch_NumRepetition_RA_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->prach_HoppingConfig_r13 = (PRACH_ParametersCE_r13_prach_HoppingConfig_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ConfigSIB_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->rsrp_ThresholdsPrachInfoList_r13.d, &_buffer[*_lidx], _lidx);
	p->rsrp_ThresholdsPrachInfoList_r13.v = serMalloc(_mem, p->rsrp_ThresholdsPrachInfoList_r13.d * sizeof(RSRP_Range));
	for (size_t i2 = 0; i2 < p->rsrp_ThresholdsPrachInfoList_r13.d; i2++) {
		NTOH_8(p->rsrp_ThresholdsPrachInfoList_r13.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecPRACH_ConfigSIB_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_startSF_CSS_RA_r13);
	_serSysDecUint8_t_PRACH_ConfigSIB_v1310_prach_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->prach_HoppingOffset_r13);
	NTOH_32(p->prach_ParametersListCE_r13.d, &_buffer[*_lidx], _lidx);
	p->prach_ParametersListCE_r13.v = serMalloc(_mem, p->prach_ParametersListCE_r13.d * sizeof(struct PRACH_ParametersCE_r13));
	for (size_t i2 = 0; i2 < p->prach_ParametersListCE_r13.d; i2++) {
		_serSysDecPRACH_ParametersCE_r13(_buffer, _size, _lidx, _mem, &p->prach_ParametersListCE_r13.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_ConfigSIB_v1310(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct N1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(uint16_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_16(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(_buffer, _size, _lidx, _mem, &p->n1PUCCH_AN_InfoList_r13);
	_serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level0_r13_e_pucch_NumRepetitionCE_Msg4_Level0_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level0_r13);
	_serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level1_r13_e_pucch_NumRepetitionCE_Msg4_Level1_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level1_r13);
	_serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level2_r13_e_pucch_NumRepetitionCE_Msg4_Level2_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level2_r13);
	_serSysDecPUCCH_ConfigCommon_v1310_pucch_NumRepetitionCE_Msg4_Level3_r13_e_pucch_NumRepetitionCE_Msg4_Level3_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigCommon_v1310(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (HighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (HighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecHighSpeedConfig_r14_highSpeedEnhancedMeasFlag_r14_e_highSpeedEnhancedMeasFlag_r14_Optional(_buffer, _size, _lidx, &p->highSpeedEnhancedMeasFlag_r14);
	_serSysDecHighSpeedConfig_r14_highSpeedEnhancedDemodulationFlag_r14_e_highSpeedEnhancedDemodulationFlag_r14_Optional(_buffer, _size, _lidx, &p->highSpeedEnhancedDemodulationFlag_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecHighSpeedConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->rootSequenceIndexHighSpeed_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->zeroCorrelationZoneConfigHighSpeed_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prach_ConfigIndexHighSpeed_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prach_FreqOffsetHighSpeed_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigCommon_v1430_pucch_NumRepetitionCE_Msg4_Level3_r14_e_pucch_NumRepetitionCE_Msg4_Level3_r14_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_Msg4_Level3_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigCommon_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->prach_ConfigIndex_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prach_FreqOffset_r15, &_buffer[*_lidx], _lidx);
	_serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_prach_StartingSubframe_r15_e_prach_StartingSubframe_r15_Optional(_buffer, _size, _lidx, &p->prach_StartingSubframe_r15);
	NTOH_32(p->mpdcch_NarrowbandsToMonitor_r15.d, &_buffer[*_lidx], _lidx);
	p->mpdcch_NarrowbandsToMonitor_r15.v = serMalloc(_mem, p->mpdcch_NarrowbandsToMonitor_r15.d * sizeof(uint8_t));
	for (size_t i3 = 0; i3 < p->mpdcch_NarrowbandsToMonitor_r15.d; i3++) {
		NTOH_8(p->mpdcch_NarrowbandsToMonitor_r15.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEDT_PRACH_ParametersCE_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EDT_PRACH_ParametersCE_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(_buffer, _size, _lidx, _mem, &p->edt_PRACH_ParametersCE_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ConfigSIB_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->edt_PRACH_ParametersListCE_r15.d, &_buffer[*_lidx], _lidx);
	p->edt_PRACH_ParametersListCE_r15.v = serMalloc(_mem, p->edt_PRACH_ParametersListCE_r15.d * sizeof(struct EDT_PRACH_ParametersCE_r15));
	for (size_t i2 = 0; i2 < p->edt_PRACH_ParametersListCE_r15.d; i2++) {
		_serSysDecEDT_PRACH_ParametersCE_r15(_buffer, _size, _lidx, _mem, &p->edt_PRACH_ParametersListCE_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_ConfigSIB_v1530(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSS_Config_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSS_Config_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->duration_r15 = (RSS_Config_r15_duration_r15_e)_tmp;
	}
	NTOH_8(p->freqLocation_r15, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicity_r15 = (RSS_Config_r15_periodicity_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerBoost_r15 = (RSS_Config_r15_powerBoost_r15_e)_tmp;
	}
	NTOH_8(p->timeOffset_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRSS_Config_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (WUS_Config_r15_numPOs_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (WUS_Config_r15_timeOffset_eDRX_Long_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxDurationFactor_r15 = (WUS_Config_r15_maxDurationFactor_r15_e)_tmp;
	}
	_serSysDecWUS_Config_r15_numPOs_r15_e_numPOs_r15_Optional(_buffer, _size, _lidx, &p->numPOs_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->freqLocation_r15 = (WUS_Config_r15_freqLocation_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeOffsetDRX_r15 = (WUS_Config_r15_timeOffsetDRX_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeOffset_eDRX_Short_r15 = (WUS_Config_r15_timeOffset_eDRX_Short_r15_e)_tmp;
	}
	_serSysDecWUS_Config_r15_timeOffset_eDRX_Long_r15_e_timeOffset_eDRX_Long_r15_Optional(_buffer, _size, _lidx, &p->timeOffset_eDRX_Long_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWUS_Config_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->highSpeedMeasGapCE_ModeA_r15 = (HighSpeedConfig_v1530_highSpeedMeasGapCE_ModeA_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecHighSpeedConfig_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1_r15_e_deltaF_slotSPUCCH_Format1_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1a_r15_e_deltaF_slotSPUCCH_Format1a_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1a_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format1b_r15_e_deltaF_slotSPUCCH_Format1b_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format1b_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_Format3_r15_e_deltaF_slotSPUCCH_Format3_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_Format3_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_RM_Format4_r15_e_deltaF_slotSPUCCH_RM_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_RM_Format4_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_slotSPUCCH_TBCC_Format4_r15_e_deltaF_slotSPUCCH_TBCC_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_slotSPUCCH_TBCC_Format4_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1and1a_r15_e_deltaF_subslotSPUCCH_Format1and1a_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_Format1and1a_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_Format1b_r15_e_deltaF_subslotSPUCCH_Format1b_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_Format1b_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_RM_Format4_r15_e_deltaF_subslotSPUCCH_RM_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_RM_Format4_r15);
	_serSysDecDeltaFList_SPUCCH_r15_setup_deltaF_subslotSPUCCH_TBCC_Format4_r15_e_deltaF_subslotSPUCCH_TBCC_Format4_r15_Optional(_buffer, _size, _lidx, &p->deltaF_subslotSPUCCH_TBCC_Format4_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DeltaFList_SPUCCH_r15_Value* p, enum DeltaFList_SPUCCH_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DeltaFList_SPUCCH_r15_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == DeltaFList_SPUCCH_r15_setup) {
		_serSysDecDeltaFList_SPUCCH_r15_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaFList_SPUCCH_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaFList_SPUCCH_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DeltaFList_SPUCCH_r15_Sel)_tmp;
	}
	_serSysDecDeltaFList_SPUCCH_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDeltaFList_SPUCCH_r15(_buffer, _size, _lidx, &p->deltaFList_SPUCCH_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommon_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_v1560(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_v1560* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerBoost_r15 = (WUS_Config_v1560_powerBoost_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWUS_Config_v1560(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numDRX_CyclesRelaxed_r16 = (WUS_Config_v1610_numDRX_CyclesRelaxed_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWUS_Config_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (HighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (HighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecHighSpeedConfig_v1610_highSpeedEnhMeasFlag2_r16_e_highSpeedEnhMeasFlag2_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEnhMeasFlag2_r16);
	_serSysDecHighSpeedConfig_v1610_highSpeedEnhDemodFlag2_r16_e_highSpeedEnhDemodFlag2_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEnhDemodFlag2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecHighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct HighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecHighSpeedConfig_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRS_ChEstMPDCCH_ConfigCommon_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRS_ChEstMPDCCH_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerRatio_r16 = (CRS_ChEstMPDCCH_ConfigCommon_r16_powerRatio_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCRS_ChEstMPDCCH_ConfigCommon_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_Config_r16_groupAlternation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_Config_r16_commonSequence_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_TimeParameters_r16_numPOs_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (GWUS_TimeParameters_r16_powerBoost_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxDurationFactor_r16 = (GWUS_TimeParameters_r16_maxDurationFactor_r16_e)_tmp;
	}
	_serSysDecGWUS_TimeParameters_r16_numPOs_r16_e_numPOs_r16_Optional(_buffer, _size, _lidx, &p->numPOs_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeOffsetDRX_r16 = (GWUS_TimeParameters_r16_timeOffsetDRX_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeOffset_eDRX_Short_r16 = (GWUS_TimeParameters_r16_timeOffset_eDRX_Short_r16_e)_tmp;
	}
	_serSysDecGWUS_TimeParameters_r16_timeOffset_eDRX_Long_r16_e_timeOffset_eDRX_Long_r16_Optional(_buffer, _size, _lidx, &p->timeOffset_eDRX_Long_r16);
	_serSysDecGWUS_TimeParameters_r16_numDRX_CyclesRelaxed_r16_e_numDRX_CyclesRelaxed_r16_Optional(_buffer, _size, _lidx, &p->numDRX_CyclesRelaxed_r16);
	_serSysDecGWUS_TimeParameters_r16_powerBoost_r16_e_powerBoost_r16_Optional(_buffer, _size, _lidx, &p->powerBoost_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecGWUS_TimeParameters_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union GWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value* p, enum GWUS_ResourceConfig_r16_resourceMappingPattern_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithWUS) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->resourceLocationWithWUS = (GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithWUS_e)_tmp;
		}
	}
	if (d == GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithoutWUS) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->resourceLocationWithoutWUS = (GWUS_ResourceConfig_r16_resourceMappingPattern_r16_resourceLocationWithoutWUS_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ResourceConfig_r16_resourceMappingPattern_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GWUS_ResourceConfig_r16_resourceMappingPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum GWUS_ResourceConfig_r16_resourceMappingPattern_r16_Sel)_tmp;
	}
	_serSysDecGWUS_ResourceConfig_r16_resourceMappingPattern_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(GWUS_NumGroups_r16_e));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->v.v[i2] = (GWUS_NumGroups_r16_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ResourceConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_ResourceConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecGWUS_ResourceConfig_r16_resourceMappingPattern_r16(_buffer, _size, _lidx, &p->resourceMappingPattern_r16);
	_serSysDecGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(_buffer, _size, _lidx, _mem, &p->numGroupsList_r16);
	_serSysDecGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(_buffer, _size, _lidx, _mem, &p->groupsForServiceList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecGWUS_ResourceConfig_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecGWUS_ResourceConfig_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(GWUS_PagingProbThresh_r16_e));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->v.v[i2] = (GWUS_PagingProbThresh_r16_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(bool));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecGWUS_Config_r16_groupAlternation_r16_e_groupAlternation_r16_Optional(_buffer, _size, _lidx, &p->groupAlternation_r16);
	_serSysDecGWUS_Config_r16_commonSequence_r16_e_commonSequence_r16_Optional(_buffer, _size, _lidx, &p->commonSequence_r16);
	_serSysDecGWUS_TimeParameters_r16_GWUS_Config_r16_timeParameters_r16_Optional(_buffer, _size, _lidx, &p->timeParameters_r16);
	_serSysDecGWUS_ResourceConfig_r16(_buffer, _size, _lidx, _mem, &p->resourceConfigDRX_r16);
	_serSysDecGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(_buffer, _size, _lidx, _mem, &p->resourceConfig_eDRX_Short_r16);
	_serSysDecGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(_buffer, _size, _lidx, _mem, &p->resourceConfig_eDRX_Long_r16);
	_serSysDecGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(_buffer, _size, _lidx, _mem, &p->probThreshList_r16);
	_serSysDecGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(_buffer, _size, _lidx, _mem, &p->groupNarrowBandList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct GWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecGWUS_Config_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->alphaSRS_Add_r16 = (Alpha_r12_e)_tmp;
	}
	NTOH_8(p->p0_NominalSRS_Add_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommon_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RadioResourceConfigCommonSIB_rss_MeasConfig_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioResourceConfigCommonSIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RadioResourceConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->rach_ConfigCommon);
	_serSysDecBCCH_Config(_buffer, _size, _lidx, &p->bcch_Config);
	_serSysDecPCCH_Config(_buffer, _size, _lidx, &p->pcch_Config);
	_serSysDecPRACH_ConfigSIB(_buffer, _size, _lidx, &p->prach_Config);
	_serSysDecPDSCH_ConfigCommon(_buffer, _size, _lidx, &p->pdsch_ConfigCommon);
	_serSysDecPUSCH_ConfigCommon(_buffer, _size, _lidx, &p->pusch_ConfigCommon);
	_serSysDecPUCCH_ConfigCommon(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serSysDecSoundingRS_UL_ConfigCommon(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigCommon);
	_serSysDecUplinkPowerControlCommon(_buffer, _size, _lidx, &p->uplinkPowerControlCommon);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ul_CyclicPrefixLength = (UL_CyclicPrefixLength_e)_tmp;
	}
	_serSysDecUplinkPowerControlCommon_v1020_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1020);
	_serSysDecRACH_ConfigCommon_v1250_RadioResourceConfigCommonSIB_rach_ConfigCommon_v1250_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon_v1250);
	_serSysDecPUSCH_ConfigCommon_v1270_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1270_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1270);
	_serSysDecBCCH_Config_v1310_RadioResourceConfigCommonSIB_bcch_Config_v1310_Optional(_buffer, _size, _lidx, &p->bcch_Config_v1310);
	_serSysDecPCCH_Config_v1310_RadioResourceConfigCommonSIB_pcch_Config_v1310_Optional(_buffer, _size, _lidx, &p->pcch_Config_v1310);
	_serSysDecFreqHoppingParameters_r13_RadioResourceConfigCommonSIB_freqHoppingParameters_r13_Optional(_buffer, _size, _lidx, &p->freqHoppingParameters_r13);
	_serSysDecPDSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pdsch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pdsch_ConfigCommon_v1310);
	_serSysDecPUSCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pusch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1310);
	_serSysDecPRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, _mem, &p->prach_ConfigCommon_v1310);
	_serSysDecPUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, _mem, &p->pucch_ConfigCommon_v1310);
	_serSysDecHighSpeedConfig_r14_RadioResourceConfigCommonSIB_highSpeedConfig_r14_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_r14);
	_serSysDecPRACH_Config_v1430_RadioResourceConfigCommonSIB_prach_Config_v1430_Optional(_buffer, _size, _lidx, &p->prach_Config_v1430);
	_serSysDecPUCCH_ConfigCommon_v1430_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1430_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon_v1430);
	_serSysDecPRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(_buffer, _size, _lidx, _mem, &p->prach_Config_v1530);
	_serSysDecRSS_Config_r15_RadioResourceConfigCommonSIB_ce_RSS_Config_r15_Optional(_buffer, _size, _lidx, &p->ce_RSS_Config_r15);
	_serSysDecWUS_Config_r15_RadioResourceConfigCommonSIB_wus_Config_r15_Optional(_buffer, _size, _lidx, &p->wus_Config_r15);
	_serSysDecHighSpeedConfig_v1530_RadioResourceConfigCommonSIB_highSpeedConfig_v1530_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_v1530);
	_serSysDecUplinkPowerControlCommon_v1530_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1540_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1540);
	_serSysDecWUS_Config_v1560_RadioResourceConfigCommonSIB_wus_Config_v1560_Optional(_buffer, _size, _lidx, &p->wus_Config_v1560);
	_serSysDecWUS_Config_v1610_RadioResourceConfigCommonSIB_wus_Config_v1610_Optional(_buffer, _size, _lidx, &p->wus_Config_v1610);
	_serSysDecHighSpeedConfig_v1610_RadioResourceConfigCommonSIB_highSpeedConfig_v1610_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_v1610);
	_serSysDecCRS_ChEstMPDCCH_ConfigCommon_r16_RadioResourceConfigCommonSIB_crs_ChEstMPDCCH_ConfigCommon_r16_Optional(_buffer, _size, _lidx, &p->crs_ChEstMPDCCH_ConfigCommon_r16);
	_serSysDecGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(_buffer, _size, _lidx, _mem, &p->gwus_Config_r16);
	_serSysDecUplinkPowerControlCommon_v1610_RadioResourceConfigCommonSIB_uplinkPowerControlCommon_v1610_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1610);
	_serSysDecRadioResourceConfigCommonSIB_rss_MeasConfig_r16_e_rss_MeasConfig_r16_Optional(_buffer, _size, _lidx, &p->rss_MeasConfig_r16);
	_serSysDecRadioResourceConfigCommonSIB_rss_MeasNonNCL_r16_e_rss_MeasNonNCL_r16_Optional(_buffer, _size, _lidx, &p->rss_MeasNonNCL_r16);
	_serSysDecB2_RadioResourceConfigCommonSIB_puncturedSubcarriersDL_r16_Optional(_buffer, _size, _lidx, &p->puncturedSubcarriersDL_r16);
	_serSysDecBool_RadioResourceConfigCommonSIB_highSpeedInterRAT_NR_r16_Optional(_buffer, _size, _lidx, &p->highSpeedInterRAT_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_TimersAndConstants_t300_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_TimersAndConstants_t301_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_TimersAndConstants_t310_v1330_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_TimersAndConstants_t300_r15_e_t300_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_TimersAndConstants_t300_r15_e_t300_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_TimersAndConstants_t300_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_TimersAndConstants(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_TimersAndConstants* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t300 = (UE_TimersAndConstants_t300_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t301 = (UE_TimersAndConstants_t301_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t310 = (UE_TimersAndConstants_t310_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->n310 = (UE_TimersAndConstants_n310_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t311 = (UE_TimersAndConstants_t311_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->n311 = (UE_TimersAndConstants_n311_e)_tmp;
	}
	_serSysDecUE_TimersAndConstants_t300_v1310_e_t300_v1310_Optional(_buffer, _size, _lidx, &p->t300_v1310);
	_serSysDecUE_TimersAndConstants_t301_v1310_e_t301_v1310_Optional(_buffer, _size, _lidx, &p->t301_v1310);
	_serSysDecUE_TimersAndConstants_t310_v1330_e_t310_v1330_Optional(_buffer, _size, _lidx, &p->t310_v1330);
	_serSysDecUE_TimersAndConstants_t300_r15_e_t300_r15_Optional(_buffer, _size, _lidx, &p->t300_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_freqInfo_ul_Bandwidth_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_freqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_freqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecARFCN_ValueEUTRA_SystemInformationBlockType2_freqInfo_ul_CarrierFreq_Optional(_buffer, _size, _lidx, &p->ul_CarrierFreq);
	_serSysDecSystemInformationBlockType2_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(_buffer, _size, _lidx, &p->ul_Bandwidth);
	NTOH_8(p->additionalSpectrumEmission, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBSFN_SubframeConfig));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_ac_BarringSkipForSMS_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12_ac_BarringInfo_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12_ac_BarringInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ac_BarringForEmergency_r12, &_buffer[*_lidx], _lidx);
	_serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Signalling_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Signalling_r12);
	_serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringForMO_Data_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForMO_Data_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringPerPLMN_r12_ac_BarringInfo_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringPerPLMN_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r12, &_buffer[*_lidx], _lidx);
	_serSysDecAC_BarringPerPLMN_r12_ac_BarringInfo_r12_ac_BarringInfo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringInfo_r12);
	_serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVoice_r12);
	_serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVideo_r12);
	_serSysDecAC_BarringPerPLMN_r12_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForSMS_r12);
	_serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ac_BarringForCSFB_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringForCSFB_r12);
	_serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Voice_r12_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Voice_r12);
	_serSysDecAC_BarringConfig_AC_BarringPerPLMN_r12_ssac_BarringForMMTEL_Video_r12_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Video_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct AC_BarringPerPLMN_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecAC_BarringPerPLMN_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_voiceServiceCauseIndication_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBarringPerACDC_Category_r13_acdc_BarringConfig_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BarringPerACDC_Category_r13_acdc_BarringConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ac_BarringFactor_r13 = (BarringPerACDC_Category_r13_acdc_BarringConfig_r13_ac_BarringFactor_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ac_BarringTime_r13 = (BarringPerACDC_Category_r13_acdc_BarringConfig_r13_ac_BarringTime_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBarringPerACDC_Category_r13_acdc_BarringConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBarringPerACDC_Category_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BarringPerACDC_Category_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->acdc_Category_r13, &_buffer[*_lidx], _lidx);
	_serSysDecBarringPerACDC_Category_r13_acdc_BarringConfig_r13_acdc_BarringConfig_r13_Optional(_buffer, _size, _lidx, &p->acdc_BarringConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecACDC_BarringForCommon_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ACDC_BarringForCommon_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->acdc_HPLMNonly_r13, &_buffer[*_lidx], _lidx);
	NTOH_32(p->barringPerACDC_CategoryList_r13.d, &_buffer[*_lidx], _lidx);
	p->barringPerACDC_CategoryList_r13.v = serMalloc(_mem, p->barringPerACDC_CategoryList_r13.d * sizeof(struct BarringPerACDC_Category_r13));
	for (size_t i2 = 0; i2 < p->barringPerACDC_CategoryList_r13.d; i2++) {
		_serSysDecBarringPerACDC_Category_r13(_buffer, _size, _lidx, &p->barringPerACDC_CategoryList_r13.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecACDC_BarringForCommon_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecACDC_BarringPerPLMN_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ACDC_BarringPerPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->acdc_OnlyForHPLMN_r13, &_buffer[*_lidx], _lidx);
	NTOH_32(p->barringPerACDC_CategoryList_r13.d, &_buffer[*_lidx], _lidx);
	p->barringPerACDC_CategoryList_r13.v = serMalloc(_mem, p->barringPerACDC_CategoryList_r13.d * sizeof(struct BarringPerACDC_Category_r13));
	for (size_t i3 = 0; i3 < p->barringPerACDC_CategoryList_r13.d; i3++) {
		_serSysDecBarringPerACDC_Category_r13(_buffer, _size, _lidx, &p->barringPerACDC_CategoryList_r13.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct ACDC_BarringPerPLMN_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecACDC_BarringPerPLMN_r13(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UDT_Restricting_r13_udt_Restricting_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UDT_Restricting_r13_udt_RestrictingTime_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_Restricting_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_Restricting_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUDT_Restricting_r13_udt_Restricting_r13_e_udt_Restricting_r13_Optional(_buffer, _size, _lidx, &p->udt_Restricting_r13);
	_serSysDecUDT_Restricting_r13_udt_RestrictingTime_r13_e_udt_RestrictingTime_r13_Optional(_buffer, _size, _lidx, &p->udt_RestrictingTime_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUDT_Restricting_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUDT_Restricting_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_RestrictingPerPLMN_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UDT_RestrictingPerPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUDT_Restricting_r13_UDT_RestrictingPerPLMN_r13_udt_Restricting_r13_Optional(_buffer, _size, _lidx, &p->udt_Restricting_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct UDT_RestrictingPerPLMN_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecUDT_RestrictingPerPLMN_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCIOT_OptimisationPLMN_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CIOT_OptimisationPLMN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCIOT_OptimisationPLMN_r13_up_CIoT_EPS_Optimisation_r13_e_up_CIoT_EPS_Optimisation_r13_Optional(_buffer, _size, _lidx, &p->up_CIoT_EPS_Optimisation_r13);
	_serSysDecCIOT_OptimisationPLMN_r13_cp_CIoT_EPS_Optimisation_r13_e_cp_CIoT_EPS_Optimisation_r13_Optional(_buffer, _size, _lidx, &p->cp_CIoT_EPS_Optimisation_r13);
	_serSysDecCIOT_OptimisationPLMN_r13_attachWithoutPDN_Connectivity_r13_e_attachWithoutPDN_Connectivity_r13_Optional(_buffer, _size, _lidx, &p->attachWithoutPDN_Connectivity_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CIOT_OptimisationPLMN_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCIOT_OptimisationPLMN_r13(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_useFullResumeID_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_unicastFreqHoppingInd_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBSFN_SubframeConfig_v1430));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBSFN_SubframeConfig_v1430(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_videoServiceCauseIndication_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PLMN_Info_r15_upperLayerIndication_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_Info_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_Info_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPLMN_Info_r15_upperLayerIndication_r15_e_upperLayerIndication_r15_Optional(_buffer, _size, _lidx, &p->upperLayerIndication_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PLMN_Info_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecPLMN_Info_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_cp_EDT_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_up_EDT_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_idleModeMeasurements_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_rlos_Enabled_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_earlySecurityReactivation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_cp_EDT_5GC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_up_EDT_5GC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_cp_PUR_EPC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_up_PUR_EPC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_cp_PUR_5GC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_up_PUR_5GC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_rai_ActivationEnh_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType2_idleModeMeasurementsNR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType2(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType2* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType2_ac_BarringInfo_ac_BarringInfo_Optional(_buffer, _size, _lidx, &p->ac_BarringInfo);
	_serSysDecRadioResourceConfigCommonSIB(_buffer, _size, _lidx, _mem, &p->radioResourceConfigCommon);
	_serSysDecUE_TimersAndConstants(_buffer, _size, _lidx, &p->ue_TimersAndConstants);
	_serSysDecSystemInformationBlockType2_freqInfo(_buffer, _size, _lidx, &p->freqInfo);
	_serSysDecMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeAlignmentTimerCommon = (TimeAlignmentTimer_e)_tmp;
	}
	_serSysDecOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Voice_r9_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Voice_r9);
	_serSysDecAC_BarringConfig_SystemInformationBlockType2_ssac_BarringForMMTEL_Video_r9_Optional(_buffer, _size, _lidx, &p->ssac_BarringForMMTEL_Video_r9);
	_serSysDecAC_BarringConfig_SystemInformationBlockType2_ac_BarringForCSFB_r10_Optional(_buffer, _size, _lidx, &p->ac_BarringForCSFB_r10);
	_serSysDecSystemInformationBlockType2_ac_BarringSkipForMMTELVoice_r12_e_ac_BarringSkipForMMTELVoice_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVoice_r12);
	_serSysDecSystemInformationBlockType2_ac_BarringSkipForMMTELVideo_r12_e_ac_BarringSkipForMMTELVideo_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForMMTELVideo_r12);
	_serSysDecSystemInformationBlockType2_ac_BarringSkipForSMS_r12_e_ac_BarringSkipForSMS_r12_Optional(_buffer, _size, _lidx, &p->ac_BarringSkipForSMS_r12);
	_serSysDecAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(_buffer, _size, _lidx, _mem, &p->ac_BarringPerPLMN_List_r12);
	_serSysDecSystemInformationBlockType2_voiceServiceCauseIndication_r12_e_voiceServiceCauseIndication_r12_Optional(_buffer, _size, _lidx, &p->voiceServiceCauseIndication_r12);
	_serSysDecACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(_buffer, _size, _lidx, _mem, &p->acdc_BarringForCommon_r13);
	_serSysDecACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(_buffer, _size, _lidx, _mem, &p->acdc_BarringPerPLMN_List_r13);
	_serSysDecUDT_Restricting_r13_SystemInformationBlockType2_udt_RestrictingForCommon_r13_Optional(_buffer, _size, _lidx, &p->udt_RestrictingForCommon_r13);
	_serSysDecUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(_buffer, _size, _lidx, _mem, &p->udt_RestrictingPerPLMN_List_r13);
	_serSysDecCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(_buffer, _size, _lidx, _mem, &p->cIoT_EPS_OptimisationInfo_r13);
	_serSysDecSystemInformationBlockType2_useFullResumeID_r13_e_useFullResumeID_r13_Optional(_buffer, _size, _lidx, &p->useFullResumeID_r13);
	_serSysDecSystemInformationBlockType2_unicastFreqHoppingInd_r13_e_unicastFreqHoppingInd_r13_Optional(_buffer, _size, _lidx, &p->unicastFreqHoppingInd_r13);
	_serSysDecMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList_v1430);
	_serSysDecSystemInformationBlockType2_videoServiceCauseIndication_r14_e_videoServiceCauseIndication_r14_Optional(_buffer, _size, _lidx, &p->videoServiceCauseIndication_r14);
	_serSysDecPLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(_buffer, _size, _lidx, _mem, &p->plmn_InfoList_r15);
	_serSysDecSystemInformationBlockType2_cp_EDT_r15_e_cp_EDT_r15_Optional(_buffer, _size, _lidx, &p->cp_EDT_r15);
	_serSysDecSystemInformationBlockType2_up_EDT_r15_e_up_EDT_r15_Optional(_buffer, _size, _lidx, &p->up_EDT_r15);
	_serSysDecSystemInformationBlockType2_idleModeMeasurements_r15_e_idleModeMeasurements_r15_Optional(_buffer, _size, _lidx, &p->idleModeMeasurements_r15);
	_serSysDecSystemInformationBlockType2_reducedCP_LatencyEnabled_r15_e_reducedCP_LatencyEnabled_r15_Optional(_buffer, _size, _lidx, &p->reducedCP_LatencyEnabled_r15);
	_serSysDecSystemInformationBlockType2_mbms_ROM_ServiceIndication_r15_e_mbms_ROM_ServiceIndication_r15_Optional(_buffer, _size, _lidx, &p->mbms_ROM_ServiceIndication_r15);
	_serSysDecSystemInformationBlockType2_rlos_Enabled_r16_e_rlos_Enabled_r16_Optional(_buffer, _size, _lidx, &p->rlos_Enabled_r16);
	_serSysDecSystemInformationBlockType2_earlySecurityReactivation_r16_e_earlySecurityReactivation_r16_Optional(_buffer, _size, _lidx, &p->earlySecurityReactivation_r16);
	_serSysDecSystemInformationBlockType2_cp_EDT_5GC_r16_e_cp_EDT_5GC_r16_Optional(_buffer, _size, _lidx, &p->cp_EDT_5GC_r16);
	_serSysDecSystemInformationBlockType2_up_EDT_5GC_r16_e_up_EDT_5GC_r16_Optional(_buffer, _size, _lidx, &p->up_EDT_5GC_r16);
	_serSysDecSystemInformationBlockType2_cp_PUR_EPC_r16_e_cp_PUR_EPC_r16_Optional(_buffer, _size, _lidx, &p->cp_PUR_EPC_r16);
	_serSysDecSystemInformationBlockType2_up_PUR_EPC_r16_e_up_PUR_EPC_r16_Optional(_buffer, _size, _lidx, &p->up_PUR_EPC_r16);
	_serSysDecSystemInformationBlockType2_cp_PUR_5GC_r16_e_cp_PUR_5GC_r16_Optional(_buffer, _size, _lidx, &p->cp_PUR_5GC_r16);
	_serSysDecSystemInformationBlockType2_up_PUR_5GC_r16_e_up_PUR_5GC_r16_Optional(_buffer, _size, _lidx, &p->up_PUR_5GC_r16);
	_serSysDecSystemInformationBlockType2_mpdcch_CQI_Reporting_r16_e_mpdcch_CQI_Reporting_r16_Optional(_buffer, _size, _lidx, &p->mpdcch_CQI_Reporting_r16);
	_serSysDecSystemInformationBlockType2_rai_ActivationEnh_r16_e_rai_ActivationEnh_r16_Optional(_buffer, _size, _lidx, &p->rai_ActivationEnh_r16);
	_serSysDecSystemInformationBlockType2_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMobilityStateParameters(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MobilityStateParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Evaluation = (MobilityStateParameters_t_Evaluation_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_HystNormal = (MobilityStateParameters_t_HystNormal_e)_tmp;
	}
	NTOH_8(p->n_CellChangeMedium, &_buffer[*_lidx], _lidx);
	NTOH_8(p->n_CellChangeHigh, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_Medium = (SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_Medium_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_High = (SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF_sf_High_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMobilityStateParameters(_buffer, _size, _lidx, &p->mobilityStateParameters);
	_serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(_buffer, _size, _lidx, &p->q_HystSF);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_cellReselectionInfoCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_cellReselectionInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_Hyst = (SystemInformationBlockType3_cellReselectionInfoCommon_q_Hyst_e)_tmp;
	}
	_serSysDecSystemInformationBlockType3_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(_buffer, _size, _lidx, &p->speedStateReselectionPars);

	return SIDL_STATUS_OK;
}

static int _serSysDecReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_cellReselectionServingFreqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_cellReselectionServingFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecReselectionThreshold_SystemInformationBlockType3_cellReselectionServingFreqInfo_s_NonIntraSearch_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearch);
	NTOH_8(p->threshServingLow, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cellReselectionPriority, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecAllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AllowedMeasBandwidth_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_Medium = (SpeedStateScaleFactors_sf_Medium_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_High = (SpeedStateScaleFactors_sf_High_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_intraFreqCellReselectionInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_intraFreqCellReselectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serSysDecP_Max_SystemInformationBlockType3_intraFreqCellReselectionInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serSysDecReselectionThreshold_SystemInformationBlockType3_intraFreqCellReselectionInfo_s_IntraSearch_Optional(_buffer, _size, _lidx, &p->s_IntraSearch);
	_serSysDecAllowedMeasBandwidth_e_SystemInformationBlockType3_intraFreqCellReselectionInfo_allowedMeasBandwidth_Optional(_buffer, _size, _lidx, &p->allowedMeasBandwidth);
	NTOH_8(p->presenceAntennaPort1, &_buffer[*_lidx], _lidx);
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->neighCellConfig[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->t_ReselectionEUTRA, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_SystemInformationBlockType3_intraFreqCellReselectionInfo_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_s_IntraSearch_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_s_IntraSearch_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->s_IntraSearchP_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->s_IntraSearchQ_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType3_s_IntraSearch_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_s_NonIntraSearch_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_s_NonIntraSearch_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->s_NonIntraSearchP_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->s_NonIntraSearchQ_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType3_s_NonIntraSearch_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionServingFreqInfo_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionServingFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReselectionSubPriority_r13 = (CellReselectionSubPriority_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionServingFreqInfo_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RedistributionServingInfo_r13_redistributionFactorCell_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (RedistributionServingInfo_r13_redistrOnPagingOnly_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionServingInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionServingInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->redistributionFactorServing_r13, &_buffer[*_lidx], _lidx);
	_serSysDecRedistributionServingInfo_r13_redistributionFactorCell_r13_e_redistributionFactorCell_r13_Optional(_buffer, _size, _lidx, &p->redistributionFactorCell_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t360_r13 = (RedistributionServingInfo_r13_t360_r13_e)_tmp;
	}
	_serSysDecRedistributionServingInfo_r13_redistrOnPagingOnly_r13_e_redistrOnPagingOnly_r13_Optional(_buffer, _size, _lidx, &p->redistrOnPagingOnly_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRedistributionServingInfo_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMinCE_r13, &_buffer[*_lidx], _lidx);
	_serSysDecQ_QualMin_r9_CellSelectionInfoCE_r13_q_QualMinRSRQ_CE_r13_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_CE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecT_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct T_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMinCE1_r13, &_buffer[*_lidx], _lidx);
	_serSysDecQ_QualMin_r9_CellSelectionInfoCE1_r13_q_QualMinRSRQ_CE1_r13_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_CE1_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_v1360(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_v1360* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->delta_RxLevMinCE1_v1360, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionInfoCommon_v1460(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionInfoCommon_v1460* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->s_SearchDeltaP_r14 = (CellReselectionInfoCommon_v1460_s_SearchDeltaP_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionInfoCommon_v1460(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionInfoHSDN_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionInfoHSDN_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->cellEquivalentSize_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionInfoHSDN_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerClass14dBm_Offset_r15 = (CellSelectionInfoCE_v1530_powerClass14dBm_Offset_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CellReselectionSubPriority_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionServingFreqInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionServingFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellReselectionPriority_CellReselectionServingFreqInfo_v1610_altCellReselectionPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionPriority_r16);
	_serSysDecCellReselectionSubPriority_r13_e_CellReselectionServingFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionSubPriority_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionServingFreqInfo_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType3(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType3_cellReselectionInfoCommon(_buffer, _size, _lidx, &p->cellReselectionInfoCommon);
	_serSysDecSystemInformationBlockType3_cellReselectionServingFreqInfo(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo);
	_serSysDecSystemInformationBlockType3_intraFreqCellReselectionInfo(_buffer, _size, _lidx, &p->intraFreqCellReselectionInfo);
	_serSysDecOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType3_s_IntraSearch_v920_s_IntraSearch_v920_Optional(_buffer, _size, _lidx, &p->s_IntraSearch_v920);
	_serSysDecSystemInformationBlockType3_s_NonIntraSearch_v920_s_NonIntraSearch_v920_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearch_v920);
	_serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMin_r9_Optional(_buffer, _size, _lidx, &p->q_QualMin_r9);
	_serSysDecReselectionThresholdQ_r9_SystemInformationBlockType3_threshServingLowQ_r9_Optional(_buffer, _size, _lidx, &p->threshServingLowQ_r9);
	_serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMinWB_r11_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r11);
	_serSysDecQ_QualMin_r9_SystemInformationBlockType3_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);
	_serSysDecCellReselectionServingFreqInfo_v1310_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1310_Optional(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo_v1310);
	_serSysDecRedistributionServingInfo_r13_SystemInformationBlockType3_redistributionServingInfo_r13_Optional(_buffer, _size, _lidx, &p->redistributionServingInfo_r13);
	_serSysDecCellSelectionInfoCE_r13_SystemInformationBlockType3_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysDecT_ReselectionEUTRA_CE_r13_SystemInformationBlockType3_t_ReselectionEUTRA_CE_r13_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_CE_r13);
	_serSysDecCellSelectionInfoCE1_r13_SystemInformationBlockType3_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);
	_serSysDecCellSelectionInfoCE1_v1360_SystemInformationBlockType3_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);
	_serSysDecCellReselectionInfoCommon_v1460_SystemInformationBlockType3_cellReselectionInfoCommon_v1460_Optional(_buffer, _size, _lidx, &p->cellReselectionInfoCommon_v1460);
	_serSysDecCellReselectionInfoHSDN_r15_SystemInformationBlockType3_cellReselectionInfoHSDN_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionInfoHSDN_r15);
	_serSysDecCellSelectionInfoCE_v1530_SystemInformationBlockType3_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);
	_serSysDecSystemInformationBlockType3_crs_IntfMitigNeighCellsCE_r15_e_crs_IntfMitigNeighCellsCE_r15_Optional(_buffer, _size, _lidx, &p->crs_IntfMitigNeighCellsCE_r15);
	_serSysDecCellReselectionServingFreqInfo_v1610_SystemInformationBlockType3_cellReselectionServingFreqInfo_v1610_Optional(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqNeighCellInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct IntraFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_OffsetCell = (Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct IntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct IntraFreqNeighCellInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecIntraFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdRange_range_e_range_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhysCellIdRange_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PhysCellIdRange_range_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdRange(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhysCellIdRange* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->start, &_buffer[*_lidx], _lidx);
	_serSysDecPhysCellIdRange_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct IntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct IntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRSS_ConfigCarrierInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RSS_ConfigCarrierInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->narrowbandIndex_r16.d, &_buffer[*_lidx], _lidx);
	p->narrowbandIndex_r16.v = serMalloc(_mem, p->narrowbandIndex_r16.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->narrowbandIndex_r16.d; i2++) {
		NTOH_8(p->narrowbandIndex_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeOffsetGranularity_r16 = (RSS_ConfigCarrierInfo_r16_timeOffsetGranularity_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRSS_ConfigCarrierInfo_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqNeighCellInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct IntraFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->rss_MeasPowerBias_r16 = (RSS_MeasPowerBias_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct IntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct IntraFreqNeighCellInfo_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecIntraFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType4(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType4* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqNeighCellList);
	_serSysDecIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqBlackCellList);
	_serSysDecPhysCellIdRange_SystemInformationBlockType4_csg_PhysCellIdRange_Optional(_buffer, _size, _lidx, &p->csg_PhysCellIdRange);
	_serSysDecOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqNeighHSDN_CellList_r15);
	_serSysDecRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(_buffer, _size, _lidx, _mem, &p->rss_ConfigCarrierInfo_r16);
	_serSysDecIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqNeighCellList_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_InterFreqCarrierFreqInfo_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_InterFreqCarrierFreqInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighCellInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_OffsetCell = (Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqNeighCellInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecInterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_threshX_Q_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_threshX_Q_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecInterFreqCarrierFreqInfo_threshX_Q_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->dl_CarrierFreq, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serSysDecP_Max_InterFreqCarrierFreqInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	NTOH_8(p->t_ReselectionEUTRA, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_InterFreqCarrierFreqInfo_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedMeasBandwidth = (AllowedMeasBandwidth_e)_tmp;
	}
	NTOH_8(p->presenceAntennaPort1, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->neighCellConfig[i3], &_buffer[*_lidx], _lidx);
	}
	_serSysDecQ_OffsetRange_e_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq);
	_serSysDecInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighCellList);
	_serSysDecInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(_buffer, _size, _lidx, _mem, &p->interFreqBlackCellList);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMin_r9_Optional(_buffer, _size, _lidx, &p->q_QualMin_r9);
	_serSysDecInterFreqCarrierFreqInfo_threshX_Q_r9_threshX_Q_r9_Optional(_buffer, _size, _lidx, &p->threshX_Q_r9);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_q_QualMinWB_r11_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (InterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecInterFreqCarrierFreqInfo_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_v1250_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1250));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqNeighCellInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecInterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_r12_threshX_Q_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_r12_threshX_Q_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecInterFreqCarrierFreqInfo_r12_threshX_Q_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicator_r11));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (InterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Q_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->dl_CarrierFreq_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin_r12, &_buffer[*_lidx], _lidx);
	_serSysDecP_Max_InterFreqCarrierFreqInfo_r12_p_Max_r12_Optional(_buffer, _size, _lidx, &p->p_Max_r12);
	NTOH_8(p->t_ReselectionEUTRA_r12, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_InterFreqCarrierFreqInfo_r12_t_ReselectionEUTRA_SF_r12_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF_r12);
	NTOH_8(p->threshX_High_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low_r12, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedMeasBandwidth_r12 = (AllowedMeasBandwidth_e)_tmp;
	}
	NTOH_8(p->presenceAntennaPort1_r12, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->neighCellConfig_r12[i3], &_buffer[*_lidx], _lidx);
	}
	_serSysDecQ_OffsetRange_e_InterFreqCarrierFreqInfo_r12_q_OffsetFreq_r12_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq_r12);
	_serSysDecInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighCellList_r12);
	_serSysDecInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(_buffer, _size, _lidx, _mem, &p->interFreqBlackCellList_r12);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMin_r12_Optional(_buffer, _size, _lidx, &p->q_QualMin_r12);
	_serSysDecInterFreqCarrierFreqInfo_r12_threshX_Q_r12_threshX_Q_r12_Optional(_buffer, _size, _lidx, &p->threshX_Q_r12);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinWB_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinWB_r12);
	_serSysDecMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(_buffer, _size, _lidx, _mem, &p->multiBandInfoList_r12);
	_serSysDecInterFreqCarrierFreqInfo_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);
	_serSysDecQ_QualMin_r9_InterFreqCarrierFreqInfo_r12_q_QualMinRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->q_QualMinRSRQ_OnAllSymbols_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNS_PmaxValue_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NS_PmaxValue_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecP_Max_NS_PmaxValue_r10_additionalPmax_r10_Optional(_buffer, _size, _lidx, &p->additionalPmax_r10);
	NTOH_8(p->additionalSpectrumEmission, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct NS_PmaxValue_r10));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecNS_PmaxValue_r10(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(NS_PmaxList_r10));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_32(p->v.v[i3].d, &_buffer[*_lidx], _lidx);
		p->v.v[i3].v = serMalloc(_mem, p->v.v[i3].d * sizeof(struct NS_PmaxValue_r10));
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysDecNS_PmaxValue_r10(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v10j0(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo_v10j0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(_buffer, _size, _lidx, _mem, &p->freqBandInfo_r10);
	_serSysDecMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(_buffer, _size, _lidx, _mem, &p->multiBandInfoList_v10j0);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v10j0));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v10j0(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CellReselectionSubPriority_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionNeighCell_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RedistributionNeighCell_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->redistributionFactorCell_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct RedistributionNeighCell_r13));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecRedistributionNeighCell_r13(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionInterFreqInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RedistributionInterFreqInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRedistributionFactor_r13_RedistributionInterFreqInfo_r13_redistributionFactorFreq_r13_Optional(_buffer, _size, _lidx, &p->redistributionFactorFreq_r13);
	_serSysDecRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(_buffer, _size, _lidx, _mem, &p->redistributionNeighCellList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRedistributionInterFreqInfo_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecT_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct T_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1310_cellReselectionSubPriority_r13_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority_r13);
	_serSysDecRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(_buffer, _size, _lidx, _mem, &p->redistributionInterFreqInfo_r13);
	_serSysDecCellSelectionInfoCE_r13_InterFreqCarrierFreqInfo_v1310_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysDecT_ReselectionEUTRA_CE_r13_InterFreqCarrierFreqInfo_v1310_t_ReselectionEUTRA_CE_r13_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_CE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1310));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1310(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1310));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1310(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1350(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_v1350* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellSelectionInfoCE1_r13_InterFreqCarrierFreqInfo_v1350_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1350));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1350(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1350));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1350(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1360(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqCarrierFreqInfo_v1360* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellSelectionInfoCE1_v1360_InterFreqCarrierFreqInfo_v1360_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1360));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1360(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->hsdn_Indication_r15, &_buffer[*_lidx], _lidx);
	_serSysDecInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighHSDN_CellList_r15);
	_serSysDecCellSelectionInfoCE_v1530_InterFreqCarrierFreqInfo_v1530_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1530));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1530(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1530));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1530(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierEUTRA_r15_qualityThreshold_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasIdleCarrierEUTRA_r15_qualityThreshold_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_Range_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRP_Threshold_r15_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_r15);
	_serSysDecRSRQ_Range_r13_MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_idleRSRQ_Threshold_r15_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasIdleCarrierEUTRA_r15_qualityThreshold_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierEUTRA_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleCarrierEUTRA_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq_r15, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedMeasBandwidth_r15 = (AllowedMeasBandwidth_e)_tmp;
	}
	_serSysDecCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(_buffer, _size, _lidx, _mem, &p->validityArea_r15);
	_serSysDecCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(_buffer, _size, _lidx, _mem, &p->measCellList_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantities = (MeasIdleCarrierEUTRA_r15_reportQuantities_e)_tmp;
	}
	_serSysDecMeasIdleCarrierEUTRA_r15_qualityThreshold_r15_qualityThreshold_r15_Optional(_buffer, _size, _lidx, &p->qualityThreshold_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleConfigSIB_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleConfigSIB_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->measIdleCarrierListEUTRA_r15.d, &_buffer[*_lidx], _lidx);
	p->measIdleCarrierListEUTRA_r15.v = serMalloc(_mem, p->measIdleCarrierListEUTRA_r15.d * sizeof(struct MeasIdleCarrierEUTRA_r15));
	for (size_t i2 = 0; i2 < p->measIdleCarrierListEUTRA_r15.d; i2++) {
		_serSysDecMeasIdleCarrierEUTRA_r15(_buffer, _size, _lidx, _mem, &p->measIdleCarrierListEUTRA_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasIdleConfigSIB_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CellReselectionSubPriority_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRSS_ConfigCarrierInfo_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighCellInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct InterFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->rss_MeasPowerBias_r16 = (RSS_MeasPowerBias_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqNeighCellInfo_v1610));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecInterFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellReselectionPriority_InterFreqCarrierFreqInfo_v1610_altCellReselectionPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionPriority_r16);
	_serSysDecCellReselectionSubPriority_r13_e_InterFreqCarrierFreqInfo_v1610_altCellReselectionSubPriority_r16_Optional(_buffer, _size, _lidx, &p->altCellReselectionSubPriority_r16);
	_serSysDecRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(_buffer, _size, _lidx, _mem, &p->rss_ConfigCarrierInfo_r16);
	_serSysDecInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighCellList_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct InterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct InterFreqCarrierFreqInfo_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicatorNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdRangeNR_r16_range_e_range_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhysCellIdRangeNR_r16_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PhysCellIdRangeNR_r16_range_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdRangeNR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PhysCellIdRangeNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->start, &_buffer[*_lidx], _lidx);
	_serSysDecPhysCellIdRangeNR_r16_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PhysCellIdRangeNR_r16));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPhysCellIdRangeNR_r16(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierNR_r16_qualityThresholdNR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasIdleCarrierNR_r16_qualityThresholdNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRP_ThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_ThresholdNR_r16);
	_serSysDecRSRQ_RangeNR_r15_MeasIdleCarrierNR_r16_qualityThresholdNR_r16_idleRSRQ_ThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_ThresholdNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasIdleCarrierNR_r16_qualityThresholdNR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecThresholdListNR_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ThresholdListNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_RangeNR_r15_ThresholdListNR_r15_nr_RSRP_r15_Optional(_buffer, _size, _lidx, &p->nr_RSRP_r15);
	_serSysDecRSRQ_RangeNR_r15_ThresholdListNR_r15_nr_RSRQ_r15_Optional(_buffer, _size, _lidx, &p->nr_RSRQ_r15);
	_serSysDecRS_SINR_RangeNR_r15_ThresholdListNR_r15_nr_SINR_r15_Optional(_buffer, _size, _lidx, &p->nr_SINR_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecThresholdListNR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB_NR_r15_periodicityAndOffset_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MTC_SSB_NR_r15_periodicityAndOffset_r15_Value* p, enum MTC_SSB_NR_r15_periodicityAndOffset_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf5_r15) {
		NTOH_8(p->sf5_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf10_r15) {
		NTOH_8(p->sf10_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf20_r15) {
		NTOH_8(p->sf20_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf40_r15) {
		NTOH_8(p->sf40_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf80_r15) {
		NTOH_8(p->sf80_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MTC_SSB_NR_r15_periodicityAndOffset_r15_sf160_r15) {
		NTOH_8(p->sf160_r15, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB_NR_r15_periodicityAndOffset_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MTC_SSB_NR_r15_periodicityAndOffset_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MTC_SSB_NR_r15_periodicityAndOffset_r15_Sel)_tmp;
	}
	_serSysDecMTC_SSB_NR_r15_periodicityAndOffset_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB_NR_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MTC_SSB_NR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMTC_SSB_NR_r15_periodicityAndOffset_r15(_buffer, _size, _lidx, &p->periodicityAndOffset_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssb_Duration_r15 = (MTC_SSB_NR_r15_ssb_Duration_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMTC_SSB_NR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSSB_ToMeasure_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SSB_ToMeasure_r15_Value* p, enum SSB_ToMeasure_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SSB_ToMeasure_r15_shortBitmap_r15) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			NTOH_8(p->shortBitmap_r15[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SSB_ToMeasure_r15_mediumBitmap_r15) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			NTOH_8(p->mediumBitmap_r15[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SSB_ToMeasure_r15_longBitmap_r15) {
		for (size_t i3 = 0; i3 < 64; i3++) {
			NTOH_8(p->longBitmap_r15[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSSB_ToMeasure_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SSB_ToMeasure_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SSB_ToMeasure_r15_Sel)_tmp;
	}
	_serSysDecSSB_ToMeasure_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSSB_ToMeasure_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RSSI_Measurement_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SS_RSSI_Measurement_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->measurementSlots_r15.d, &_buffer[*_lidx], _lidx);
	p->measurementSlots_r15.v = serMalloc(_mem, p->measurementSlots_r15.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->measurementSlots_r15.d; i3++) {
		NTOH_8(p->measurementSlots_r15.v[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->endSymbol_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSS_RSSI_Measurement_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMaxRS_IndexCellQualNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_maxRS_IndexCellQual_r16_Optional(_buffer, _size, _lidx, &p->maxRS_IndexCellQual_r16);
	_serSysDecThresholdListNR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_threshRS_Index_r16_Optional(_buffer, _size, _lidx, &p->threshRS_Index_r16);
	_serSysDecMTC_SSB_NR_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_measTimingConfig_r16_Optional(_buffer, _size, _lidx, &p->measTimingConfig_r16);
	_serSysDecSSB_ToMeasure_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r16);
	NTOH_8(p->deriveSSB_IndexFromCell_r16, &_buffer[*_lidx], _lidx);
	_serSysDecSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(_buffer, _size, _lidx, _mem, &p->ss_RSSI_Measurement_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBeamMeasConfigIdleNR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BeamMeasConfigIdleNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantityRS_IndexNR_r16 = (BeamMeasConfigIdleNR_r16_reportQuantityRS_IndexNR_r16_e)_tmp;
	}
	NTOH_8(p->maxReportRS_Index_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->reportRS_IndexResultsNR_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBeamMeasConfigIdleNR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleCarrierNR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleCarrierNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreqNR_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subcarrierSpacingSSB_r16 = (MeasIdleCarrierNR_r16_subcarrierSpacingSSB_r16_e)_tmp;
	}
	_serSysDecMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serSysDecCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(_buffer, _size, _lidx, _mem, &p->measCellListNR_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantitiesNR_r16 = (MeasIdleCarrierNR_r16_reportQuantitiesNR_r16_e)_tmp;
	}
	_serSysDecMeasIdleCarrierNR_r16_qualityThresholdNR_r16_qualityThresholdNR_r16_Optional(_buffer, _size, _lidx, &p->qualityThresholdNR_r16);
	_serSysDecMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(_buffer, _size, _lidx, _mem, &p->ssb_MeasConfig_r16);
	_serSysDecBeamMeasConfigIdleNR_r16_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(_buffer, _size, _lidx, &p->beamMeasConfigIdle_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleConfigSIB_NR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleConfigSIB_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->measIdleCarrierListNR_r16.d, &_buffer[*_lidx], _lidx);
	p->measIdleCarrierListNR_r16.v = serMalloc(_mem, p->measIdleCarrierListNR_r16.d * sizeof(struct MeasIdleCarrierNR_r16));
	for (size_t i2 = 0; i2 < p->measIdleCarrierListNR_r16.d; i2++) {
		_serSysDecMeasIdleCarrierNR_r16(_buffer, _size, _lidx, _mem, &p->measIdleCarrierListNR_r16.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasIdleConfigSIB_NR_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType5(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType5* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->interFreqCarrierFreqList.d, &_buffer[*_lidx], _lidx);
	p->interFreqCarrierFreqList.v = serMalloc(_mem, p->interFreqCarrierFreqList.d * sizeof(struct InterFreqCarrierFreqInfo));
	for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
		_serSysDecInterFreqCarrierFreqInfo(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList.v[i2]);
	}
	_serSysDecOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1250);
	_serSysDecInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_r12);
	_serSysDecInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1280);
	_serSysDecInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1310);
	_serSysDecInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1310);
	_serSysDecInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1350);
	_serSysDecInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1350);
	_serSysDecInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1360);
	_serSysDecUint8_t_SystemInformationBlockType5_scptm_FreqOffset_r14_Optional(_buffer, _size, _lidx, &p->scptm_FreqOffset_r14);
	_serSysDecInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1530);
	_serSysDecInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1530);
	_serSysDecMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(_buffer, _size, _lidx, _mem, &p->measIdleConfigSIB_r15);
	_serSysDecInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1610);
	_serSysDecInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqListExt_v1610);
	_serSysDecMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(_buffer, _size, _lidx, _mem, &p->measIdleConfigSIB_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_threshX_Q_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD_threshX_Q_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCarrierFreqUTRA_FDD_threshX_Q_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->carrierFreq, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_CarrierFreqUTRA_FDD_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_MaxUTRA, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_QualMin, &_buffer[*_lidx], _lidx);
	_serSysDecCarrierFreqUTRA_FDD_threshX_Q_r9_threshX_Q_r9_Optional(_buffer, _size, _lidx, &p->threshX_Q_r9);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqUTRA_FDD));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqUTRA_FDD(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_TDD(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_TDD* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->carrierFreq, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_CarrierFreqUTRA_TDD_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_MaxUTRA, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqUTRA_TDD));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqUTRA_TDD(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqInfoUTRA_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqInfoUTRA_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCarrierFreqInfoUTRA_v1250_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqInfoUTRA_v1250));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqInfoUTRA_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqInfoUTRA_v1250));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqInfoUTRA_v1250(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct FreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicator_UTRA_FDD));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_FDD_Ext_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqUTRA_FDD_Ext_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->carrierFreq_r12, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_CarrierFreqUTRA_FDD_Ext_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	NTOH_8(p->threshX_High_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_MaxUTRA_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_QualMin_r12, &_buffer[*_lidx], _lidx);
	_serSysDecCarrierFreqUTRA_FDD_Ext_r12_threshX_Q_r12_threshX_Q_r12_Optional(_buffer, _size, _lidx, &p->threshX_Q_r12);
	_serSysDecFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(_buffer, _size, _lidx, _mem, &p->multiBandInfoList_r12);
	_serSysDecCarrierFreqUTRA_FDD_Ext_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqUTRA_FDD_Ext_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqUTRA_FDD_Ext_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqUTRA_TDD_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqUTRA_TDD_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->carrierFreq_r12, &_buffer[*_lidx], _lidx);
	_serSysDecCellReselectionPriority_CarrierFreqUTRA_TDD_r12_cellReselectionPriority_r12_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r12);
	NTOH_8(p->threshX_High_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_MaxUTRA_r12, &_buffer[*_lidx], _lidx);
	_serSysDecCarrierFreqUTRA_TDD_r12_reducedMeasPerformance_r12_e_reducedMeasPerformance_r12_Optional(_buffer, _size, _lidx, &p->reducedMeasPerformance_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqUTRA_TDD_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqUTRA_TDD_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType6(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType6* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_FDD);
	_serSysDecCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_TDD);
	NTOH_8(p->t_ReselectionUTRA, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_SystemInformationBlockType6_t_ReselectionUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionUTRA_SF);
	_serSysDecOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_FDD_v1250);
	_serSysDecCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_TDD_v1250);
	_serSysDecCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_FDD_Ext_r12);
	_serSysDecCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListUTRA_TDD_Ext_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->arfcn_Spacing, &_buffer[*_lidx], _lidx);
	NTOH_8(p->numberOfFollowingARFCNs, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsGERAN_followingARFCNs_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CarrierFreqsGERAN_followingARFCNs_Value* p, enum CarrierFreqsGERAN_followingARFCNs_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CarrierFreqsGERAN_followingARFCNs_explicitListOfARFCNs) {
		NTOH_32(p->explicitListOfARFCNs.d, &_buffer[*_lidx], _lidx);
		p->explicitListOfARFCNs.v = serMalloc(_mem, p->explicitListOfARFCNs.d * sizeof(ARFCN_ValueGERAN));
		for (size_t i3 = 0; i3 < p->explicitListOfARFCNs.d; i3++) {
			NTOH_16(p->explicitListOfARFCNs.v[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == CarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs) {
		_serSysDecCarrierFreqsGERAN_followingARFCNs_equallySpacedARFCNs(_buffer, _size, _lidx, &p->equallySpacedARFCNs);
	}
	if (d == CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs) {
		NTOH_32(p->variableBitMapOfARFCNs.d, &_buffer[*_lidx], _lidx);
		p->variableBitMapOfARFCNs.v = serMalloc(_mem, p->variableBitMapOfARFCNs.d * sizeof(OCTET_STRING_ELEMENT));
		for (size_t i3 = 0; i3 < p->variableBitMapOfARFCNs.d; i3++) {
			NTOH_8(p->variableBitMapOfARFCNs.v[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsGERAN_followingARFCNs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqsGERAN_followingARFCNs* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CarrierFreqsGERAN_followingARFCNs_Sel)_tmp;
	}
	_serSysDecCarrierFreqsGERAN_followingARFCNs_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsGERAN(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqsGERAN* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->startingARFCN, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->bandIndicator = (BandIndicatorGERAN_e)_tmp;
	}
	_serSysDecCarrierFreqsGERAN_followingARFCNs(_buffer, _size, _lidx, _mem, &p->followingARFCNs);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsInfoGERAN_commonInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqsInfoGERAN_commonInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellReselectionPriority_CarrierFreqsInfoGERAN_commonInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	for (size_t i3 = 0; i3 < 8; i3++) {
		NTOH_8(p->ncc_Permitted[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_CarrierFreqsInfoGERAN_commonInfo_p_MaxGERAN_Optional(_buffer, _size, _lidx, &p->p_MaxGERAN);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsInfoGERAN(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqsInfoGERAN* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCarrierFreqsGERAN(_buffer, _size, _lidx, _mem, &p->carrierFreqs);
	_serSysDecCarrierFreqsInfoGERAN_commonInfo(_buffer, _size, _lidx, &p->commonInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqsInfoGERAN));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqsInfoGERAN(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType7(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType7* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->t_ReselectionGERAN, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_SystemInformationBlockType7_t_ReselectionGERAN_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionGERAN_SF);
	_serSysDecCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqsInfoList);
	_serSysDecOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemTimeInfoCDMA2000_cdma_SystemTime_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemTimeInfoCDMA2000_cdma_SystemTime_Value* p, enum SystemTimeInfoCDMA2000_cdma_SystemTime_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemTimeInfoCDMA2000_cdma_SystemTime_synchronousSystemTime) {
		for (size_t i2 = 0; i2 < 39; i2++) {
			NTOH_8(p->synchronousSystemTime[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SystemTimeInfoCDMA2000_cdma_SystemTime_asynchronousSystemTime) {
		for (size_t i2 = 0; i2 < 49; i2++) {
			NTOH_8(p->asynchronousSystemTime[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemTimeInfoCDMA2000_cdma_SystemTime(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemTimeInfoCDMA2000_cdma_SystemTime* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemTimeInfoCDMA2000_cdma_SystemTime_Sel)_tmp;
	}
	_serSysDecSystemTimeInfoCDMA2000_cdma_SystemTime_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemTimeInfoCDMA2000(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemTimeInfoCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->cdma_EUTRA_Synchronisation, &_buffer[*_lidx], _lidx);
	_serSysDecSystemTimeInfoCDMA2000_cdma_SystemTime(_buffer, _size, _lidx, &p->cdma_SystemTime);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemTimeInfoCDMA2000(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType8_searchWindowSize_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType8_searchWindowSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(PreRegistrationZoneIdHRPD));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPreRegistrationInfoHRPD(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PreRegistrationInfoHRPD* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->preRegistrationAllowed, &_buffer[*_lidx], _lidx);
	_serSysDecPreRegistrationZoneIdHRPD_PreRegistrationInfoHRPD_preRegistrationZoneId_Optional(_buffer, _size, _lidx, &p->preRegistrationZoneId);
	_serSysDecSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(_buffer, _size, _lidx, _mem, &p->secondaryPreRegistrationZoneIdList);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBandClassInfoCDMA2000(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BandClassInfoCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->bandClass = (BandclassCDMA2000_e)_tmp;
	}
	_serSysDecCellReselectionPriority_BandClassInfoCDMA2000_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellsPerBandclassCDMA2000(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellsPerBandclassCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->arfcn, &_buffer[*_lidx], _lidx);
	NTOH_32(p->physCellIdList.d, &_buffer[*_lidx], _lidx);
	p->physCellIdList.v = serMalloc(_mem, p->physCellIdList.d * sizeof(PhysCellIdCDMA2000));
	for (size_t i4 = 0; i4 < p->physCellIdList.d; i4++) {
		NTOH_16(p->physCellIdList.v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellCDMA2000(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->bandClass = (BandclassCDMA2000_e)_tmp;
	}
	NTOH_32(p->neighCellsPerFreqList.d, &_buffer[*_lidx], _lidx);
	p->neighCellsPerFreqList.v = serMalloc(_mem, p->neighCellsPerFreqList.d * sizeof(struct NeighCellsPerBandclassCDMA2000));
	for (size_t i3 = 0; i3 < p->neighCellsPerFreqList.d; i3++) {
		_serSysDecNeighCellsPerBandclassCDMA2000(_buffer, _size, _lidx, _mem, &p->neighCellsPerFreqList.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->bandClassList.d, &_buffer[*_lidx], _lidx);
	p->bandClassList.v = serMalloc(_mem, p->bandClassList.d * sizeof(struct BandClassInfoCDMA2000));
	for (size_t i2 = 0; i2 < p->bandClassList.d; i2++) {
		_serSysDecBandClassInfoCDMA2000(_buffer, _size, _lidx, &p->bandClassList.v[i2]);
	}
	NTOH_32(p->neighCellList.d, &_buffer[*_lidx], _lidx);
	p->neighCellList.v = serMalloc(_mem, p->neighCellList.d * sizeof(struct NeighCellCDMA2000));
	for (size_t i2 = 0; i2 < p->neighCellList.d; i2++) {
		_serSysDecNeighCellCDMA2000(_buffer, _size, _lidx, _mem, &p->neighCellList.v[i2]);
	}
	NTOH_8(p->t_ReselectionCDMA2000, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_CellReselectionParametersCDMA2000_t_ReselectionCDMA2000_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionCDMA2000_SF);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8_parametersHRPD(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType8_parametersHRPD* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPreRegistrationInfoHRPD(_buffer, _size, _lidx, _mem, &p->preRegistrationInfoHRPD);
	_serSysDecCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParametersHRPD);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType8_parametersHRPD(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 15; i2++) {
		NTOH_8(p->sid[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->nid[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->multipleSID, &_buffer[*_lidx], _lidx);
	NTOH_8(p->multipleNID, &_buffer[*_lidx], _lidx);
	NTOH_8(p->homeReg, &_buffer[*_lidx], _lidx);
	NTOH_8(p->foreignSIDReg, &_buffer[*_lidx], _lidx);
	NTOH_8(p->foreignNIDReg, &_buffer[*_lidx], _lidx);
	NTOH_8(p->parameterReg, &_buffer[*_lidx], _lidx);
	NTOH_8(p->powerUpReg, &_buffer[*_lidx], _lidx);
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->registrationPeriod[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 12; i2++) {
		NTOH_8(p->registrationZone[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 3; i2++) {
		NTOH_8(p->totalZone[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 3; i2++) {
		NTOH_8(p->zoneTimer[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSFB_RegistrationParam1XRTT(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 42; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8_parameters1XRTT(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType8_parameters1XRTT* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSFB_RegistrationParam1XRTT_SystemInformationBlockType8_parameters1XRTT_csfb_RegistrationParam1XRTT_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT);
	_serSysDecB42_SystemInformationBlockType8_parameters1XRTT_longCodeState1XRTT_Optional(_buffer, _size, _lidx, &p->longCodeState1XRTT);
	_serSysDecCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParameters1XRTT);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType8_parameters1XRTT(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellsPerBandclassCDMA2000_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellsPerBandclassCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->physCellIdList_v920.d, &_buffer[*_lidx], _lidx);
	p->physCellIdList_v920.v = serMalloc(_mem, p->physCellIdList_v920.d * sizeof(PhysCellIdCDMA2000));
	for (size_t i4 = 0; i4 < p->physCellIdList_v920.d; i4++) {
		NTOH_16(p->physCellIdList_v920.v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellCDMA2000_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->neighCellsPerFreqList_v920.d, &_buffer[*_lidx], _lidx);
	p->neighCellsPerFreqList_v920.v = serMalloc(_mem, p->neighCellsPerFreqList_v920.d * sizeof(struct NeighCellsPerBandclassCDMA2000_v920));
	for (size_t i3 = 0; i3 < p->neighCellsPerFreqList_v920.d; i3++) {
		_serSysDecNeighCellsPerBandclassCDMA2000_v920(_buffer, _size, _lidx, _mem, &p->neighCellsPerFreqList_v920.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->neighCellList_v920.d, &_buffer[*_lidx], _lidx);
	p->neighCellList_v920.v = serMalloc(_mem, p->neighCellList_v920.d * sizeof(struct NeighCellCDMA2000_v920));
	for (size_t i2 = 0; i2 < p->neighCellList_v920.d; i2++) {
		_serSysDecNeighCellCDMA2000_v920(_buffer, _size, _lidx, _mem, &p->neighCellList_v920.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000_v920(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000_v920(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerDownReg_r9 = (CSFB_RegistrationParam1XRTT_v920_powerDownReg_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSFB_RegistrationParam1XRTT_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig1XRTT_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig1XRTT_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ac_Barring0to9_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring10_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring11_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring12_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring13_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring14_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_Barring15_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_BarringMsg_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_BarringReg_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ac_BarringEmg_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig1XRTT_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType8_csfb_DualRxTxSupport_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_systemTimeInfo_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ParametersCDMA2000_r11_systemTimeInfo_r11_Value* p, enum ParametersCDMA2000_r11_systemTimeInfo_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ParametersCDMA2000_r11_systemTimeInfo_r11_explicitValue) {
		_serSysDecSystemTimeInfoCDMA2000(_buffer, _size, _lidx, &p->explicitValue);
	}
	if (d == ParametersCDMA2000_r11_systemTimeInfo_r11_defaultValue) {
		NTOH_8(p->defaultValue, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_systemTimeInfo_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ParametersCDMA2000_r11_systemTimeInfo_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ParametersCDMA2000_r11_systemTimeInfo_r11_Sel)_tmp;
	}
	_serSysDecParametersCDMA2000_r11_systemTimeInfo_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecParametersCDMA2000_r11_systemTimeInfo_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellsPerBandclassCDMA2000_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellsPerBandclassCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->arfcn, &_buffer[*_lidx], _lidx);
	NTOH_32(p->physCellIdList_r11.d, &_buffer[*_lidx], _lidx);
	p->physCellIdList_r11.v = serMalloc(_mem, p->physCellIdList_r11.d * sizeof(PhysCellIdCDMA2000));
	for (size_t i5 = 0; i5 < p->physCellIdList_r11.d; i5++) {
		NTOH_16(p->physCellIdList_r11.v[i5], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNeighCellCDMA2000_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NeighCellCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->bandClass = (BandclassCDMA2000_e)_tmp;
	}
	NTOH_32(p->neighFreqInfoList_r11.d, &_buffer[*_lidx], _lidx);
	p->neighFreqInfoList_r11.v = serMalloc(_mem, p->neighFreqInfoList_r11.d * sizeof(struct NeighCellsPerBandclassCDMA2000_r11));
	for (size_t i4 = 0; i4 < p->neighFreqInfoList_r11.d; i4++) {
		_serSysDecNeighCellsPerBandclassCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->neighFreqInfoList_r11.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->bandClassList.d, &_buffer[*_lidx], _lidx);
	p->bandClassList.v = serMalloc(_mem, p->bandClassList.d * sizeof(struct BandClassInfoCDMA2000));
	for (size_t i3 = 0; i3 < p->bandClassList.d; i3++) {
		_serSysDecBandClassInfoCDMA2000(_buffer, _size, _lidx, &p->bandClassList.v[i3]);
	}
	NTOH_32(p->neighCellList_r11.d, &_buffer[*_lidx], _lidx);
	p->neighCellList_r11.v = serMalloc(_mem, p->neighCellList_r11.d * sizeof(struct NeighCellCDMA2000_r11));
	for (size_t i3 = 0; i3 < p->neighCellList_r11.d; i3++) {
		_serSysDecNeighCellCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->neighCellList_r11.v[i3]);
	}
	NTOH_8(p->t_ReselectionCDMA2000, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_CellReselectionParametersCDMA2000_r11_t_ReselectionCDMA2000_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionCDMA2000_SF);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_parametersHRPD_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ParametersCDMA2000_r11_parametersHRPD_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPreRegistrationInfoHRPD(_buffer, _size, _lidx, _mem, &p->preRegistrationInfoHRPD_r11);
	_serSysDecCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParametersHRPD_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecParametersCDMA2000_r11_parametersHRPD_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSFB_RegistrationParam1XRTT(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSFB_RegistrationParam1XRTT_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 42; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellReselectionParametersCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAC_BarringConfig1XRTT_r9(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_parameters1XRTT_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ParametersCDMA2000_r11_parameters1XRTT_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSFB_RegistrationParam1XRTT_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_r11_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_r11);
	_serSysDecCSFB_RegistrationParam1XRTT_v920_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_RegistrationParam1XRTT_Ext_r11_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_Ext_r11);
	_serSysDecB42_ParametersCDMA2000_r11_parameters1XRTT_r11_longCodeState1XRTT_r11_Optional(_buffer, _size, _lidx, &p->longCodeState1XRTT_r11);
	_serSysDecCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParameters1XRTT_r11);
	_serSysDecAC_BarringConfig1XRTT_r9_ParametersCDMA2000_r11_parameters1XRTT_r11_ac_BarringConfig1XRTT_r11_Optional(_buffer, _size, _lidx, &p->ac_BarringConfig1XRTT_r11);
	_serSysDecBool_ParametersCDMA2000_r11_parameters1XRTT_r11_csfb_SupportForDualRxUEs_r11_Optional(_buffer, _size, _lidx, &p->csfb_SupportForDualRxUEs_r11);
	_serSysDecParametersCDMA2000_r11_parameters1XRTT_r11_csfb_DualRxTxSupport_r11_e_csfb_DualRxTxSupport_r11_Optional(_buffer, _size, _lidx, &p->csfb_DualRxTxSupport_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecParametersCDMA2000_r11_parameters1XRTT_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecParametersCDMA2000_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ParametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecParametersCDMA2000_r11_systemTimeInfo_r11_systemTimeInfo_r11_Optional(_buffer, _size, _lidx, &p->systemTimeInfo_r11);
	NTOH_8(p->searchWindowSize_r11, &_buffer[*_lidx], _lidx);
	_serSysDecParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(_buffer, _size, _lidx, _mem, &p->parametersHRPD_r11);
	_serSysDecParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(_buffer, _size, _lidx, _mem, &p->parameters1XRTT_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SIB8_PerPLMN_r11_parametersCDMA2000_r11_Value* p, enum SIB8_PerPLMN_r11_parametersCDMA2000_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SIB8_PerPLMN_r11_parametersCDMA2000_r11_explicitValue) {
		_serSysDecParametersCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->explicitValue);
	}
	if (d == SIB8_PerPLMN_r11_parametersCDMA2000_r11_defaultValue) {
		NTOH_8(p->defaultValue, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSIB8_PerPLMN_r11_parametersCDMA2000_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SIB8_PerPLMN_r11_parametersCDMA2000_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SIB8_PerPLMN_r11_parametersCDMA2000_r11_Sel)_tmp;
	}
	_serSysDecSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSIB8_PerPLMN_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SIB8_PerPLMN_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_Identity_r11, &_buffer[*_lidx], _lidx);
	_serSysDecSIB8_PerPLMN_r11_parametersCDMA2000_r11(_buffer, _size, _lidx, _mem, &p->parametersCDMA2000_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SIB8_PerPLMN_r11));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSIB8_PerPLMN_r11(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType8(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType8* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemTimeInfoCDMA2000_SystemInformationBlockType8_systemTimeInfo_Optional(_buffer, _size, _lidx, &p->systemTimeInfo);
	_serSysDecUint8_t_SystemInformationBlockType8_searchWindowSize_Optional(_buffer, _size, _lidx, &p->searchWindowSize);
	_serSysDecSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(_buffer, _size, _lidx, _mem, &p->parametersHRPD);
	_serSysDecSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(_buffer, _size, _lidx, _mem, &p->parameters1XRTT);
	_serSysDecOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecBool_SystemInformationBlockType8_csfb_SupportForDualRxUEs_r9_Optional(_buffer, _size, _lidx, &p->csfb_SupportForDualRxUEs_r9);
	_serSysDecCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParametersHRPD_v920);
	_serSysDecCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(_buffer, _size, _lidx, _mem, &p->cellReselectionParameters1XRTT_v920);
	_serSysDecCSFB_RegistrationParam1XRTT_v920_SystemInformationBlockType8_csfb_RegistrationParam1XRTT_v920_Optional(_buffer, _size, _lidx, &p->csfb_RegistrationParam1XRTT_v920);
	_serSysDecAC_BarringConfig1XRTT_r9_SystemInformationBlockType8_ac_BarringConfig1XRTT_r9_Optional(_buffer, _size, _lidx, &p->ac_BarringConfig1XRTT_r9);
	_serSysDecSystemInformationBlockType8_csfb_DualRxTxSupport_r10_e_csfb_DualRxTxSupport_r10_Optional(_buffer, _size, _lidx, &p->csfb_DualRxTxSupport_r10);
	_serSysDecSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(_buffer, _size, _lidx, _mem, &p->sib8_PerPLMN_List_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(_buffer, _size, _lidx, _mem, &p->hnb_Name);
	_serSysDecOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecO50_SystemInformationBlockType10_dummy_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O50_SystemInformationBlockType10_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 50; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType10* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->warningType[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecO50_SystemInformationBlockType10_dummy_Optional(_buffer, _size, _lidx, &p->dummy);
	_serSysDecOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecO1_SystemInformationBlockType11_dataCodingScheme_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O1_SystemInformationBlockType11_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType11* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->warningMessageSegmentType = (SystemInformationBlockType11_warningMessageSegmentType_e)_tmp;
	}
	NTOH_8(p->warningMessageSegmentNumber, &_buffer[*_lidx], _lidx);
	NTOH_32(p->warningMessageSegment.d, &_buffer[*_lidx], _lidx);
	p->warningMessageSegment.v = serMalloc(_mem, p->warningMessageSegment.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		NTOH_8(p->warningMessageSegment.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecO1_SystemInformationBlockType11_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serSysDecOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecO1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType12_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType12_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier_r9[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber_r9[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->warningMessageSegmentType_r9 = (SystemInformationBlockType12_r9_warningMessageSegmentType_r9_e)_tmp;
	}
	NTOH_8(p->warningMessageSegmentNumber_r9, &_buffer[*_lidx], _lidx);
	NTOH_32(p->warningMessageSegment_r9.d, &_buffer[*_lidx], _lidx);
	p->warningMessageSegment_r9.v = serMalloc(_mem, p->warningMessageSegment_r9.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->warningMessageSegment_r9.d; i2++) {
		NTOH_8(p->warningMessageSegment_r9.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecO1_SystemInformationBlockType12_r9_dataCodingScheme_r9_Optional(_buffer, _size, _lidx, &p->dataCodingScheme_r9);
	_serSysDecOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(_buffer, _size, _lidx, _mem, &p->warningAreaCoordinatesSegment_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_mcch_Config_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_mcch_Config_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mcch_RepetitionPeriod_r9 = (MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_RepetitionPeriod_r9_e)_tmp;
	}
	NTOH_8(p->mcch_Offset_r9, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mcch_ModificationPeriod_r9 = (MBSFN_AreaInfo_r9_mcch_Config_r9_mcch_ModificationPeriod_r9_e)_tmp;
	}
	for (size_t i3 = 0; i3 < 6; i3++) {
		NTOH_8(p->sf_AllocInfo_r9[i3], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->signallingMCS_r9 = (MBSFN_AreaInfo_r9_mcch_Config_r9_signallingMCS_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_mcch_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_RepetitionPeriod_v1430_e_mcch_RepetitionPeriod_v1430_Optional(_buffer, _size, _lidx, &p->mcch_RepetitionPeriod_v1430);
	_serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_ModificationPeriod_v1430_e_mcch_ModificationPeriod_v1430_Optional(_buffer, _size, _lidx, &p->mcch_ModificationPeriod_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (MBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->mbsfn_AreaId_r9, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->non_MBSFNregionLength = (MBSFN_AreaInfo_r9_non_MBSFNregionLength_e)_tmp;
	}
	NTOH_8(p->notificationIndicator_r9, &_buffer[*_lidx], _lidx);
	_serSysDecMBSFN_AreaInfo_r9_mcch_Config_r9(_buffer, _size, _lidx, &p->mcch_Config_r9);
	_serSysDecMBSFN_AreaInfo_r9_mcch_Config_r14_mcch_Config_r14_Optional(_buffer, _size, _lidx, &p->mcch_Config_r14);
	_serSysDecMBSFN_AreaInfo_r9_subcarrierSpacingMBMS_r14_e_subcarrierSpacingMBMS_r14_Optional(_buffer, _size, _lidx, &p->subcarrierSpacingMBMS_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_NotificationConfig_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBMS_NotificationConfig_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->notificationRepetitionCoeff_r9 = (MBMS_NotificationConfig_r9_notificationRepetitionCoeff_r9_e)_tmp;
	}
	NTOH_8(p->notificationOffset_r9, &_buffer[*_lidx], _lidx);
	NTOH_8(p->notificationSF_Index_r9, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_NotificationConfig_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBMS_NotificationConfig_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->notificationSF_Index_v1430, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMBMS_NotificationConfig_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r16_mcch_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r16_mcch_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mcch_RepetitionPeriod_r16 = (MBSFN_AreaInfo_r16_mcch_Config_r16_mcch_RepetitionPeriod_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mcch_ModificationPeriod_r16 = (MBSFN_AreaInfo_r16_mcch_Config_r16_mcch_ModificationPeriod_r16_e)_tmp;
	}
	NTOH_8(p->mcch_Offset_r16, &_buffer[*_lidx], _lidx);
	for (size_t i3 = 0; i3 < 10; i3++) {
		NTOH_8(p->sf_AllocInfo_r16[i3], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->signallingMCS_r16 = (MBSFN_AreaInfo_r16_mcch_Config_r16_signallingMCS_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (MBSFN_AreaInfo_r16_timeSeparation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBSFN_AreaInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->mbsfn_AreaId_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->notificationIndicator_r16, &_buffer[*_lidx], _lidx);
	_serSysDecMBSFN_AreaInfo_r16_mcch_Config_r16(_buffer, _size, _lidx, &p->mcch_Config_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subcarrierSpacingMBMS_r16 = (MBSFN_AreaInfo_r16_subcarrierSpacingMBMS_r16_e)_tmp;
	}
	_serSysDecMBSFN_AreaInfo_r16_timeSeparation_r16_e_timeSeparation_r16_Optional(_buffer, _size, _lidx, &p->timeSeparation_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBSFN_AreaInfo_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBSFN_AreaInfo_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType13_r9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType13_r9* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->mbsfn_AreaInfoList_r9.d, &_buffer[*_lidx], _lidx);
	p->mbsfn_AreaInfoList_r9.v = serMalloc(_mem, p->mbsfn_AreaInfoList_r9.d * sizeof(struct MBSFN_AreaInfo_r9));
	for (size_t i2 = 0; i2 < p->mbsfn_AreaInfoList_r9.d; i2++) {
		_serSysDecMBSFN_AreaInfo_r9(_buffer, _size, _lidx, &p->mbsfn_AreaInfoList_r9.v[i2]);
	}
	_serSysDecMBMS_NotificationConfig_r9(_buffer, _size, _lidx, &p->notificationConfig_r9);
	_serSysDecOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecMBMS_NotificationConfig_v1430_SystemInformationBlockType13_r9_notificationConfig_v1430_Optional(_buffer, _size, _lidx, &p->notificationConfig_v1430);
	_serSysDecMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_AreaInfoList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecEAB_Config_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EAB_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->eab_Category_r11 = (EAB_Config_r11_eab_Category_r11_e)_tmp;
	}
	for (size_t i2 = 0; i2 < 10; i2++) {
		NTOH_8(p->eab_BarringBitmap_r11[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEAB_Config_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEAB_ConfigPLMN_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EAB_ConfigPLMN_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEAB_Config_r11_EAB_ConfigPLMN_r11_eab_Config_r11_Optional(_buffer, _size, _lidx, &p->eab_Config_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType14_r11_eab_Param_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemInformationBlockType14_r11_eab_Param_r11_Value* p, enum SystemInformationBlockType14_r11_eab_Param_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType14_r11_eab_Param_r11_eab_Common_r11) {
		_serSysDecEAB_Config_r11(_buffer, _size, _lidx, &p->eab_Common_r11);
	}
	if (d == SystemInformationBlockType14_r11_eab_Param_r11_eab_PerPLMN_List_r11) {
		NTOH_32(p->eab_PerPLMN_List_r11.d, &_buffer[*_lidx], _lidx);
		p->eab_PerPLMN_List_r11.v = serMalloc(_mem, p->eab_PerPLMN_List_r11.d * sizeof(struct EAB_ConfigPLMN_r11));
		for (size_t i2 = 0; i2 < p->eab_PerPLMN_List_r11.d; i2++) {
			_serSysDecEAB_ConfigPLMN_r11(_buffer, _size, _lidx, &p->eab_PerPLMN_List_r11.v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType14_r11_eab_Param_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType14_r11_eab_Param_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType14_r11_eab_Param_r11_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType14_r11_eab_Param_r11_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType14_r11_eab_Param_r11(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType14_r11_eab_PerRSRP_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType14_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType14_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(_buffer, _size, _lidx, _mem, &p->eab_Param_r11);
	_serSysDecOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType14_r11_eab_PerRSRP_r15_e_eab_PerRSRP_r15_Optional(_buffer, _size, _lidx, &p->eab_PerRSRP_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(MBMS_SAI_r11));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_16(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_SAI_InterFreq_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_SAI_InterFreq_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->dl_CarrierFreq_r11, &_buffer[*_lidx], _lidx);
	NTOH_32(p->mbms_SAI_List_r11.d, &_buffer[*_lidx], _lidx);
	p->mbms_SAI_List_r11.v = serMalloc(_mem, p->mbms_SAI_List_r11.d * sizeof(MBMS_SAI_r11));
	for (size_t i3 = 0; i3 < p->mbms_SAI_List_r11.d; i3++) {
		NTOH_16(p->mbms_SAI_List_r11.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBMS_SAI_InterFreq_r11));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBMS_SAI_InterFreq_r11(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicator_r11));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_SAI_InterFreq_v1140(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_SAI_InterFreq_v1140* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(_buffer, _size, _lidx, _mem, &p->multiBandInfoList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBMS_SAI_InterFreq_v1140));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBMS_SAI_InterFreq_v1140(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_CarrierType_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBMS_CarrierType_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->carrierType_r14 = (MBMS_CarrierType_r14_carrierType_r14_e)_tmp;
	}
	_serSysDecUint8_t_MBMS_CarrierType_r14_frameOffset_r14_Optional(_buffer, _size, _lidx, &p->frameOffset_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMBMS_CarrierType_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MBMS_CarrierType_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecMBMS_CarrierType_r14(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType15_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType15_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(_buffer, _size, _lidx, _mem, &p->mbms_SAI_IntraFreq_r11);
	_serSysDecMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(_buffer, _size, _lidx, _mem, &p->mbms_SAI_InterFreqList_r11);
	_serSysDecOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(_buffer, _size, _lidx, _mem, &p->mbms_SAI_InterFreqList_v1140);
	_serSysDecMBMS_CarrierType_r14_SystemInformationBlockType15_r11_mbms_IntraFreqCarrierType_r14_Optional(_buffer, _size, _lidx, &p->mbms_IntraFreqCarrierType_r14);
	_serSysDecMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(_buffer, _size, _lidx, _mem, &p->mbms_InterFreqCarrierTypeList_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecB2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInt16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecInt8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType16_r11_timeInfo_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType16_r11_timeInfo_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->timeInfoUTC_r11, &_buffer[*_lidx], _lidx);
	_serSysDecB2_SystemInformationBlockType16_r11_timeInfo_r11_dayLightSavingTime_r11_Optional(_buffer, _size, _lidx, &p->dayLightSavingTime_r11);
	_serSysDecInt16_t_SystemInformationBlockType16_r11_timeInfo_r11_leapSeconds_r11_Optional(_buffer, _size, _lidx, &p->leapSeconds_r11);
	_serSysDecInt8_t_SystemInformationBlockType16_r11_timeInfo_r11_localTimeOffset_r11_Optional(_buffer, _size, _lidx, &p->localTimeOffset_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType16_r11_timeInfo_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecReferenceTime_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReferenceTime_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->refDays_r15, &_buffer[*_lidx], _lidx);
	NTOH_32(p->refSeconds_r15, &_buffer[*_lidx], _lidx);
	NTOH_16(p->refMilliSeconds_r15, &_buffer[*_lidx], _lidx);
	NTOH_16(p->refQuarterMicroSeconds_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecTimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (TimeReferenceInfo_r15_timeInfoType_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecTimeReferenceInfo_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimeReferenceInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecReferenceTime_r15(_buffer, _size, _lidx, &p->time_r15);
	_serSysDecUint8_t_TimeReferenceInfo_r15_uncertainty_r15_Optional(_buffer, _size, _lidx, &p->uncertainty_r15);
	_serSysDecTimeReferenceInfo_r15_timeInfoType_r15_e_timeInfoType_r15_Optional(_buffer, _size, _lidx, &p->timeInfoType_r15);
	_serSysDecUint16_t_TimeReferenceInfo_r15_referenceSFN_r15_Optional(_buffer, _size, _lidx, &p->referenceSFN_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecTimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTimeReferenceInfo_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType16_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType16_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType16_r11_timeInfo_r11_timeInfo_r11_Optional(_buffer, _size, _lidx, &p->timeInfo_r11);
	_serSysDecOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecTimeReferenceInfo_r15_SystemInformationBlockType16_r11_timeReferenceInfo_r15_Optional(_buffer, _size, _lidx, &p->timeReferenceInfo_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRP_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRP_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdRSRP_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdRSRP_High_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRP_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdRSRQ_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdRSRQ_High_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdRSRQ_OnAllSymbolsWithWB_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdRSRQ_OnAllSymbolsWithWB_High_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdRSRQ_OnAllSymbolsLow_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdRSRQ_OnAllSymbolsHigh_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdRSRQ_WB_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdRSRQ_WB_High_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdChannelUtilization_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdChannelUtilizationLow_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdChannelUtilizationHigh_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->thresholdBackhaulDL_BandwidthLow_r12 = (WLAN_backhaulRate_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->thresholdBackhaulDL_BandwidthHigh_r12 = (WLAN_backhaulRate_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->thresholdBackhaulUL_BandwidthLow_r12 = (WLAN_backhaulRate_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->thresholdBackhaulUL_BandwidthHigh_r12 = (WLAN_backhaulRate_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->thresholdWLAN_RSSI_Low_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->thresholdWLAN_RSSI_High_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 16; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecT_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct T_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRP_r12_thresholdRSRP_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRP_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_r12_thresholdRSRQ_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_thresholdRSRQ_OnAllSymbolsWithWB_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_OnAllSymbolsWithWB_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_OnAllSymbols_r12_thresholdRSRQ_OnAllSymbols_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_OnAllSymbols_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdRSRQ_WB_r12_thresholdRSRQ_WB_r12_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ_WB_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdChannelUtilization_r12_thresholdChannelUtilization_r12_Optional(_buffer, _size, _lidx, &p->thresholdChannelUtilization_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdBackhaul_Bandwidth_r12_thresholdBackhaul_Bandwidth_r12_Optional(_buffer, _size, _lidx, &p->thresholdBackhaul_Bandwidth_r12);
	_serSysDecWLAN_OffloadConfig_r12_thresholdWLAN_RSSI_r12_thresholdWLAN_RSSI_r12_Optional(_buffer, _size, _lidx, &p->thresholdWLAN_RSSI_r12);
	_serSysDecB16_WLAN_OffloadConfig_r12_offloadPreferenceIndicator_r12_Optional(_buffer, _size, _lidx, &p->offloadPreferenceIndicator_r12);
	_serSysDecT_Reselection_WLAN_OffloadConfig_r12_t_SteeringWLAN_r12_Optional(_buffer, _size, _lidx, &p->t_SteeringWLAN_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct WLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecWLAN_OffloadConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		NTOH_8(p->v.v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecO6_WLAN_Identifiers_r12_bssid_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O6_WLAN_Identifiers_r12_bssid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 6; i4++) {
		NTOH_8(p->v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecO6_WLAN_Identifiers_r12_hessid_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O6_WLAN_Identifiers_r12_hessid_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 6; i4++) {
		NTOH_8(p->v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_Identifiers_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct WLAN_Identifiers_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(_buffer, _size, _lidx, _mem, &p->ssid_r12);
	_serSysDecO6_WLAN_Identifiers_r12_bssid_r12_Optional(_buffer, _size, _lidx, &p->bssid_r12);
	_serSysDecO6_WLAN_Identifiers_r12_hessid_r12_Optional(_buffer, _size, _lidx, &p->hessid_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct WLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct WLAN_Identifiers_r12));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecWLAN_Identifiers_r12(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadInfoPerPLMN_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct WLAN_OffloadInfoPerPLMN_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecWLAN_OffloadConfig_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_OffloadConfigCommon_r12_Optional(_buffer, _size, _lidx, &p->wlan_OffloadConfigCommon_r12);
	_serSysDecWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(_buffer, _size, _lidx, _mem, &p->wlan_Id_List_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct WLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct WLAN_OffloadInfoPerPLMN_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecWLAN_OffloadInfoPerPLMN_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType17_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType17_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(_buffer, _size, _lidx, _mem, &p->wlan_OffloadInfoPerPLMN_List_r12);
	_serSysDecOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicator_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_OffsetIndicator_r12_Value* p, enum SL_OffsetIndicator_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_OffsetIndicator_r12_small_r12) {
		NTOH_16(p->small_r12, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_OffsetIndicator_r12_large_r12) {
		NTOH_16(p->large_r12, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicator_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicator_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_OffsetIndicator_r12_Sel)_tmp;
	}
	_serSysDecSL_OffsetIndicator_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSubframeBitmapSL_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SubframeBitmapSL_r12_Value* p, enum SubframeBitmapSL_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubframeBitmapSL_r12_bs4_r12) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			NTOH_8(p->bs4_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs8_r12) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			NTOH_8(p->bs8_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs12_r12) {
		for (size_t i3 = 0; i3 < 12; i3++) {
			NTOH_8(p->bs12_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs16_r12) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			NTOH_8(p->bs16_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs30_r12) {
		for (size_t i3 = 0; i3 < 30; i3++) {
			NTOH_8(p->bs30_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs40_r12) {
		for (size_t i3 = 0; i3 < 40; i3++) {
			NTOH_8(p->bs40_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r12_bs42_r12) {
		for (size_t i3 = 0; i3 < 42; i3++) {
			NTOH_8(p->bs42_r12[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSubframeBitmapSL_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubframeBitmapSL_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SubframeBitmapSL_r12_Sel)_tmp;
	}
	_serSysDecSubframeBitmapSL_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TF_ResourceConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TF_ResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->prb_Num_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prb_Start_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->prb_End_r12, &_buffer[*_lidx], _lidx);
	_serSysDecSL_OffsetIndicator_r12(_buffer, _size, _lidx, &p->offsetIndicator_r12);
	_serSysDecSubframeBitmapSL_r12(_buffer, _size, _lidx, &p->subframeBitmap_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_HoppingConfigComm_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_HoppingConfigComm_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->hoppingParameter_r12, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numSubbands_r12 = (SL_HoppingConfigComm_r12_numSubbands_r12_e)_tmp;
	}
	NTOH_8(p->rb_Offset_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->data_TF_ResourceConfig_r12);
	_serSysDecSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(_buffer, _size, _lidx, _mem, &p->trpt_Subset_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_rxParametersNCell_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePool_r12_rxParametersNCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_SL_CommResourcePool_r12_rxParametersNCell_r12_tdd_Config_r12_Optional(_buffer, _size, _lidx, &p->tdd_Config_r12);
	NTOH_8(p->syncConfigIndex_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePool_r12_rxParametersNCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TxParameters_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TxParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->alpha_r12 = (Alpha_r12_e)_tmp;
	}
	NTOH_8(p->p0_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_txParameters_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePool_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->sc_TxParameters_r12);
	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->dataTxParameters_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePool_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SL_Priority_r13));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePool_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePool_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_CP_Len_r12 = (SL_CP_Len_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_Period_r12 = (SL_PeriodComm_r12_e)_tmp;
	}
	_serSysDecSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->sc_TF_ResourceConfig_r12);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->data_CP_Len_r12 = (SL_CP_Len_r12_e)_tmp;
	}
	_serSysDecSL_HoppingConfigComm_r12(_buffer, _size, _lidx, &p->dataHoppingConfig_r12);
	_serSysDecSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(_buffer, _size, _lidx, _mem, &p->ue_SelectedResourceConfig_r12);
	_serSysDecSL_CommResourcePool_r12_rxParametersNCell_r12_rxParametersNCell_r12_Optional(_buffer, _size, _lidx, &p->rxParametersNCell_r12);
	_serSysDecSL_CommResourcePool_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysDecSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(_buffer, _size, _lidx, _mem, &p->priorityList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePool_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePool_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 19; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_txParameters_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->syncTxParameters_r12);
	NTOH_8(p->syncTxThreshIC_r12, &_buffer[*_lidx], _lidx);
	_serSysDecB19_SL_SyncConfig_r12_txParameters_r12_syncInfoReserved_r12_Optional(_buffer, _size, _lidx, &p->syncInfoReserved_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncConfig_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_rxParamsNCell_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_rxParamsNCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId_r12, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->discSyncWindow_r12 = (SL_SyncConfig_r12_rxParamsNCell_r12_discSyncWindow_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncConfig_r12_rxParamsNCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfig_r12_syncTxPeriodic_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfig_r12_gnss_Sync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfig_r12_slss_TxDisabled_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->syncCP_Len_r12 = (SL_CP_Len_r12_e)_tmp;
	}
	NTOH_8(p->syncOffsetIndicator_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->slssid_r12, &_buffer[*_lidx], _lidx);
	_serSysDecSL_SyncConfig_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysDecSL_SyncConfig_r12_rxParamsNCell_r12_rxParamsNCell_r12_Optional(_buffer, _size, _lidx, &p->rxParamsNCell_r12);
	_serSysDecSL_SyncConfig_r12_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(_buffer, _size, _lidx, &p->syncTxPeriodic_r13);
	_serSysDecSL_OffsetIndicatorSync_v1430_SL_SyncConfig_r12_syncOffsetIndicator_v1430_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator_v1430);
	_serSysDecSL_SyncConfig_r12_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator2_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator2_r14);
	_serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfig_r12_syncOffsetIndicator3_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator3_r14);
	_serSysDecSL_SyncConfig_r12_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(_buffer, _size, _lidx, &p->slss_TxDisabled_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_SyncConfig_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType18_r12_commConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType18_r12_commConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->commRxPool_r12.d, &_buffer[*_lidx], _lidx);
	p->commRxPool_r12.v = serMalloc(_mem, p->commRxPool_r12.d * sizeof(struct SL_CommResourcePool_r12));
	for (size_t i2 = 0; i2 < p->commRxPool_r12.d; i2++) {
		_serSysDecSL_CommResourcePool_r12(_buffer, _size, _lidx, _mem, &p->commRxPool_r12.v[i2]);
	}
	_serSysDecSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(_buffer, _size, _lidx, _mem, &p->commTxPoolNormalCommon_r12);
	_serSysDecSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(_buffer, _size, _lidx, _mem, &p->commTxPoolExceptional_r12);
	_serSysDecSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(_buffer, _size, _lidx, _mem, &p->commSyncConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType18_r12_commConfig_r12(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePool_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType18_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType18_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(_buffer, _size, _lidx, _mem, &p->commConfig_r12);
	_serSysDecOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(_buffer, _size, _lidx, _mem, &p->commTxPoolNormalCommonExt_r13);
	_serSysDecSystemInformationBlockType18_r12_commTxResourceUC_ReqAllowed_r13_e_commTxResourceUC_ReqAllowed_r13_Optional(_buffer, _size, _lidx, &p->commTxResourceUC_ReqAllowed_r13);
	_serSysDecSystemInformationBlockType18_r12_commTxAllowRelayCommon_r13_e_commTxAllowRelayCommon_r13_Optional(_buffer, _size, _lidx, &p->commTxAllowRelayCommon_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PoolSelectionConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PoolSelectionConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshLow_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshHigh_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value* p, enum SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_rsrpBased_r12) {
		_serSysDecSL_PoolSelectionConfig_r12(_buffer, _size, _lidx, &p->rsrpBased_r12);
	}
	if (d == SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_random_r12) {
		NTOH_8(p->random_r12, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Sel)_tmp;
	}
	_serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_poolSelection_r12(_buffer, _size, _lidx, &p->poolSelection_r12);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->txProbability_r12 = (SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_txProbability_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->txParametersGeneral_r12);
	_serSysDecSL_DiscResourcePool_r12_txParameters_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(_buffer, _size, _lidx, &p->ue_SelectedResourceConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_txParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParameters_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_rxParameters_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_SL_DiscResourcePool_r12_rxParameters_r12_tdd_Config_r12_Optional(_buffer, _size, _lidx, &p->tdd_Config_r12);
	NTOH_8(p->syncConfigIndex_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_rxParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_discPeriod_v1310_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_DiscResourcePool_r12_discPeriod_v1310_Value* p, enum SL_DiscResourcePool_r12_discPeriod_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_discPeriod_v1310_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscResourcePool_r12_discPeriod_v1310_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (SL_DiscResourcePool_r12_discPeriod_v1310_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_discPeriod_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_discPeriod_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscResourcePool_r12_discPeriod_v1310_Sel)_tmp;
	}
	_serSysDecSL_DiscResourcePool_r12_discPeriod_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_discPeriod_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->physCellId_r13.d, &_buffer[*_lidx], _lidx);
	p->physCellId_r13.v = serMalloc(_mem, p->physCellId_r13.d * sizeof(PhysCellId));
	for (size_t i3 = 0; i3 < p->physCellId_r13.d; i3++) {
		NTOH_16(p->physCellId_r13.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup) {
		_serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Sel)_tmp;
	}
	_serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecARFCN_ValueEUTRA_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_CarrierFreq_Optional(_buffer, _size, _lidx, &p->ul_CarrierFreq);
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo_ul_Bandwidth_e_ul_Bandwidth_Optional(_buffer, _size, _lidx, &p->ul_Bandwidth);
	NTOH_8(p->additionalSpectrumEmission, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->physCellId_r13.d, &_buffer[*_lidx], _lidx);
	p->physCellId_r13.v = serMalloc(_mem, p->physCellId_r13.d * sizeof(PhysCellId));
	for (size_t i3 = 0; i3 < p->physCellId_r13.d; i3++) {
		NTOH_16(p->physCellId_r13.v[i3], &_buffer[*_lidx], _lidx);
	}
	_serSysDecP_Max_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serSysDecTDD_Config_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_r13_Optional(_buffer, _size, _lidx, &p->tdd_Config_r13);
	_serSysDecTDD_Config_v1130_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_freqInfo(_buffer, _size, _lidx, &p->freqInfo);
	NTOH_8(p->referenceSignalPower, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup_syncConfigIndex_r13_Optional(_buffer, _size, _lidx, &p->syncConfigIndex_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup) {
		_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Sel)_tmp;
	}
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->additionalSpectrumEmission_v1370, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup_freqInfo_v1370(_buffer, _size, _lidx, &p->freqInfo_v1370);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value* p, enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup) {
		_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Sel)_tmp;
	}
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscResourcePool_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscResourcePool_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cp_Len_r12 = (SL_CP_Len_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->discPeriod_r12 = (SL_DiscResourcePool_r12_discPeriod_r12_e)_tmp;
	}
	NTOH_8(p->numRetx_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->numRepetition_r12, &_buffer[*_lidx], _lidx);
	_serSysDecSL_TF_ResourceConfig_r12(_buffer, _size, _lidx, &p->tf_ResourceConfig_r12);
	_serSysDecSL_DiscResourcePool_r12_txParameters_r12_txParameters_r12_Optional(_buffer, _size, _lidx, &p->txParameters_r12);
	_serSysDecSL_DiscResourcePool_r12_rxParameters_r12_rxParameters_r12_Optional(_buffer, _size, _lidx, &p->rxParameters_r12);
	_serSysDecSL_DiscResourcePool_r12_discPeriod_v1310_discPeriod_v1310_Optional(_buffer, _size, _lidx, &p->discPeriod_v1310);
	_serSysDecSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(_buffer, _size, _lidx, _mem, &p->rxParamsAddNeighFreq_r13);
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(_buffer, _size, _lidx, _mem, &p->txParamsAddNeighFreq_r13);
	_serSysDecSL_DiscResourcePool_r12_txParamsAddNeighFreq_v1370_txParamsAddNeighFreq_v1370_Optional(_buffer, _size, _lidx, &p->txParamsAddNeighFreq_v1370);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_DiscResourcePool_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxPowerInfo_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscTxPowerInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->discMaxTxPower_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		_serSysDecSL_DiscTxPowerInfo_r12(_buffer, _size, _lidx, &p->v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_SyncConfig_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->discRxPool_r12.d, &_buffer[*_lidx], _lidx);
	p->discRxPool_r12.v = serMalloc(_mem, p->discRxPool_r12.d * sizeof(struct SL_DiscResourcePool_r12));
	for (size_t i2 = 0; i2 < p->discRxPool_r12.d; i2++) {
		_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->discRxPool_r12.v[i2]);
	}
	_serSysDecSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(_buffer, _size, _lidx, _mem, &p->discTxPoolCommon_r12);
	_serSysDecSL_DiscTxPowerInfoList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPowerInfo_r12_Optional(_buffer, _size, _lidx, &p->discTxPowerInfo_r12);
	_serSysDecSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(_buffer, _size, _lidx, _mem, &p->discSyncConfig_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType19_r12_discConfig_r12(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo2_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PLMN_IdentityInfo2_r12_Value* p, enum PLMN_IdentityInfo2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PLMN_IdentityInfo2_r12_plmn_Index_r12) {
		NTOH_8(p->plmn_Index_r12, &_buffer[*_lidx], _lidx);
	}
	if (d == PLMN_IdentityInfo2_r12_plmnIdentity_r12) {
		_serSysDecPLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmnIdentity_r12);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo2_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityInfo2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PLMN_IdentityInfo2_r12_Sel)_tmp;
	}
	_serSysDecPLMN_IdentityInfo2_r12_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PLMN_IdentityInfo2_r12));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPLMN_IdentityInfo2_r12(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CarrierFreqInfo_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CarrierFreqInfo_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq_r12, &_buffer[*_lidx], _lidx);
	_serSysDecPLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CarrierFreqInfo_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CarrierFreqInfo_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_DiscResourcePool_r12));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxResourcesInterFreq_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SL_DiscTxResourcesInterFreq_r13_Value* p, enum SL_DiscTxResourcesInterFreq_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_DiscTxResourcesInterFreq_r13_acquireSI_FromCarrier_r13) {
		NTOH_8(p->acquireSI_FromCarrier_r13, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_discTxPoolCommon_r13) {
		NTOH_32(p->discTxPoolCommon_r13.d, &_buffer[*_lidx], _lidx);
		p->discTxPoolCommon_r13.v = serMalloc(_mem, p->discTxPoolCommon_r13.d * sizeof(struct SL_DiscResourcePool_r12));
		for (size_t i3 = 0; i3 < p->discTxPoolCommon_r13.d; i3++) {
			_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->discTxPoolCommon_r13.v[i3]);
		}
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_requestDedicated_r13) {
		NTOH_8(p->requestDedicated_r13, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_DiscTxResourcesInterFreq_r13_noTxOnCarrier_r13) {
		NTOH_8(p->noTxOnCarrier_r13, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxResourcesInterFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscTxResourcesInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_DiscTxResourcesInterFreq_r13_Sel)_tmp;
	}
	_serSysDecSL_DiscTxResourcesInterFreq_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscTxResourcesInterFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ResourcesInterFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_ResourcesInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(_buffer, _size, _lidx, _mem, &p->discRxResourcesInterFreq_r13);
	_serSysDecSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(_buffer, _size, _lidx, _mem, &p->discTxResourcesInterFreq_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_ResourcesInterFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_ResourcesInterFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 3; i3++) {
		_serSysDecSL_DiscTxPowerInfo_r12(_buffer, _size, _lidx, &p->v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_asyncParameters_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_asyncParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->syncCP_Len_r13 = (SL_CP_Len_r12_e)_tmp;
	}
	NTOH_8(p->syncOffsetIndicator_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->slssid_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncConfigNFreq_r13_asyncParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i4 = 0; i4 < 19; i4++) {
		NTOH_8(p->v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_txParameters_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_txParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->syncTxParameters_r13);
	NTOH_8(p->syncTxThreshIC_r13, &_buffer[*_lidx], _lidx);
	_serSysDecB19_SL_SyncConfigNFreq_r13_txParameters_r13_syncInfoReserved_r13_Optional(_buffer, _size, _lidx, &p->syncInfoReserved_r13);
	_serSysDecSL_SyncConfigNFreq_r13_txParameters_r13_syncTxPeriodic_r13_e_syncTxPeriodic_r13_Optional(_buffer, _size, _lidx, &p->syncTxPeriodic_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncConfigNFreq_r13_txParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_rxParameters_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_rxParameters_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->discSyncWindow_r13 = (SL_SyncConfigNFreq_r13_rxParameters_r13_discSyncWindow_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncConfigNFreq_r13_rxParameters_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfigNFreq_r13_gnss_Sync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigNFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncConfigNFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_SyncConfigNFreq_r13_asyncParameters_r13_asyncParameters_r13_Optional(_buffer, _size, _lidx, &p->asyncParameters_r13);
	_serSysDecSL_SyncConfigNFreq_r13_txParameters_r13_txParameters_r13_Optional(_buffer, _size, _lidx, &p->txParameters_r13);
	_serSysDecSL_SyncConfigNFreq_r13_rxParameters_r13_rxParameters_r13_Optional(_buffer, _size, _lidx, &p->rxParameters_r13);
	_serSysDecSL_OffsetIndicatorSync_v1430_SL_SyncConfigNFreq_r13_syncOffsetIndicator_v1430_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator_v1430);
	_serSysDecSL_SyncConfigNFreq_r13_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator2_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator2_r14);
	_serSysDecSL_OffsetIndicatorSync_r14_SL_SyncConfigNFreq_r13_syncOffsetIndicator3_r14_Optional(_buffer, _size, _lidx, &p->syncOffsetIndicator3_r14);
	_serSysDecSL_SyncConfigNFreq_r13_slss_TxDisabled_r15_e_slss_TxDisabled_r15_Optional(_buffer, _size, _lidx, &p->slss_TxDisabled_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_SyncConfigNFreq_r13));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_SyncConfigNFreq_r13(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoNFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoNFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_CellSelectionInfoNFreq_r13_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_Hyst_r13 = (CellSelectionInfoNFreq_r13_q_Hyst_r13_e)_tmp;
	}
	NTOH_8(p->q_RxLevMinReselection_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->t_ReselectionEUTRA_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoNFreq_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigOtherInterFreq_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscConfigOtherInterFreq_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DiscTxPowerInfoList_r12_SL_DiscConfigOtherInterFreq_r13_txPowerInfo_r13_Optional(_buffer, _size, _lidx, &p->txPowerInfo_r13);
	_serSysDecSL_DiscConfigOtherInterFreq_r13_refCarrierCommon_r13_e_refCarrierCommon_r13_Optional(_buffer, _size, _lidx, &p->refCarrierCommon_r13);
	_serSysDecSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(_buffer, _size, _lidx, _mem, &p->discSyncConfig_r13);
	_serSysDecCellSelectionInfoNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discCellSelectionInfo_r13_Optional(_buffer, _size, _lidx, &p->discCellSelectionInfo_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_DiscConfigOtherInterFreq_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CarrierFreqInfo_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CarrierFreqInfo_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(_buffer, _size, _lidx, _mem, &p->discResourcesNonPS_r13);
	_serSysDecSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(_buffer, _size, _lidx, _mem, &p->discResourcesPS_r13);
	_serSysDecSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(_buffer, _size, _lidx, _mem, &p->discConfigOther_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CarrierFreqInfo_v1310));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CarrierFreqInfo_v1310(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfig_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfig_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(_buffer, _size, _lidx, _mem, &p->discInterFreqList_v1310);
	_serSysDecSystemInformationBlockType19_r12_discConfig_v1310_gapRequestsAllowedCommon_e_gapRequestsAllowedCommon_Optional(_buffer, _size, _lidx, &p->gapRequestsAllowedCommon);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType19_r12_discConfig_v1310(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_DiscConfigRelayUE_r13_hystMax_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_DiscConfigRelayUE_r13_hystMin_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigRelayUE_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigRelayUE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshHigh_r13_Optional(_buffer, _size, _lidx, &p->threshHigh_r13);
	_serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRelayUE_r13_threshLow_r13_Optional(_buffer, _size, _lidx, &p->threshLow_r13);
	_serSysDecSL_DiscConfigRelayUE_r13_hystMax_r13_e_hystMax_r13_Optional(_buffer, _size, _lidx, &p->hystMax_r13);
	_serSysDecSL_DiscConfigRelayUE_r13_hystMin_r13_e_hystMin_r13_Optional(_buffer, _size, _lidx, &p->hystMin_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_DiscConfigRemoteUE_r13_hystMax_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (ReselectionInfoRelay_r13_minHyst_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecReselectionInfoRelay_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReselectionInfoRelay_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin_r13, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->filterCoefficient_r13 = (FilterCoefficient_e)_tmp;
	}
	_serSysDecReselectionInfoRelay_r13_minHyst_r13_e_minHyst_r13_Optional(_buffer, _size, _lidx, &p->minHyst_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscConfigRemoteUE_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_DiscConfigRemoteUE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_RangeSL4_r13_SL_DiscConfigRemoteUE_r13_threshHigh_r13_Optional(_buffer, _size, _lidx, &p->threshHigh_r13);
	_serSysDecSL_DiscConfigRemoteUE_r13_hystMax_r13_e_hystMax_r13_Optional(_buffer, _size, _lidx, &p->hystMax_r13);
	_serSysDecReselectionInfoRelay_r13(_buffer, _size, _lidx, &p->reselectionInfoIC_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfigRelay_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType19_r12_discConfigRelay_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DiscConfigRelayUE_r13(_buffer, _size, _lidx, &p->relayUE_Config_r13);
	_serSysDecSL_DiscConfigRemoteUE_r13(_buffer, _size, _lidx, &p->remoteUE_Config_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType19_r12_discConfigRelay_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_DiscResourcePool_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfigPS_13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfigPS_13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->discRxPoolPS_r13.d, &_buffer[*_lidx], _lidx);
	p->discRxPoolPS_r13.v = serMalloc(_mem, p->discRxPoolPS_r13.d * sizeof(struct SL_DiscResourcePool_r12));
	for (size_t i2 = 0; i2 < p->discRxPoolPS_r13.d; i2++) {
		_serSysDecSL_DiscResourcePool_r12(_buffer, _size, _lidx, _mem, &p->discRxPoolPS_r13.v[i2]);
	}
	_serSysDecSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(_buffer, _size, _lidx, _mem, &p->discTxPoolPS_Common_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType19_r12_discConfigPS_13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType19_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType19_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(_buffer, _size, _lidx, _mem, &p->discConfig_r12);
	_serSysDecSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(_buffer, _size, _lidx, _mem, &p->discInterFreqList_r12);
	_serSysDecOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(_buffer, _size, _lidx, _mem, &p->discConfig_v1310);
	_serSysDecSystemInformationBlockType19_r12_discConfigRelay_r13_discConfigRelay_r13_Optional(_buffer, _size, _lidx, &p->discConfigRelay_r13);
	_serSysDecSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(_buffer, _size, _lidx, _mem, &p->discConfigPS_13);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value* p, enum SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_fdd_r14) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->fdd_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_fdd_r14_e)_tmp;
		}
	}
	if (d == SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_tdd_r14) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->tdd_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_tdd_r14_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_br_BCCH_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dummy = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_dummy_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dummy2 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_dummy2_e)_tmp;
	}
	NTOH_8(p->mpdcch_Narrowband_SC_MCCH_r14, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_NumRepetition_SC_MCCH_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_NumRepetition_SC_MCCH_r14_e)_tmp;
	}
	_serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_StartSF_SC_MCCH_r14(_buffer, _size, _lidx, &p->mpdcch_StartSF_SC_MCCH_r14);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpdcch_PDSCH_HoppingConfig_SC_MCCH_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_mpdcch_PDSCH_HoppingConfig_SC_MCCH_r14_e)_tmp;
	}
	NTOH_32(p->sc_mcch_CarrierFreq_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sc_mcch_Offset_BR_r14, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_mcch_RepetitionPeriod_BR_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_sc_mcch_RepetitionPeriod_BR_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_mcch_ModificationPeriod_BR_r14 = (SystemInformationBlockType20_r13_br_BCCH_Config_r14_sc_mcch_ModificationPeriod_BR_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value* p, enum SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf10) {
		NTOH_8(p->sf10, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf20) {
		NTOH_8(p->sf20, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf32) {
		NTOH_8(p->sf32, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf40) {
		NTOH_8(p->sf40, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf64) {
		NTOH_8(p->sf64, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf80) {
		NTOH_8(p->sf80, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf128) {
		NTOH_8(p->sf128, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf160) {
		NTOH_8(p->sf160, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf256) {
		NTOH_8(p->sf256, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf320) {
		NTOH_16(p->sf320, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf512) {
		NTOH_16(p->sf512, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf640) {
		NTOH_16(p->sf640, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf1024) {
		NTOH_16(p->sf1024, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf2048) {
		NTOH_16(p->sf2048, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf4096) {
		NTOH_16(p->sf4096, &_buffer[*_lidx], _lidx);
	}
	if (d == SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_sf8192) {
		NTOH_16(p->sf8192, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Sel)_tmp;
	}
	_serSysDecSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSC_MCCH_SchedulingInfo_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SC_MCCH_SchedulingInfo_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->onDurationTimerSCPTM_r14 = (SC_MCCH_SchedulingInfo_r14_onDurationTimerSCPTM_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_InactivityTimerSCPTM_r14 = (SC_MCCH_SchedulingInfo_r14_drx_InactivityTimerSCPTM_r14_e)_tmp;
	}
	_serSysDecSC_MCCH_SchedulingInfo_r14_schedulingPeriodStartOffsetSCPTM_r14(_buffer, _size, _lidx, &p->schedulingPeriodStartOffsetSCPTM_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSC_MCCH_SchedulingInfo_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType20_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType20_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_mcch_RepetitionPeriod_r13 = (SystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_r13_e)_tmp;
	}
	NTOH_8(p->sc_mcch_Offset_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sc_mcch_FirstSubframe_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_SystemInformationBlockType20_r13_sc_mcch_duration_r13_Optional(_buffer, _size, _lidx, &p->sc_mcch_duration_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sc_mcch_ModificationPeriod_r13 = (SystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_r13_e)_tmp;
	}
	_serSysDecOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType20_r13_br_BCCH_Config_r14_br_BCCH_Config_r14_Optional(_buffer, _size, _lidx, &p->br_BCCH_Config_r14);
	_serSysDecSC_MCCH_SchedulingInfo_r14_SystemInformationBlockType20_r13_sc_mcch_SchedulingInfo_r14_Optional(_buffer, _size, _lidx, &p->sc_mcch_SchedulingInfo_r14);
	_serSysDecSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeA_SC_MTCH_r14);
	_serSysDecSystemInformationBlockType20_r13_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_e_pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14_Optional(_buffer, _size, _lidx, &p->pdsch_maxNumRepetitionCEmodeB_SC_MTCH_r14);
	_serSysDecSystemInformationBlockType20_r13_sc_mcch_RepetitionPeriod_v1470_e_sc_mcch_RepetitionPeriod_v1470_Optional(_buffer, _size, _lidx, &p->sc_mcch_RepetitionPeriod_v1470);
	_serSysDecSystemInformationBlockType20_r13_sc_mcch_ModificationPeriod_v1470_e_sc_mcch_ModificationPeriod_v1470_Optional(_buffer, _size, _lidx, &p->sc_mcch_ModificationPeriod_v1470);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_OffsetIndicator_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSubframeBitmapSL_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SubframeBitmapSL_r14_Value* p, enum SubframeBitmapSL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubframeBitmapSL_r14_bs10_r14) {
		for (size_t i3 = 0; i3 < 10; i3++) {
			NTOH_8(p->bs10_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs16_r14) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			NTOH_8(p->bs16_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs20_r14) {
		for (size_t i3 = 0; i3 < 20; i3++) {
			NTOH_8(p->bs20_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs30_r14) {
		for (size_t i3 = 0; i3 < 30; i3++) {
			NTOH_8(p->bs30_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs40_r14) {
		for (size_t i3 = 0; i3 < 40; i3++) {
			NTOH_8(p->bs40_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs50_r14) {
		for (size_t i3 = 0; i3 < 50; i3++) {
			NTOH_8(p->bs50_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs60_r14) {
		for (size_t i3 = 0; i3 < 60; i3++) {
			NTOH_8(p->bs60_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SubframeBitmapSL_r14_bs100_r14) {
		for (size_t i3 = 0; i3 < 100; i3++) {
			NTOH_8(p->bs100_r14[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSubframeBitmapSL_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubframeBitmapSL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SubframeBitmapSL_r14_Sel)_tmp;
	}
	_serSysDecSubframeBitmapSL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14_rxParametersNCell_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePoolV2X_r14_rxParametersNCell_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_tdd_Config_r14_Optional(_buffer, _size, _lidx, &p->tdd_Config_r14);
	NTOH_8(p->syncConfigIndex_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePoolV2X_r14_rxParametersNCell_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_TxParameters_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PPPP_TxConfigIndex_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PPPP_TxConfigIndex_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->priorityThreshold_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->defaultTxConfigIndex_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cbr_ConfigIndex_r14, &_buffer[*_lidx], _lidx);
	NTOH_32(p->tx_ConfigIndexList_r14.d, &_buffer[*_lidx], _lidx);
	p->tx_ConfigIndexList_r14.v = serMalloc(_mem, p->tx_ConfigIndexList_r14.d * sizeof(Tx_ConfigIndex_r14));
	for (size_t i4 = 0; i4 < p->tx_ConfigIndexList_r14.d; i4++) {
		NTOH_8(p->tx_ConfigIndexList_r14.v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_PPPP_TxConfigIndex_r14));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_PPPP_TxConfigIndex_r14(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_P2X_ResourceSelectionConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_P2X_ResourceSelectionConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_P2X_ResourceSelectionConfig_r14_partialSensing_r14_e_partialSensing_r14_Optional(_buffer, _size, _lidx, &p->partialSensing_r14);
	_serSysDecSL_P2X_ResourceSelectionConfig_r14_randomSelection_r14_e_randomSelection_r14_Optional(_buffer, _size, _lidx, &p->randomSelection_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_P2X_ResourceSelectionConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncAllowed_r14_gnss_Sync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncAllowed_r14_enb_Sync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_SyncAllowed_r14_ue_Sync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncAllowed_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncAllowed_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_SyncAllowed_r14_gnss_Sync_r14_e_gnss_Sync_r14_Optional(_buffer, _size, _lidx, &p->gnss_Sync_r14);
	_serSysDecSL_SyncAllowed_r14_enb_Sync_r14_e_enb_Sync_r14_Optional(_buffer, _size, _lidx, &p->enb_Sync_r14);
	_serSysDecSL_SyncAllowed_r14_ue_Sync_r14_e_ue_Sync_r14_Optional(_buffer, _size, _lidx, &p->ue_Sync_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_SyncAllowed_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SL_RestrictResourceReservationPeriod_r14_e));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->v.v[i3] = (SL_RestrictResourceReservationPeriod_r14_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_MinT2Value_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_MinT2Value_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->priorityList_r15.d, &_buffer[*_lidx], _lidx);
	p->priorityList_r15.v = serMalloc(_mem, p->priorityList_r15.d * sizeof(SL_Priority_r13));
	for (size_t i4 = 0; i4 < p->priorityList_r15.d; i4++) {
		NTOH_8(p->priorityList_r15.v[i4], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->minT2Value_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_MinT2Value_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_MinT2Value_r15(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMCS_PSSCH_Range_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MCS_PSSCH_Range_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->minMCS_PSSCH_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->maxMCS_PSSCH_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct MCS_PSSCH_Range_r15));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysDecMCS_PSSCH_Range_r15(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PPPP_TxConfigIndex_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PPPP_TxConfigIndex_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(_buffer, _size, _lidx, _mem, &p->mcs_PSSCH_RangeList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_PPPP_TxConfigIndex_v1530));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_PPPP_TxConfigIndex_v1530(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePoolV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_OffsetIndicator_r12_SL_CommResourcePoolV2X_r14_sl_OffsetIndicator_r14_Optional(_buffer, _size, _lidx, &p->sl_OffsetIndicator_r14);
	_serSysDecSubframeBitmapSL_r14(_buffer, _size, _lidx, &p->sl_Subframe_r14);
	NTOH_8(p->adjacencyPSCCH_PSSCH_r14, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sizeSubchannel_r14 = (SL_CommResourcePoolV2X_r14_sizeSubchannel_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->numSubchannel_r14 = (SL_CommResourcePoolV2X_r14_numSubchannel_r14_e)_tmp;
	}
	NTOH_8(p->startRB_Subchannel_r14, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_SL_CommResourcePoolV2X_r14_startRB_PSCCH_Pool_r14_Optional(_buffer, _size, _lidx, &p->startRB_PSCCH_Pool_r14);
	_serSysDecSL_CommResourcePoolV2X_r14_rxParametersNCell_r14_rxParametersNCell_r14_Optional(_buffer, _size, _lidx, &p->rxParametersNCell_r14);
	_serSysDecSL_TxParameters_r12_SL_CommResourcePoolV2X_r14_dataTxParameters_r14_Optional(_buffer, _size, _lidx, &p->dataTxParameters_r14);
	_serSysDecUint8_t_SL_CommResourcePoolV2X_r14_zoneID_r14_Optional(_buffer, _size, _lidx, &p->zoneID_r14);
	_serSysDecUint8_t_SL_CommResourcePoolV2X_r14_threshS_RSSI_CBR_r14_Optional(_buffer, _size, _lidx, &p->threshS_RSSI_CBR_r14);
	_serSysDecSL_V2X_TxPoolReportIdentity_r14_SL_CommResourcePoolV2X_r14_poolReportId_r14_Optional(_buffer, _size, _lidx, &p->poolReportId_r14);
	_serSysDecSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(_buffer, _size, _lidx, _mem, &p->cbr_pssch_TxConfigList_r14);
	_serSysDecSL_P2X_ResourceSelectionConfig_r14_SL_CommResourcePoolV2X_r14_resourceSelectionConfigP2X_r14_Optional(_buffer, _size, _lidx, &p->resourceSelectionConfigP2X_r14);
	_serSysDecSL_SyncAllowed_r14_SL_CommResourcePoolV2X_r14_syncAllowed_r14_Optional(_buffer, _size, _lidx, &p->syncAllowed_r14);
	_serSysDecSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(_buffer, _size, _lidx, _mem, &p->restrictResourceReservationPeriod_r14);
	_serSysDecSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(_buffer, _size, _lidx, _mem, &p->sl_MinT2ValueList_r15);
	_serSysDecSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(_buffer, _size, _lidx, _mem, &p->cbr_pssch_TxConfigList_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_SyncConfig_r12));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_SyncConfig_r12(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmn_Identity);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse = (PLMN_IdentityInfo_cellReservedForOperatorUse_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PLMN_IdentityInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecPLMN_IdentityInfo(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(PhysCellId));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		NTOH_16(p->v.v[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_TypeTxSync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_SyncConfigNFreq_r13));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysDecSL_SyncConfigNFreq_r13(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_CommResourcePoolV2X_r14));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommResourcePoolV2X_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_TypeTxSync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TxPower_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_TxPower_r14_Value* p, enum SL_TxPower_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_TxPower_r14_minusinfinity_r14) {
		NTOH_8(p->minusinfinity_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_TxPower_r14_txPower_r14) {
		NTOH_8(p->txPower_r14, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TxPower_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TxPower_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_TxPower_r14_Sel)_tmp;
	}
	_serSysDecSL_TxPower_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_TxPower_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PSSCH_TxParameters_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PSSCH_TxParameters_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->minMCS_PSSCH_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->maxMCS_PSSCH_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->minSubChannel_NumberPSSCH_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->maxSubchannel_NumberPSSCH_r14, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedRetxNumberPSSCH_r14 = (SL_PSSCH_TxParameters_r14_allowedRetxNumberPSSCH_r14_e)_tmp;
	}
	_serSysDecSL_TxPower_r14_SL_PSSCH_TxParameters_r14_maxTxPower_r14_Optional(_buffer, _size, _lidx, &p->maxTxPower_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PSSCH_TxParameters_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PSSCH_TxParameters_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->minMCS_PSSCH_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->maxMCS_PSSCH_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_PSSCH_TxParameters_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_PSSCH_TxParameters_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PSSCH_TxConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_PSSCH_TxConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_TypeTxSync_r14_e_SL_PSSCH_TxConfig_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->thresUE_Speed_r14 = (SL_PSSCH_TxConfig_r14_thresUE_Speed_r14_e)_tmp;
	}
	_serSysDecSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->parametersAboveThres_r14);
	_serSysDecSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->parametersBelowThres_r14);
	_serSysDecSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersAboveThres_v1530_Optional(_buffer, _size, _lidx, &p->parametersAboveThres_v1530);
	_serSysDecSL_PSSCH_TxParameters_v1530_SL_PSSCH_TxConfig_r14_parametersBelowThres_v1530_Optional(_buffer, _size, _lidx, &p->parametersBelowThres_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SL_RestrictResourceReservationPeriod_r14_e));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->v.v[i4] = (SL_RestrictResourceReservationPeriod_r14_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->minNumCandidateSF_r14, &_buffer[*_lidx], _lidx);
	for (size_t i4 = 0; i4 < 10; i4++) {
		NTOH_8(p->gapCandidateSensing_r14[i4], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolSensingConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->pssch_TxConfigList_r14.d, &_buffer[*_lidx], _lidx);
	p->pssch_TxConfigList_r14.v = serMalloc(_mem, p->pssch_TxConfigList_r14.d * sizeof(struct SL_PSSCH_TxConfig_r14));
	for (size_t i4 = 0; i4 < p->pssch_TxConfigList_r14.d; i4++) {
		_serSysDecSL_PSSCH_TxConfig_r14(_buffer, _size, _lidx, &p->pssch_TxConfigList_r14.v[i4]);
	}
	for (size_t i4 = 0; i4 < 64; i4++) {
		NTOH_8(p->thresPSSCH_RSRP_List_r14[i4], &_buffer[*_lidx], _lidx);
	}
	_serSysDecSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(_buffer, _size, _lidx, _mem, &p->restrictResourceReservationPeriod_r14);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->probResourceKeep_r14 = (SL_CommTxPoolSensingConfig_r14_probResourceKeep_r14_e)_tmp;
	}
	_serSysDecSL_CommTxPoolSensingConfig_r14_p2x_SensingConfig_r14_p2x_SensingConfig_r14_Optional(_buffer, _size, _lidx, &p->p2x_SensingConfig_r14);
	_serSysDecSL_CommTxPoolSensingConfig_r14_sl_ReselectAfter_r14_e_sl_ReselectAfter_r14_Optional(_buffer, _size, _lidx, &p->sl_ReselectAfter_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommTxPoolSensingConfig_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ZoneConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_ZoneConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->zoneLength_r14 = (SL_ZoneConfig_r14_zoneLength_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->zoneWidth_r14 = (SL_ZoneConfig_r14_zoneWidth_r14_e)_tmp;
	}
	NTOH_8(p->zoneIdLongiMod_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->zoneIdLatiMod_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_ZoneConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_InterFreqUE_Config_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_InterFreqUE_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(_buffer, _size, _lidx, _mem, &p->physCellIdList_r14);
	_serSysDecSL_TypeTxSync_r14_e_SL_V2X_InterFreqUE_Config_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	_serSysDecSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_SyncConfig_r14);
	_serSysDecSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommRxPool_r14);
	_serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommTxPoolNormal_r14);
	_serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(_buffer, _size, _lidx, _mem, &p->p2x_CommTxPoolNormal_r14);
	_serSysDecSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommTxPoolExceptional_r14);
	_serSysDecSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_ResourceSelectionConfig_r14);
	_serSysDecSL_ZoneConfig_r14_SL_V2X_InterFreqUE_Config_r14_zoneConfig_r14_Optional(_buffer, _size, _lidx, &p->zoneConfig_r14);
	_serSysDecUint16_t_SL_V2X_InterFreqUE_Config_r14_offsetDFN_r14_Optional(_buffer, _size, _lidx, &p->offsetDFN_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_V2X_InterFreqUE_Config_r14));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_V2X_InterFreqUE_Config_r14(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value* p, enum SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmission_r14) {
		NTOH_8(p->additionalSpectrumEmission_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmission_v1440) {
		NTOH_16(p->additionalSpectrumEmission_v1440, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Sel)_tmp;
	}
	_serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_FreqSelectionConfig_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_FreqSelectionConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->priorityList_r15.d, &_buffer[*_lidx], _lidx);
	p->priorityList_r15.v = serMalloc(_mem, p->priorityList_r15.d * sizeof(SL_Priority_r13));
	for (size_t i4 = 0; i4 < p->priorityList_r15.d; i4++) {
		NTOH_8(p->priorityList_r15.v[i4], &_buffer[*_lidx], _lidx);
	}
	_serSysDecSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqReselection_r15_Optional(_buffer, _size, _lidx, &p->threshCBR_FreqReselection_r15);
	_serSysDecSL_CBR_r14_SL_V2X_FreqSelectionConfig_r15_threshCBR_FreqKeeping_r15_Optional(_buffer, _size, _lidx, &p->threshCBR_FreqKeeping_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_V2X_FreqSelectionConfig_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecSL_V2X_FreqSelectionConfig_r15(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoV2X_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_InterFreqInfoV2X_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_r14);
	NTOH_32(p->v2x_CommCarrierFreq_r14, &_buffer[*_lidx], _lidx);
	_serSysDecP_Max_SL_InterFreqInfoV2X_r14_sl_MaxTxPower_r14_Optional(_buffer, _size, _lidx, &p->sl_MaxTxPower_r14);
	_serSysDecSL_InterFreqInfoV2X_r14_sl_Bandwidth_r14_e_sl_Bandwidth_r14_Optional(_buffer, _size, _lidx, &p->sl_Bandwidth_r14);
	_serSysDecSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_SchedulingPool_r14);
	_serSysDecSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_UE_ConfigList_r14);
	_serSysDecSL_InterFreqInfoV2X_r14_additionalSpectrumEmissionV2X_r14_additionalSpectrumEmissionV2X_r14_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmissionV2X_r14);
	_serSysDecSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(_buffer, _size, _lidx, _mem, &p->v2x_FreqSelectionConfigList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_InterFreqInfoV2X_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_InterFreqInfoV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CommTxPoolSensingConfig_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_ZoneConfig_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SL_TypeTxSync_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(ARFCN_ValueEUTRA_r9));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_PSSCH_TxConfig_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_CBR_PSSCH_TxConfig_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cr_Limit_r14, &_buffer[*_lidx], _lidx);
	_serSysDecSL_PSSCH_TxParameters_r14(_buffer, _size, _lidx, &p->tx_Parameters_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_CommonTxConfigList_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CBR_CommonTxConfigList_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->cbr_RangeCommonConfigList_r14.d, &_buffer[*_lidx], _lidx);
	p->cbr_RangeCommonConfigList_r14.v = serMalloc(_mem, p->cbr_RangeCommonConfigList_r14.d * sizeof(SL_CBR_Levels_Config_r14));
	for (size_t i2 = 0; i2 < p->cbr_RangeCommonConfigList_r14.d; i2++) {
		NTOH_32(p->cbr_RangeCommonConfigList_r14.v[i2].d, &_buffer[*_lidx], _lidx);
		p->cbr_RangeCommonConfigList_r14.v[i2].v = serMalloc(_mem, p->cbr_RangeCommonConfigList_r14.v[i2].d * sizeof(SL_CBR_r14));
		for (size_t i3 = 0; i3 < p->cbr_RangeCommonConfigList_r14.v[i2].d; i3++) {
			NTOH_8(p->cbr_RangeCommonConfigList_r14.v[i2].v[i3], &_buffer[*_lidx], _lidx);
		}
	}
	NTOH_32(p->sl_CBR_PSSCH_TxConfigList_r14.d, &_buffer[*_lidx], _lidx);
	p->sl_CBR_PSSCH_TxConfigList_r14.v = serMalloc(_mem, p->sl_CBR_PSSCH_TxConfigList_r14.d * sizeof(struct SL_CBR_PSSCH_TxConfig_r14));
	for (size_t i2 = 0; i2 < p->sl_CBR_PSSCH_TxConfigList_r14.d; i2++) {
		_serSysDecSL_CBR_PSSCH_TxConfig_r14(_buffer, _size, _lidx, &p->sl_CBR_PSSCH_TxConfigList_r14.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_CBR_CommonTxConfigList_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_ConfigCommon_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_ConfigCommon_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommRxPool_r14);
	_serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommTxPoolNormalCommon_r14);
	_serSysDecSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(_buffer, _size, _lidx, _mem, &p->p2x_CommTxPoolNormalCommon_r14);
	_serSysDecSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_CommTxPoolExceptional_r14);
	_serSysDecSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_SyncConfig_r14);
	_serSysDecSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_InterFreqInfoList_r14);
	_serSysDecSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(_buffer, _size, _lidx, _mem, &p->v2x_ResourceSelectionConfig_r14);
	_serSysDecSL_ZoneConfig_r14_SL_V2X_ConfigCommon_r14_zoneConfig_r14_Optional(_buffer, _size, _lidx, &p->zoneConfig_r14);
	_serSysDecSL_TypeTxSync_r14_e_SL_V2X_ConfigCommon_r14_typeTxSync_r14_Optional(_buffer, _size, _lidx, &p->typeTxSync_r14);
	_serSysDecSL_Priority_r13_SL_V2X_ConfigCommon_r14_thresSL_TxPrioritization_r14_Optional(_buffer, _size, _lidx, &p->thresSL_TxPrioritization_r14);
	_serSysDecSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(_buffer, _size, _lidx, _mem, &p->anchorCarrierFreqList_r14);
	_serSysDecUint16_t_SL_V2X_ConfigCommon_r14_offsetDFN_r14_Optional(_buffer, _size, _lidx, &p->offsetDFN_r14);
	_serSysDecSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(_buffer, _size, _lidx, _mem, &p->cbr_CommonTxConfigList_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_V2X_ConfigCommon_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(ARFCN_ValueNR_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType21_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType21_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(_buffer, _size, _lidx, _mem, &p->sl_V2X_ConfigCommon_r14);
	_serSysDecOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(_buffer, _size, _lidx, _mem, &p->anchorCarrierFreqListNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicatorNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(FreqBandIndicatorNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMTC_SSB_NR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSS_RSSI_Measurement_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CellReselectionSubPriority_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNR_r15_threshX_Q_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqNR_r15_threshX_Q_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCarrierFreqNR_r15_threshX_Q_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecInt8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNS_PmaxValueNR_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NS_PmaxValueNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecP_MaxNR_r15_NS_PmaxValueNR_r15_additionalPmaxNR_r15_Optional(_buffer, _size, _lidx, &p->additionalPmaxNR_r15);
	NTOH_8(p->additionalSpectrumEmissionNR_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct NS_PmaxValueNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serSysDecNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInt8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecThresholdListNR_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(NS_PmaxListNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_32(p->v.v[i3].d, &_buffer[*_lidx], _lidx);
		p->v.v[i3].v = serMalloc(_mem, p->v.v[i3].d * sizeof(struct NS_PmaxValueNR_r15));
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysDecNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(NS_PmaxListNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_32(p->v.v[i3].d, &_buffer[*_lidx], _lidx);
		p->v.v[i3].v = serMalloc(_mem, p->v.v[i3].d * sizeof(struct NS_PmaxValueNR_r15));
		for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
			_serSysDecNS_PmaxValueNR_r15(_buffer, _size, _lidx, &p->v.v[i3].v[i4]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSSB_ToMeasure_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNR_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqNR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq_r15, &_buffer[*_lidx], _lidx);
	_serSysDecMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(_buffer, _size, _lidx, _mem, &p->multiBandInfoList_r15);
	_serSysDecMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(_buffer, _size, _lidx, _mem, &p->multiBandInfoListSUL_r15);
	_serSysDecMTC_SSB_NR_r15_CarrierFreqNR_r15_measTimingConfig_r15_Optional(_buffer, _size, _lidx, &p->measTimingConfig_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subcarrierSpacingSSB_r15 = (CarrierFreqNR_r15_subcarrierSpacingSSB_r15_e)_tmp;
	}
	_serSysDecSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(_buffer, _size, _lidx, _mem, &p->ss_RSSI_Measurement_r15);
	_serSysDecCellReselectionPriority_CarrierFreqNR_r15_cellReselectionPriority_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority_r15);
	_serSysDecCellReselectionSubPriority_r13_e_CarrierFreqNR_r15_cellReselectionSubPriority_r15_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority_r15);
	NTOH_8(p->threshX_High_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low_r15, &_buffer[*_lidx], _lidx);
	_serSysDecCarrierFreqNR_r15_threshX_Q_r15_threshX_Q_r15_Optional(_buffer, _size, _lidx, &p->threshX_Q_r15);
	NTOH_8(p->q_RxLevMin_r15, &_buffer[*_lidx], _lidx);
	_serSysDecInt8_t_CarrierFreqNR_r15_q_RxLevMinSUL_r15_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL_r15);
	NTOH_8(p->p_MaxNR_r15, &_buffer[*_lidx], _lidx);
	_serSysDecNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(_buffer, _size, _lidx, _mem, &p->ns_PmaxListNR_r15);
	_serSysDecInt8_t_CarrierFreqNR_r15_q_QualMin_r15_Optional(_buffer, _size, _lidx, &p->q_QualMin_r15);
	NTOH_8(p->deriveSSB_IndexFromCell_r15, &_buffer[*_lidx], _lidx);
	_serSysDecMaxRS_IndexCellQualNR_r15_CarrierFreqNR_r15_maxRS_IndexCellQual_r15_Optional(_buffer, _size, _lidx, &p->maxRS_IndexCellQual_r15);
	_serSysDecThresholdListNR_r15_CarrierFreqNR_r15_threshRS_Index_r15_Optional(_buffer, _size, _lidx, &p->threshRS_Index_r15);
	_serSysDecMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(_buffer, _size, _lidx, _mem, &p->multiBandNsPmaxListNR_v1550);
	_serSysDecMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(_buffer, _size, _lidx, _mem, &p->multiBandNsPmaxListNR_SUL_v1550);
	_serSysDecSSB_ToMeasure_r15_CarrierFreqNR_r15_ssb_ToMeasure_r15_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqNR_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqNR_r15(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(PhysCellIdNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB2_LP_NR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MTC_SSB2_LP_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pci_List_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicity_r16 = (MTC_SSB2_LP_NR_r16_periodicity_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMTC_SSB2_LP_NR_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SSB_PositionQCL_RelationNR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct WhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(PhysCellIdNR_r15));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CarrierFreqNR_v1610_highSpeedCarrierNR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNR_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqNR_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(_buffer, _size, _lidx, _mem, &p->smtc2_LP_r16);
	_serSysDecSSB_PositionQCL_RelationNR_r16_e_CarrierFreqNR_v1610_ssb_PositionQCL_CommonNR_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_CommonNR_r16);
	_serSysDecWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(_buffer, _size, _lidx, _mem, &p->whiteCellListNR_r16);
	_serSysDecCarrierFreqNR_v1610_highSpeedCarrierNR_r16_e_highSpeedCarrierNR_r16_Optional(_buffer, _size, _lidx, &p->highSpeedCarrierNR_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqNR_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqNR_v1610(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType24_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType24_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListNR_r15);
	NTOH_8(p->t_ReselectionNR_r15, &_buffer[*_lidx], _lidx);
	_serSysDecSpeedStateScaleFactors_SystemInformationBlockType24_r15_t_ReselectionNR_SF_r15_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF_r15);
	_serSysDecOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListNR_v1610);

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerCat_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UAC_BarringPerCat_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->accessCategory_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->uac_barringInfoSetIndex_r15, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct UAC_BarringPerCat_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecUAC_BarringPerCat_r15(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value* p, enum UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_ImplicitAC_BarringList_r15) {
		for (size_t i3 = 0; i3 < 63; i3++) {
			NTOH_8(p->uac_ImplicitAC_BarringList_r15[i3], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_ExplicitAC_BarringList_r15) {
		NTOH_32(p->uac_ExplicitAC_BarringList_r15.d, &_buffer[*_lidx], _lidx);
		p->uac_ExplicitAC_BarringList_r15.v = serMalloc(_mem, p->uac_ExplicitAC_BarringList_r15.d * sizeof(struct UAC_BarringPerCat_r15));
		for (size_t i3 = 0; i3 < p->uac_ExplicitAC_BarringList_r15.d; i3++) {
			_serSysDecUAC_BarringPerCat_r15(_buffer, _size, _lidx, &p->uac_ExplicitAC_BarringList_r15.v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Sel)_tmp;
	}
	_serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerPLMN_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UAC_BarringPerPLMN_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r15, &_buffer[*_lidx], _lidx);
	_serSysDecUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(_buffer, _size, _lidx, _mem, &p->uac_AC_BarringListType_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct UAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct UAC_BarringPerPLMN_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecUAC_BarringPerPLMN_r15(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUAC_BarringInfoSet_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UAC_BarringInfoSet_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->uac_BarringFactor_r15 = (UAC_BarringInfoSet_r15_uac_BarringFactor_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->uac_BarringTime_r15 = (UAC_BarringInfoSet_r15_uac_BarringTime_r15_e)_tmp;
	}
	for (size_t i3 = 0; i3 < 7; i3++) {
		NTOH_8(p->uac_BarringForAccessIdentity_r15[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value* p, enum SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_plmnCommon_r15) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->plmnCommon_r15 = (UAC_AC1_SelectAssistInfo_r15_e)_tmp;
		}
	}
	if (d == SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_individualPLMNList_r15) {
		NTOH_32(p->individualPLMNList_r15.d, &_buffer[*_lidx], _lidx);
		p->individualPLMNList_r15.v = serMalloc(_mem, p->individualPLMNList_r15.d * sizeof(UAC_AC1_SelectAssistInfo_r15_e));
		for (size_t i2 = 0; i2 < p->individualPLMNList_r15.d; i2++) {
			{
				size_t _tmp;
				NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
				p->individualPLMNList_r15.v[i2] = (UAC_AC1_SelectAssistInfo_r15_e)_tmp;
			}
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType25_r15_ab_PerRSRP_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType25_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType25_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(_buffer, _size, _lidx, _mem, &p->uac_BarringForCommon_r15);
	_serSysDecUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(_buffer, _size, _lidx, _mem, &p->uac_BarringPerPLMN_List_r15);
	NTOH_32(p->uac_BarringInfoSetList_r15.d, &_buffer[*_lidx], _lidx);
	p->uac_BarringInfoSetList_r15.v = serMalloc(_mem, p->uac_BarringInfoSetList_r15.d * sizeof(struct UAC_BarringInfoSet_r15));
	for (size_t i2 = 0; i2 < p->uac_BarringInfoSetList_r15.d; i2++) {
		_serSysDecUAC_BarringInfoSet_r15(_buffer, _size, _lidx, &p->uac_BarringInfoSetList_r15.v[i2]);
	}
	_serSysDecSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(_buffer, _size, _lidx, _mem, &p->uac_AC1_SelectAssistInfo_r15);
	_serSysDecOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType25_r15_ab_PerRSRP_r16_e_ab_PerRSRP_r16_Optional(_buffer, _size, _lidx, &p->ab_PerRSRP_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_InterFreqInfoV2X_r14));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_InterFreqInfoV2X_r14(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PPPP_TxConfigIndex_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PPPP_TxConfigIndex_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->priorityThreshold_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->defaultTxConfigIndex_r15, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cbr_ConfigIndex_r15, &_buffer[*_lidx], _lidx);
	NTOH_32(p->tx_ConfigIndexList_r15.d, &_buffer[*_lidx], _lidx);
	p->tx_ConfigIndexList_r15.v = serMalloc(_mem, p->tx_ConfigIndexList_r15.d * sizeof(Tx_ConfigIndex_r14));
	for (size_t i3 = 0; i3 < p->tx_ConfigIndexList_r15.d; i3++) {
		NTOH_8(p->tx_ConfigIndexList_r15.v[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->mcs_PSSCH_RangeList_r15.d, &_buffer[*_lidx], _lidx);
	p->mcs_PSSCH_RangeList_r15.v = serMalloc(_mem, p->mcs_PSSCH_RangeList_r15.d * sizeof(struct MCS_PSSCH_Range_r15));
	for (size_t i3 = 0; i3 < p->mcs_PSSCH_RangeList_r15.d; i3++) {
		_serSysDecMCS_PSSCH_Range_r15(_buffer, _size, _lidx, &p->mcs_PSSCH_RangeList_r15.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_PPPP_TxConfigIndex_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_PPPP_TxConfigIndex_r15(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SL_DestinationIdentity_r12));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		for (size_t i4 = 0; i4 < 24; i4++) {
			NTOH_8(p->v.v[i3][i4], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_AllowedCarrierFreqList_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_AllowedCarrierFreqList_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->allowedCarrierFreqSet1.d, &_buffer[*_lidx], _lidx);
	p->allowedCarrierFreqSet1.v = serMalloc(_mem, p->allowedCarrierFreqSet1.d * sizeof(ARFCN_ValueEUTRA_r9));
	for (size_t i3 = 0; i3 < p->allowedCarrierFreqSet1.d; i3++) {
		NTOH_32(p->allowedCarrierFreqSet1.v[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->allowedCarrierFreqSet2.d, &_buffer[*_lidx], _lidx);
	p->allowedCarrierFreqSet2.v = serMalloc(_mem, p->allowedCarrierFreqSet2.d * sizeof(ARFCN_ValueEUTRA_r9));
	for (size_t i3 = 0; i3 < p->allowedCarrierFreqSet2.d; i3++) {
		NTOH_32(p->allowedCarrierFreqSet2.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_AllowedCarrierFreqList_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PPPR_Dest_CarrierFreq(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PPPR_Dest_CarrierFreq* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(_buffer, _size, _lidx, _mem, &p->destinationInfoList_r15);
	_serSysDecSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(_buffer, _size, _lidx, _mem, &p->allowedCarrierFreqList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_PPPR_Dest_CarrierFreq));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_PPPR_Dest_CarrierFreq(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_PacketDuplicationConfig_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_PacketDuplicationConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshSL_Reliability_r15, &_buffer[*_lidx], _lidx);
	_serSysDecSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(_buffer, _size, _lidx, _mem, &p->allowedCarrierFreqConfig_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_V2X_PacketDuplicationConfig_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(ARFCN_ValueEUTRA_r9));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SL_V2X_FreqSelectionConfig_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecSL_V2X_FreqSelectionConfig_r15(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType26_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType26_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(_buffer, _size, _lidx, _mem, &p->v2x_InterFreqInfoList_r15);
	_serSysDecSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(_buffer, _size, _lidx, _mem, &p->cbr_pssch_TxConfigList_r15);
	_serSysDecSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(_buffer, _size, _lidx, _mem, &p->v2x_PacketDuplicationConfig_r15);
	_serSysDecSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(_buffer, _size, _lidx, _mem, &p->syncFreqList_r15);
	_serSysDecSystemInformationBlockType26_r15_slss_TxMultiFreq_r15_e_slss_TxMultiFreq_r15_Optional(_buffer, _size, _lidx, &p->slss_TxMultiFreq_r15);
	_serSysDecSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(_buffer, _size, _lidx, _mem, &p->v2x_FreqSelectionConfigList_r15);
	_serSysDecUint8_t_SystemInformationBlockType26_r15_threshS_RSSI_CBR_r15_Optional(_buffer, _size, _lidx, &p->threshS_RSSI_CBR_r15);
	_serSysDecOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecB10_PLMN_Info_r16_nr_BandList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B10_PLMN_Info_r16_nr_BandList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 10; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_Info_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_Info_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecB10_PLMN_Info_r16_nr_BandList_r16_Optional(_buffer, _size, _lidx, &p->nr_BandList_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType26a_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType26a_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_InfoList_r16.d, &_buffer[*_lidx], _lidx);
	p->plmn_InfoList_r16.v = serMalloc(_mem, p->plmn_InfoList_r16.d * sizeof(struct PLMN_Info_r16));
	for (size_t i2 = 0; i2 < p->plmn_InfoList_r16.d; i2++) {
		_serSysDecPLMN_Info_r16(_buffer, _size, _lidx, &p->plmn_InfoList_r16.v[i2]);
	}
	NTOH_32(p->bandListENDC_r16.d, &_buffer[*_lidx], _lidx);
	p->bandListENDC_r16.v = serMalloc(_mem, p->bandListENDC_r16.d * sizeof(FreqBandIndicatorNR_r15));
	for (size_t i2 = 0; i2 < p->bandListENDC_r16.d; i2++) {
		NTOH_16(p->bandListENDC_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqNBIOT_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CarrierFreqNBIOT_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->carrierFreqOffset_r16 = (CarrierFreqNBIOT_r16_carrierFreqOffset_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CarrierFreqNBIOT_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCarrierFreqNBIOT_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType27_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType27_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListNBIOT_r16);
	_serSysDecOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType28_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType28_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->segmentNumber_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->segmentType_r16 = (SystemInformationBlockType28_r16_segmentType_r16_e)_tmp;
	}
	NTOH_32(p->segmentContainer_r16.d, &_buffer[*_lidx], _lidx);
	p->segmentContainer_r16.v = serMalloc(_mem, p->segmentContainer_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->segmentContainer_r16.d; i2++) {
		NTOH_8(p->segmentContainer_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPeriodicityStartPos_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PeriodicityStartPos_r16_Value* p, enum PeriodicityStartPos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PeriodicityStartPos_r16_periodicity10ms) {
		NTOH_8(p->periodicity10ms, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity20ms) {
		NTOH_8(p->periodicity20ms, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity40ms) {
		NTOH_8(p->periodicity40ms, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity80ms) {
		NTOH_8(p->periodicity80ms, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_periodicity160ms) {
		NTOH_8(p->periodicity160ms, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare3) {
		NTOH_8(p->spare3, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare2) {
		NTOH_8(p->spare2, &_buffer[*_lidx], _lidx);
	}
	if (d == PeriodicityStartPos_r16_spare1) {
		NTOH_8(p->spare1, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPeriodicityStartPos_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PeriodicityStartPos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PeriodicityStartPos_r16_Sel)_tmp;
	}
	_serSysDecPeriodicityStartPos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value* p, enum ResourceReservationConfigDL_r16_resourceReservationFreq_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap1dot4) {
		for (size_t i2 = 0; i2 < 6; i2++) {
			NTOH_8(p->rbg_Bitmap1dot4[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap3) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			NTOH_8(p->rbg_Bitmap3[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap5) {
		for (size_t i2 = 0; i2 < 13; i2++) {
			NTOH_8(p->rbg_Bitmap5[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap10) {
		for (size_t i2 = 0; i2 < 17; i2++) {
			NTOH_8(p->rbg_Bitmap10[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap15) {
		for (size_t i2 = 0; i2 < 19; i2++) {
			NTOH_8(p->rbg_Bitmap15[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_resourceReservationFreq_r16_rbg_Bitmap20) {
		for (size_t i2 = 0; i2 < 25; i2++) {
			NTOH_8(p->rbg_Bitmap20[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigDL_r16_resourceReservationFreq_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ResourceReservationConfigDL_r16_resourceReservationFreq_r16_Sel)_tmp;
	}
	_serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_slotBitmap_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ResourceReservationConfigDL_r16_slotBitmap_r16_Value* p, enum ResourceReservationConfigDL_r16_slotBitmap_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigDL_r16_slotBitmap_r16_slotPattern10ms) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			NTOH_8(p->slotPattern10ms[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigDL_r16_slotBitmap_r16_slotPattern40ms) {
		for (size_t i2 = 0; i2 < 80; i2++) {
			NTOH_8(p->slotPattern40ms[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_slotBitmap_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigDL_r16_slotBitmap_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ResourceReservationConfigDL_r16_slotBitmap_r16_Sel)_tmp;
	}
	_serSysDecResourceReservationConfigDL_r16_slotBitmap_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecB7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigDL_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPeriodicityStartPos_r16(_buffer, _size, _lidx, &p->periodicityStartPos_r16);
	_serSysDecResourceReservationConfigDL_r16_resourceReservationFreq_r16_resourceReservationFreq_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationFreq_r16);
	_serSysDecResourceReservationConfigDL_r16_slotBitmap_r16(_buffer, _size, _lidx, &p->slotBitmap_r16);
	_serSysDecB7_ResourceReservationConfigDL_r16_symbolBitmap1_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap1_r16);
	_serSysDecB7_ResourceReservationConfigDL_r16_symbolBitmap2_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecResourceReservationConfigDL_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigUL_r16_slotBitmap_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ResourceReservationConfigUL_r16_slotBitmap_r16_Value* p, enum ResourceReservationConfigUL_r16_slotBitmap_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ResourceReservationConfigUL_r16_slotBitmap_r16_slotPattern10ms) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			NTOH_8(p->slotPattern10ms[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ResourceReservationConfigUL_r16_slotBitmap_r16_slotPattern40ms) {
		for (size_t i2 = 0; i2 < 80; i2++) {
			NTOH_8(p->slotPattern40ms[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigUL_r16_slotBitmap_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigUL_r16_slotBitmap_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ResourceReservationConfigUL_r16_slotBitmap_r16_Sel)_tmp;
	}
	_serSysDecResourceReservationConfigUL_r16_slotBitmap_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecResourceReservationConfigUL_r16_slotBitmap_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigUL_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigUL_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPeriodicityStartPos_r16(_buffer, _size, _lidx, &p->periodicityStartPos_r16);
	_serSysDecResourceReservationConfigUL_r16_slotBitmap_r16_slotBitmap_r16_Optional(_buffer, _size, _lidx, &p->slotBitmap_r16);
	_serSysDecB7_ResourceReservationConfigUL_r16_symbolBitmap1_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap1_r16);
	_serSysDecB7_ResourceReservationConfigUL_r16_symbolBitmap2_r16_Optional(_buffer, _size, _lidx, &p->symbolBitmap2_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecResourceReservationConfigUL_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType29_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType29_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecResourceReservationConfigDL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonDL_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationConfigCommonDL_r16);
	_serSysDecResourceReservationConfigUL_r16_SystemInformationBlockType29_r16_resourceReservationConfigCommonUL_r16_Optional(_buffer, _size, _lidx, &p->resourceReservationConfigCommonUL_r16);
	_serSysDecOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemInformation_r8_IEs_sib_TypeAndInfo_s_Value* p, enum SystemInformation_r8_IEs_sib_TypeAndInfo_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib2) {
		_serSysDecSystemInformationBlockType2(_buffer, _size, _lidx, _mem, &p->sib2);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib3) {
		_serSysDecSystemInformationBlockType3(_buffer, _size, _lidx, _mem, &p->sib3);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib4) {
		_serSysDecSystemInformationBlockType4(_buffer, _size, _lidx, _mem, &p->sib4);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib5) {
		_serSysDecSystemInformationBlockType5(_buffer, _size, _lidx, _mem, &p->sib5);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib6) {
		_serSysDecSystemInformationBlockType6(_buffer, _size, _lidx, _mem, &p->sib6);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib7) {
		_serSysDecSystemInformationBlockType7(_buffer, _size, _lidx, _mem, &p->sib7);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib8) {
		_serSysDecSystemInformationBlockType8(_buffer, _size, _lidx, _mem, &p->sib8);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib9) {
		_serSysDecSystemInformationBlockType9(_buffer, _size, _lidx, _mem, &p->sib9);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib10) {
		_serSysDecSystemInformationBlockType10(_buffer, _size, _lidx, _mem, &p->sib10);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib11) {
		_serSysDecSystemInformationBlockType11(_buffer, _size, _lidx, _mem, &p->sib11);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib12_v920) {
		_serSysDecSystemInformationBlockType12_r9(_buffer, _size, _lidx, _mem, &p->sib12_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib13_v920) {
		_serSysDecSystemInformationBlockType13_r9(_buffer, _size, _lidx, _mem, &p->sib13_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib14_v1130) {
		_serSysDecSystemInformationBlockType14_r11(_buffer, _size, _lidx, _mem, &p->sib14_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib15_v1130) {
		_serSysDecSystemInformationBlockType15_r11(_buffer, _size, _lidx, _mem, &p->sib15_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib16_v1130) {
		_serSysDecSystemInformationBlockType16_r11(_buffer, _size, _lidx, _mem, &p->sib16_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib17_v1250) {
		_serSysDecSystemInformationBlockType17_r12(_buffer, _size, _lidx, _mem, &p->sib17_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib18_v1250) {
		_serSysDecSystemInformationBlockType18_r12(_buffer, _size, _lidx, _mem, &p->sib18_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib19_v1250) {
		_serSysDecSystemInformationBlockType19_r12(_buffer, _size, _lidx, _mem, &p->sib19_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib20_v1310) {
		_serSysDecSystemInformationBlockType20_r13(_buffer, _size, _lidx, _mem, &p->sib20_v1310);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib21_v1430) {
		_serSysDecSystemInformationBlockType21_r14(_buffer, _size, _lidx, _mem, &p->sib21_v1430);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib24_v1530) {
		_serSysDecSystemInformationBlockType24_r15(_buffer, _size, _lidx, _mem, &p->sib24_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib25_v1530) {
		_serSysDecSystemInformationBlockType25_r15(_buffer, _size, _lidx, _mem, &p->sib25_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26_v1530) {
		_serSysDecSystemInformationBlockType26_r15(_buffer, _size, _lidx, _mem, &p->sib26_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26a_v1610) {
		_serSysDecSystemInformationBlockType26a_r16(_buffer, _size, _lidx, _mem, &p->sib26a_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib27_v1610) {
		_serSysDecSystemInformationBlockType27_r16(_buffer, _size, _lidx, _mem, &p->sib27_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib28_v1610) {
		_serSysDecSystemInformationBlockType28_r16(_buffer, _size, _lidx, _mem, &p->sib28_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib29_v1610) {
		_serSysDecSystemInformationBlockType29_r16(_buffer, _size, _lidx, _mem, &p->sib29_v1610);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_r8_IEs_sib_TypeAndInfo_s(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_r8_IEs_sib_TypeAndInfo_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformation_r8_IEs_sib_TypeAndInfo_s_Sel)_tmp;
	}
	_serSysDecSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_v8a0_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformation_v8a0_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformation_v8a0_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_v8a0_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_v8a0_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformation_v8a0_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformation_v8a0_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_r8_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_r8_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->sib_TypeAndInfo.d, &_buffer[*_lidx], _lidx);
	p->sib_TypeAndInfo.v = serMalloc(_mem, p->sib_TypeAndInfo.d * sizeof(struct SystemInformation_r8_IEs_sib_TypeAndInfo_s));
	for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
		_serSysDecSystemInformation_r8_IEs_sib_TypeAndInfo_s(_buffer, _size, _lidx, _mem, &p->sib_TypeAndInfo.v[i1]);
	}
	_serSysDecSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockPos_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockPos_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->assistanceDataSIB_Element_r15.d, &_buffer[*_lidx], _lidx);
	p->assistanceDataSIB_Element_r15.v = serMalloc(_mem, p->assistanceDataSIB_Element_r15.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->assistanceDataSIB_Element_r15.d; i2++) {
		NTOH_8(p->assistanceDataSIB_Element_r15.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value* p, enum PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_1_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_2_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_3_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_4_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_5_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_6_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_7_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib1_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_1_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_2_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_3_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_4_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_5_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_6_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_7_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_8_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_8_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_9_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_9_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_10_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_10_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_11_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_11_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_12_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_12_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_13_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_13_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_14_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_14_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_15_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_15_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_16_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_16_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_17_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_17_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_18_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_18_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_19_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib2_19_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib3_1_r15) {
		_serSysDecSystemInformationBlockPos_r15(_buffer, _size, _lidx, _mem, &p->posSib3_1_r15);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Sel)_tmp;
	}
	_serSysDecPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSystemInformation_r15_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PosSystemInformation_r15_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPosSystemInformation_r15_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSystemInformation_r15_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PosSystemInformation_r15_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->posSIB_TypeAndInfo_r15.d, &_buffer[*_lidx], _lidx);
	p->posSIB_TypeAndInfo_r15.v = serMalloc(_mem, p->posSIB_TypeAndInfo_r15.d * sizeof(struct PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s));
	for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r15.d; i1++) {
		_serSysDecPosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(_buffer, _size, _lidx, _mem, &p->posSIB_TypeAndInfo_r15.v[i1]);
	}
	_serSysDecOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecPosSystemInformation_r15_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value* p, enum SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_posSystemInformation_r15) {
		_serSysDecPosSystemInformation_r15_IEs(_buffer, _size, _lidx, _mem, &p->posSystemInformation_r15);
	}
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture) {
		_serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_criticalExtensionsFuture(_buffer, _size, _lidx, &p->criticalExtensionsFuture);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_criticalExtensions_criticalExtensionsFuture_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Sel)_tmp;
	}
	_serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_criticalExtensions_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemInformation_criticalExtensions_Value* p, enum SystemInformation_criticalExtensions_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformation_criticalExtensions_systemInformation_r8) {
		_serSysDecSystemInformation_r8_IEs(_buffer, _size, _lidx, _mem, &p->systemInformation_r8);
	}
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15) {
		_serSysDecSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(_buffer, _size, _lidx, _mem, &p->criticalExtensionsFuture_r15);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation_criticalExtensions(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation_criticalExtensions* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformation_criticalExtensions_Sel)_tmp;
	}
	_serSysDecSystemInformation_criticalExtensions_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformation(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformation_criticalExtensions(_buffer, _size, _lidx, _mem, &p->criticalExtensions);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 27; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_cellAccessRelatedInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_cellAccessRelatedInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_IdentityList.d, &_buffer[*_lidx], _lidx);
	p->plmn_IdentityList.v = serMalloc(_mem, p->plmn_IdentityList.d * sizeof(struct PLMN_IdentityInfo));
	for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
		_serSysDecPLMN_IdentityInfo(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList.v[i1]);
	}
	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->trackingAreaCode[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 28; i1++) {
		NTOH_8(p->cellIdentity[i1], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellBarred = (SystemInformationBlockType1_cellAccessRelatedInfo_cellBarred_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->intraFreqReselection = (SystemInformationBlockType1_cellAccessRelatedInfo_intraFreqReselection_e)_tmp;
	}
	NTOH_8(p->csg_Indication, &_buffer[*_lidx], _lidx);
	_serSysDecCSG_Identity_SystemInformationBlockType1_cellAccessRelatedInfo_csg_Identity_Optional(_buffer, _size, _lidx, &p->csg_Identity);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_cellSelectionInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_cellSelectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_SystemInformationBlockType1_cellSelectionInfo_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_Max_SystemInformationBlockType1_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct P_Max_SystemInformationBlockType1_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_Periodicity = (SI_Periodicity_r12_e)_tmp;
	}
	NTOH_32(p->sib_MappingInfo.d, &_buffer[*_lidx], _lidx);
	p->sib_MappingInfo.v = serMalloc(_mem, p->sib_MappingInfo.d * sizeof(SIB_Type_e));
	for (size_t i2 = 0; i2 < p->sib_MappingInfo.d; i2++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->sib_MappingInfo.v[i2] = (SIB_Type_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_SystemInformationBlockType1_tdd_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_SystemInformationBlockType1_tdd_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_QualMin_r9, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_CellSelectionInfo_v920_q_QualMinOffset_r9_Optional(_buffer, _size, _lidx, &p->q_QualMinOffset_r9);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfo_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_QualMinWB_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfo_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250_category0Allowed_r12_e_category0Allowed_r12_Optional(_buffer, _size, _lidx, &p->category0Allowed_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_QualMinRSRQ_OnAllSymbols_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfo_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 10; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingInfo_BR_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingInfo_BR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->si_Narrowband_r13, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_TBS_r13 = (SchedulingInfo_BR_r13_si_TBS_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SchedulingInfo_BR_r13));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecSchedulingInfo_BR_r13(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value* p, enum SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern10_r13) {
		for (size_t i1 = 0; i1 < 10; i1++) {
			NTOH_8(p->subframePattern10_r13[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_subframePattern40_r13) {
		for (size_t i1 = 0; i1 < 40; i1++) {
			NTOH_8(p->subframePattern40_r13[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 10; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SystemInfoValueTagSI_r13));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_WindowLength_BR_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_WindowLength_BR_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_RepetitionPattern_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_RepetitionPattern_r13_e)_tmp;
	}
	_serSysDecSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(_buffer, _size, _lidx, _mem, &p->schedulingInfoList_BR_r13);
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_DownlinkOrTddSubframeBitmapBR_r13);
	_serSysDecB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_UplinkSubframeBitmapBR_r13);
	NTOH_8(p->startSymbolBR_r13, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_HoppingConfigCommon_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_HoppingConfigCommon_r13_e)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(_buffer, _size, _lidx, &p->si_ValidityTime_r13);
	_serSysDecSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(_buffer, _size, _lidx, _mem, &p->systemInfoValueTagList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value* p, enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value* p, enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_FDD_r13 = (SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_FDD_r13_e)_tmp;
		}
	}
	if (d == SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->interval_TDD_r13 = (SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_TDD_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingNB_r13_e_mpdcch_pdsch_HoppingNB_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_pdsch_HoppingNB_r13);
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeA_r13_interval_DLHoppingConfigCommonModeA_r13_Optional(_buffer, _size, _lidx, &p->interval_DLHoppingConfigCommonModeA_r13);
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_interval_DLHoppingConfigCommonModeB_r13_interval_DLHoppingConfigCommonModeB_r13_Optional(_buffer, _size, _lidx, &p->interval_DLHoppingConfigCommonModeB_r13);
	_serSysDecUint8_t_SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_mpdcch_pdsch_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_pdsch_HoppingOffset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE1_v1360(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->specialSubframePatterns_v1430 = (TDD_Config_v1430_specialSubframePatterns_v1430_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellAccessRelatedInfo_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellAccessRelatedInfo_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_IdentityList_r14.d, &_buffer[*_lidx], _lidx);
	p->plmn_IdentityList_r14.v = serMalloc(_mem, p->plmn_IdentityList_r14.d * sizeof(struct PLMN_IdentityInfo));
	for (size_t i2 = 0; i2 < p->plmn_IdentityList_r14.d; i2++) {
		_serSysDecPLMN_IdentityInfo(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_r14.v[i2]);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->trackingAreaCode_r14[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 28; i2++) {
		NTOH_8(p->cellIdentity_r14[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CellAccessRelatedInfo_r14));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCellAccessRelatedInfo_r14(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1450(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1450* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->specialSubframePatterns_v1450 = (TDD_Config_v1450_specialSubframePatterns_v1450_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_Config_v1450(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCellSelectionInfoCE_v1530(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value* p, enum SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigEnabled) {
		NTOH_8(p->crs_IntfMitigEnabled, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->crs_IntfMitigNumPRBs = (SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigNumPRBs_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Sel)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_IdentityInfo_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse_CRS_r15 = (PLMN_IdentityInfo_v1530_cellReservedForOperatorUse_CRS_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PLMN_IdentityInfo_v1530));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPLMN_IdentityInfo_v1530(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PosSIB_Type_r15_encrypted_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGNSS_ID_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GNSS_ID_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->gnss_id_r15 = (GNSS_ID_r15_gnss_id_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecGNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct GNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecGNSS_ID_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSBAS_ID_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SBAS_ID_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sbas_id_r15 = (SBAS_ID_r15_sbas_id_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSBAS_ID_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSIB_Type_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PosSIB_Type_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPosSIB_Type_r15_encrypted_r15_e_encrypted_r15_Optional(_buffer, _size, _lidx, &p->encrypted_r15);
	_serSysDecGNSS_ID_r15_PosSIB_Type_r15_gnss_id_r15_Optional(_buffer, _size, _lidx, &p->gnss_id_r15);
	_serSysDecSBAS_ID_r15_PosSIB_Type_r15_sbas_id_r15_Optional(_buffer, _size, _lidx, &p->sbas_id_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->posSibType_r15 = (PosSIB_Type_r15_posSibType_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSchedulingInfo_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PosSchedulingInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->posSI_Periodicity_r15 = (PosSchedulingInfo_r15_posSI_Periodicity_r15_e)_tmp;
	}
	NTOH_32(p->posSIB_MappingInfo_r15.d, &_buffer[*_lidx], _lidx);
	p->posSIB_MappingInfo_r15.v = serMalloc(_mem, p->posSIB_MappingInfo_r15.d * sizeof(struct PosSIB_Type_r15));
	for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r15.d; i2++) {
		_serSysDecPosSIB_Type_r15(_buffer, _size, _lidx, &p->posSIB_MappingInfo_r15.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PosSchedulingInfo_r15));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPosSchedulingInfo_r15(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value* p, enum PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_plmn_Identity_r15) {
		_serSysDecPLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmn_Identity_r15);
	}
	if (d == PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_plmn_Index_r15) {
		NTOH_8(p->plmn_Index_r15, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Sel)_tmp;
	}
	_serSysDecPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityInfo_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(_buffer, _size, _lidx, _mem, &p->plmn_Identity_5GC_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse_r15 = (PLMN_IdentityInfo_r15_cellReservedForOperatorUse_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse_CRS_r15 = (PLMN_IdentityInfo_r15_cellReservedForOperatorUse_CRS_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellIdentity_5GC_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CellIdentity_5GC_r15_Value* p, enum CellIdentity_5GC_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CellIdentity_5GC_r15_cellIdentity_r15) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			NTOH_8(p->cellIdentity_r15[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == CellIdentity_5GC_r15_cellId_Index_r15) {
		NTOH_8(p->cellId_Index_r15, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellIdentity_5GC_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellIdentity_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CellIdentity_5GC_r15_Sel)_tmp;
	}
	_serSysDecCellIdentity_5GC_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellAccessRelatedInfo_5GC_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellAccessRelatedInfo_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_IdentityList_r15.d, &_buffer[*_lidx], _lidx);
	p->plmn_IdentityList_r15.v = serMalloc(_mem, p->plmn_IdentityList_r15.d * sizeof(struct PLMN_IdentityInfo_r15));
	for (size_t i2 = 0; i2 < p->plmn_IdentityList_r15.d; i2++) {
		_serSysDecPLMN_IdentityInfo_r15(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_r15.v[i2]);
	}
	_serSysDecRAN_AreaCode_r15_CellAccessRelatedInfo_5GC_r15_ran_AreaCode_r15_Optional(_buffer, _size, _lidx, &p->ran_AreaCode_r15);
	for (size_t i2 = 0; i2 < 24; i2++) {
		NTOH_8(p->trackingAreaCode_5GC_r15[i2], &_buffer[*_lidx], _lidx);
	}
	_serSysDecCellIdentity_5GC_r15(_buffer, _size, _lidx, &p->cellIdentity_5GC_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellBarred_5GC_r15 = (SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellBarred_5GC_r15_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellBarred_5GC_CRS_r15 = (SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellBarred_5GC_CRS_r15_e)_tmp;
	}
	NTOH_32(p->cellAccessRelatedInfoList_5GC_r15.d, &_buffer[*_lidx], _lidx);
	p->cellAccessRelatedInfoList_5GC_r15.v = serMalloc(_mem, p->cellAccessRelatedInfoList_5GC_r15.d * sizeof(struct CellAccessRelatedInfo_5GC_r15));
	for (size_t i1 = 0; i1 < p->cellAccessRelatedInfoList_5GC_r15.d; i1++) {
		_serSysDecCellAccessRelatedInfo_5GC_r15(_buffer, _size, _lidx, _mem, &p->cellAccessRelatedInfoList_5GC_r15.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PLMN_IdentityInfo_v1610_iab_Support_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PLMN_IdentityInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPLMN_IdentityInfo_v1610_cp_CIoT_5GS_Optimisation_r16_e_cp_CIoT_5GS_Optimisation_r16_Optional(_buffer, _size, _lidx, &p->cp_CIoT_5GS_Optimisation_r16);
	_serSysDecPLMN_IdentityInfo_v1610_up_CIoT_5GS_Optimisation_r16_e_up_CIoT_5GS_Optimisation_r16_Optional(_buffer, _size, _lidx, &p->up_CIoT_5GS_Optimisation_r16);
	_serSysDecPLMN_IdentityInfo_v1610_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecPLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PLMN_IdentityInfo_v1610));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPLMN_IdentityInfo_v1610(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1610_IEs_eDRX_Allowed_5GC_r16_e_eDRX_Allowed_5GC_r16_Optional(_buffer, _size, _lidx, &p->eDRX_Allowed_5GC_r16);
	_serSysDecSystemInformationBlockType1_v1610_IEs_transmissionInControlChRegion_r16_e_transmissionInControlChRegion_r16_Optional(_buffer, _size, _lidx, &p->transmissionInControlChRegion_r16);
	_serSysDecSystemInformationBlockType1_v1610_IEs_campingAllowedInCE_r16_e_campingAllowedInCE_r16_Optional(_buffer, _size, _lidx, &p->campingAllowedInCE_r16);
	_serSysDecPLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_v1610);
	_serSysDecSystemInformationBlockType1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1610_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1540_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1540_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1540_IEs_si_posOffset_r15_e_si_posOffset_r15_Optional(_buffer, _size, _lidx, &p->si_posOffset_r15);
	_serSysDecSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1540_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1530_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1530_IEs_hsdn_Cell_r15_e_hsdn_Cell_r15_Optional(_buffer, _size, _lidx, &p->hsdn_Cell_r15);
	_serSysDecCellSelectionInfoCE_v1530_SystemInformationBlockType1_v1530_IEs_cellSelectionInfoCE_v1530_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_v1530);
	_serSysDecSystemInformationBlockType1_v1530_IEs_crs_IntfMitigConfig_r15_crs_IntfMitigConfig_r15_Optional(_buffer, _size, _lidx, &p->crs_IntfMitigConfig_r15);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellBarred_CRS_r15 = (SystemInformationBlockType1_v1530_IEs_cellBarred_CRS_r15_e)_tmp;
	}
	_serSysDecPLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList_v1530);
	_serSysDecPosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(_buffer, _size, _lidx, _mem, &p->posSchedulingInfoList_r15);
	_serSysDecSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(_buffer, _size, _lidx, _mem, &p->cellAccessRelatedInfo_5GC_r15);
	_serSysDecSystemInformationBlockType1_v1530_IEs_ims_EmergencySupport5GC_r15_e_ims_EmergencySupport5GC_r15_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport5GC_r15);
	_serSysDecSystemInformationBlockType1_v1530_IEs_eCallOverIMS_Support5GC_r15_e_eCallOverIMS_Support5GC_r15_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support5GC_r15);
	_serSysDecSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1530_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1450_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1450_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_v1450_SystemInformationBlockType1_v1450_IEs_tdd_Config_v1450_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1450);
	_serSysDecSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1450_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1430_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1430_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1430_IEs_eCallOverIMS_Support_r14_e_eCallOverIMS_Support_r14_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support_r14);
	_serSysDecTDD_Config_v1430_SystemInformationBlockType1_v1430_IEs_tdd_Config_v1430_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1430);
	_serSysDecCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->cellAccessRelatedInfoList_r14);
	_serSysDecSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1430_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1360_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1360_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellSelectionInfoCE1_v1360_SystemInformationBlockType1_v1360_IEs_cellSelectionInfoCE1_v1360_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_v1360);
	_serSysDecSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1360_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1350_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1350_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellSelectionInfoCE1_r13_SystemInformationBlockType1_v1350_IEs_cellSelectionInfoCE1_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE1_r13);
	_serSysDecSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1350_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1320_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1320_IEs_freqHoppingParametersDL_r13_freqHoppingParametersDL_r13_Optional(_buffer, _size, _lidx, &p->freqHoppingParametersDL_r13);
	_serSysDecSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1320_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1310_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecB10_SystemInformationBlockType1_v1310_IEs_hyperSFN_r13_Optional(_buffer, _size, _lidx, &p->hyperSFN_r13);
	_serSysDecSystemInformationBlockType1_v1310_IEs_eDRX_Allowed_r13_e_eDRX_Allowed_r13_Optional(_buffer, _size, _lidx, &p->eDRX_Allowed_r13);
	_serSysDecCellSelectionInfoCE_r13_SystemInformationBlockType1_v1310_IEs_cellSelectionInfoCE_r13_Optional(_buffer, _size, _lidx, &p->cellSelectionInfoCE_r13);
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(_buffer, _size, _lidx, _mem, &p->bandwidthReducedAccessRelatedInfo_r13);
	_serSysDecSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1310_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1250_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1250_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v1250_IEs_cellAccessRelatedInfo_v1250(_buffer, _size, _lidx, &p->cellAccessRelatedInfo_v1250);
	_serSysDecCellSelectionInfo_v1250_SystemInformationBlockType1_v1250_IEs_cellSelectionInfo_v1250_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v1250);
	_serSysDecSystemInformationBlockType1_v1250_IEs_freqBandIndicatorPriority_r12_e_freqBandIndicatorPriority_r12_Optional(_buffer, _size, _lidx, &p->freqBandIndicatorPriority_r12);
	_serSysDecSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1250_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1130_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1130_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_Config_v1130_SystemInformationBlockType1_v1130_IEs_tdd_Config_v1130_Optional(_buffer, _size, _lidx, &p->tdd_Config_v1130);
	_serSysDecCellSelectionInfo_v1130_SystemInformationBlockType1_v1130_IEs_cellSelectionInfo_v1130_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v1130);
	_serSysDecSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v1130_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v920_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v920_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_v920_IEs_ims_EmergencySupport_r9_e_ims_EmergencySupport_r9_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport_r9);
	_serSysDecCellSelectionInfo_v920_SystemInformationBlockType1_v920_IEs_cellSelectionInfo_v920_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo_v920);
	_serSysDecSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v920_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v890_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v890_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSystemInformationBlockType1_v890_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemInformationBlockType1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemInformationBlockType1* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSystemInformationBlockType1_cellAccessRelatedInfo(_buffer, _size, _lidx, _mem, &p->cellAccessRelatedInfo);
	_serSysDecSystemInformationBlockType1_cellSelectionInfo(_buffer, _size, _lidx, &p->cellSelectionInfo);
	_serSysDecP_Max_SystemInformationBlockType1_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	NTOH_8(p->freqBandIndicator, &_buffer[*_lidx], _lidx);
	NTOH_32(p->schedulingInfoList.d, &_buffer[*_lidx], _lidx);
	p->schedulingInfoList.v = serMalloc(_mem, p->schedulingInfoList.d * sizeof(struct SchedulingInfo));
	for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
		_serSysDecSchedulingInfo(_buffer, _size, _lidx, _mem, &p->schedulingInfoList.v[i1]);
	}
	_serSysDecTDD_Config_SystemInformationBlockType1_tdd_Config_Optional(_buffer, _size, _lidx, &p->tdd_Config);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_WindowLength = (SystemInformationBlockType1_si_WindowLength_e)_tmp;
	}
	NTOH_8(p->systemInfoValueTag, &_buffer[*_lidx], _lidx);
	_serSysDecSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_c1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union BCCH_DL_SCH_MessageType_c1_Value* p, enum BCCH_DL_SCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serSysDecSystemInformation(_buffer, _size, _lidx, _mem, &p->systemInformation);
	}
	if (d == BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serSysDecSystemInformationBlockType1(_buffer, _size, _lidx, _mem, &p->systemInformationBlockType1);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_c1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum BCCH_DL_SCH_MessageType_c1_Sel)_tmp;
	}
	_serSysDecBCCH_DL_SCH_MessageType_c1_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_DL_SCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union BCCH_DL_SCH_MessageType_Value* p, enum BCCH_DL_SCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_c1) {
		_serSysDecBCCH_DL_SCH_MessageType_c1(_buffer, _size, _lidx, _mem, &p->c1);
	}
	if (d == BCCH_DL_SCH_MessageType_messageClassExtension) {
		_serSysDecBCCH_DL_SCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum BCCH_DL_SCH_MessageType_Sel)_tmp;
	}
	_serSysDecBCCH_DL_SCH_MessageType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBCCH_DL_SCH_MessageType(_buffer, _size, _lidx, _mem, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSI_List_Type_SIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct BCCH_DL_SCH_Message));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecBCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSegmentedSI_List_Type_SegmentedSIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(SI_List_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1].d, &_buffer[*_lidx], _lidx);
		p->v.v[i1].v = serMalloc(_mem, p->v.v[i1].d * sizeof(struct BCCH_DL_SCH_Message));
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serSysDecBCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBCCH_BCH_Message_BcchInfo_Type_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serSysDecBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(_buffer, _size, _lidx, _mem, &p->SIB1);
	_serSysDecSI_List_Type_SIs_Optional(_buffer, _size, _lidx, _mem, &p->SIs);
	_serSysDecSegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, _mem, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchInfo_Type_BcchInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcchInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecNull_Type_BcchConfig_Type_StopSib1Transmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Null_Type_BcchConfig_Type_StopSib1Transmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBcchToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysDecBcchToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, _mem, &p->Pdsch);
	_serSysDecBcchInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, _mem, &p->BcchInfo);
	_serSysDecNull_Type_BcchConfig_Type_StopSib1Transmission_Optional(_buffer, _size, _lidx, &p->StopSib1Transmission);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcchConfig_Type_BcchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BcchConfig_Type_BcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDciDlInfoCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Config_v1310_PCCH_Config_v13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_Config_v1310_PCCH_Config_v13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPCCH_Config_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);
	_serSysDecPCCH_Config_v1310_PCCH_Config_v13_Optional(_buffer, _size, _lidx, &p->PCCH_Config_v13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcchConfig_Type_PcchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PcchConfig_Type_PcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCA_CellInitialConfig_Type_CA_CellInitialConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CA_CellInitialConfig_Type_CA_CellInitialConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CA_CellInitialConfig_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRToPbchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Bcch_BRToPbchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->EnableMIB_Repetition, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRToPbchConfig_Type_Pbch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Bcch_BRToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcch_BRToPbchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSib1_BRSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Sib1_BRSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->SchedulingInfoSIB1_BR_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSib1_BRSchedul_Type_Sib1_BRSchedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Sib1_BRSchedul_Type_Sib1_BRSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSib1_BRSchedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBandwidthReducedAccessRelatedInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, BandwidthReducedAccessRelatedInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_WindowLength_BR_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_WindowLength_BR_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_RepetitionPattern_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_RepetitionPattern_r13_e)_tmp;
	}
	_serSysDecSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(_buffer, _size, _lidx, _mem, &p->schedulingInfoList_BR_r13);
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_fdd_DownlinkOrTddSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_DownlinkOrTddSubframeBitmapBR_r13);
	_serSysDecB10_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_fdd_UplinkSubframeBitmapBR_r13_Optional(_buffer, _size, _lidx, &p->fdd_UplinkSubframeBitmapBR_r13);
	NTOH_8(p->startSymbolBR_r13, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_HoppingConfigCommon_r13 = (SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_HoppingConfigCommon_r13_e)_tmp;
	}
	_serSysDecSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_si_ValidityTime_r13_e_si_ValidityTime_r13_Optional(_buffer, _size, _lidx, &p->si_ValidityTime_r13);
	_serSysDecSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(_buffer, _size, _lidx, _mem, &p->systemInfoValueTagList_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBandwidthReducedAccessRelatedInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SI_SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(int32_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRToPdschConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSib1_BRSchedul_Type_Sib1_BRSchedul_Optional(_buffer, _size, _lidx, &p->Sib1_BRSchedul);
	_serSysDecBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(_buffer, _size, _lidx, _mem, &p->SiSchedul);
	_serSysDecSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(_buffer, _size, _lidx, _mem, &p->SubframeOffsetList);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRToPdschConfig_Type_Pdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcch_BRToPdschConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_BR_r13_c1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union BCCH_DL_SCH_MessageType_BR_r13_c1_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformation_BR_r13) {
		_serSysDecSystemInformation(_buffer, _size, _lidx, _mem, &p->systemInformation_BR_r13);
	}
	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformationBlockType1_BR_r13) {
		_serSysDecSystemInformationBlockType1(_buffer, _size, _lidx, _mem, &p->systemInformationBlockType1_BR_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_BR_r13_c1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_MessageType_BR_r13_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum BCCH_DL_SCH_MessageType_BR_r13_c1_Sel)_tmp;
	}
	_serSysDecBCCH_DL_SCH_MessageType_BR_r13_c1_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_BR_r13_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_BR_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union BCCH_DL_SCH_MessageType_BR_r13_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1) {
		_serSysDecBCCH_DL_SCH_MessageType_BR_r13_c1(_buffer, _size, _lidx, _mem, &p->c1);
	}
	if (d == BCCH_DL_SCH_MessageType_BR_r13_messageClassExtension) {
		_serSysDecBCCH_DL_SCH_MessageType_BR_r13_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_MessageType_BR_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_MessageType_BR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum BCCH_DL_SCH_MessageType_BR_r13_Sel)_tmp;
	}
	_serSysDecBCCH_DL_SCH_MessageType_BR_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_Message_BR(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_Message_BR* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBCCH_DL_SCH_MessageType_BR_r13(_buffer, _size, _lidx, _mem, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysDecBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBR_SI_List_Type_SIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BR_SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct BCCH_DL_SCH_Message_BR));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBR_SegmentedSI_List_Type_SegmentedSIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(BR_SI_List_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1].d, &_buffer[*_lidx], _lidx);
		p->v.v[i1].v = serMalloc(_mem, p->v.v[i1].d * sizeof(struct BCCH_DL_SCH_Message_BR));
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serSysDecBCCH_DL_SCH_Message_BR(_buffer, _size, _lidx, _mem, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBCCH_BCH_Message_Bcch_BRInfo_Type_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serSysDecBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(_buffer, _size, _lidx, _mem, &p->SIB1);
	_serSysDecBR_SI_List_Type_SIs_Optional(_buffer, _size, _lidx, _mem, &p->SIs);
	_serSysDecBR_SegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, _mem, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRInfo_Type_BcchInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcch_BRInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecNull_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Null_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBcch_BRToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serSysDecBcch_BRToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, _mem, &p->Pdsch);
	_serSysDecBcch_BRInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, _mem, &p->BcchInfo);
	_serSysDecNull_Type_Bcch_BRConfig_Type_StopSib1Transmission_Optional(_buffer, _size, _lidx, &p->StopSib1Transmission);

	return SIDL_STATUS_OK;
}

static int _serSysDecBcch_BRConfig_Type_BRBcchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Bcch_BRConfig_Type_BRBcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBcch_BRConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subframeStartPosition_r13 = (LAA_SCellConfiguration_r13_subframeStartPosition_r13_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->laa_SCellSubframeConfig_r13[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecLAA_SCellConfiguration_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfigLAA_UL_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfigLAA_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingCellId_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cif_InSchedulingCell_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCrossCarrierSchedulingConfigLAA_UL_r14(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfigLAA_UL_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value* p, enum LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup) {
		_serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Sel)_tmp;
	}
	_serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecLBT_Config_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union LBT_Config_r14_Value* p, enum LBT_Config_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == LBT_Config_r14_maxEnergyDetectionThreshold_r14) {
		NTOH_8(p->maxEnergyDetectionThreshold_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == LBT_Config_r14_energyDetectionThresholdOffset_r14) {
		NTOH_8(p->energyDetectionThresholdOffset_r14, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecLBT_Config_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LBT_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum LBT_Config_r14_Sel)_tmp;
	}
	_serSysDecLBT_Config_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecLBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecLBT_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductions_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductions_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL1_r13 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL2_r13 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL3_r13 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL4_r13 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL5_r13 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductions_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCCH_CandidateReductions_r13_Value* p, enum PDCCH_CandidateReductions_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCCH_CandidateReductions_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCCH_CandidateReductions_r13_setup) {
		_serSysDecPDCCH_CandidateReductions_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductions_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductions_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCCH_CandidateReductions_r13_Sel)_tmp;
	}
	_serSysDecPDCCH_CandidateReductions_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCCH_CandidateReductions_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductionsLAA_UL_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL1_r14 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL2_r14 = (PDCCH_CandidateReductionValue_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL3_r14 = (PDCCH_CandidateReductionValue_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL4_r14 = (PDCCH_CandidateReductionValue_r14_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcch_candidateReductionAL5_r14 = (PDCCH_CandidateReductionValue_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCCH_CandidateReductionsLAA_UL_r14_Value* p, enum PDCCH_CandidateReductionsLAA_UL_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCCH_CandidateReductionsLAA_UL_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCCH_CandidateReductionsLAA_UL_r14_setup) {
		_serSysDecPDCCH_CandidateReductionsLAA_UL_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductionsLAA_UL_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCCH_CandidateReductionsLAA_UL_r14_Sel)_tmp;
	}
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format0B_r14_e_maxNumberOfSchedSubframes_Format0B_r14_Optional(_buffer, _size, _lidx, &p->maxNumberOfSchedSubframes_Format0B_r14);
	_serSysDecPDCCH_ConfigLAA_r14_maxNumberOfSchedSubframes_Format4B_r14_e_maxNumberOfSchedSubframes_Format4B_r14_Optional(_buffer, _size, _lidx, &p->maxNumberOfSchedSubframes_Format4B_r14);
	_serSysDecPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format0A_r14_e_skipMonitoringDCI_Format0A_r14_Optional(_buffer, _size, _lidx, &p->skipMonitoringDCI_Format0A_r14);
	_serSysDecPDCCH_ConfigLAA_r14_skipMonitoringDCI_Format4A_r14_e_skipMonitoringDCI_Format4A_r14_Optional(_buffer, _size, _lidx, &p->skipMonitoringDCI_Format4A_r14);
	_serSysDecPDCCH_CandidateReductions_r13_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0A_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format0A_r14);
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4A_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format4A_r14);
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format0B_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format0B_r14);
	_serSysDecPDCCH_CandidateReductionsLAA_UL_r14_PDCCH_ConfigLAA_r14_pdcch_CandidateReductions_Format4B_r14_Optional(_buffer, _size, _lidx, &p->pdcch_CandidateReductions_Format4B_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCCH_ConfigLAA_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (LAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint8_t_SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup_srs_SubframeIndication_r14_Optional(_buffer, _size, _lidx, &p->srs_SubframeIndication_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_v1430_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup) {
		_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigDedicatedAperiodic_v1430_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecLAA_SCellConfiguration_v1430_crossCarrierSchedulingConfig_UL_r14_crossCarrierSchedulingConfig_UL_r14_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_UL_r14);
	_serSysDecLBT_Config_r14_LAA_SCellConfiguration_v1430_lbt_Config_r14_Optional(_buffer, _size, _lidx, &p->lbt_Config_r14);
	_serSysDecPDCCH_ConfigLAA_r14_LAA_SCellConfiguration_v1430_pdcch_ConfigLAA_r14_Optional(_buffer, _size, _lidx, &p->pdcch_ConfigLAA_r14);
	_serSysDecLAA_SCellConfiguration_v1430_absenceOfAnyOtherTechnology_r14_e_absenceOfAnyOtherTechnology_r14_Optional(_buffer, _size, _lidx, &p->absenceOfAnyOtherTechnology_r14);
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_v1430_LAA_SCellConfiguration_v1430_soundingRS_UL_ConfigDedicatedAperiodic_v1430_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicatedAperiodic_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecLAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecLAA_SCellConfiguration_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBasicCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BasicCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCellConfigCapability_Type_ConfigCapability_Optional(_buffer, _size, _lidx, &p->ConfigCapability);
	_serSysDecStaticCellInfo_Type_StaticCellInfo_Optional(_buffer, _size, _lidx, &p->StaticCellInfo);
	_serSysDecPhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(_buffer, _size, _lidx, _mem, &p->PhysicalLayerConfigDL);
	_serSysDecInitialCellPower_Type_InitialCellPower_Optional(_buffer, _size, _lidx, &p->InitialCellPower);
	_serSysDecBcchConfig_Type_BcchConfig_Optional(_buffer, _size, _lidx, _mem, &p->BcchConfig);
	_serSysDecPcchConfig_Type_PcchConfig_Optional(_buffer, _size, _lidx, _mem, &p->PcchConfig);
	_serSysDecCA_CellInitialConfig_Type_CA_CellInitialConfig_Optional(_buffer, _size, _lidx, &p->CA_CellInitialConfig);
	_serSysDecBcch_BRConfig_Type_BRBcchConfig_Optional(_buffer, _size, _lidx, _mem, &p->BRBcchConfig);
	_serSysDecLAA_SCellConfiguration_r13_LAA_SCellConfiguration_Optional(_buffer, _size, _lidx, &p->LAA_SCellConfiguration);
	_serSysDecLAA_SCellConfiguration_v1430_LAA_SCellConfiguration_v1430_Optional(_buffer, _size, _lidx, &p->LAA_SCellConfiguration_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecBasicCellConfig_Type_Basic_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BasicCellConfig_Type_Basic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecBasicCellConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecC_RNTI_C_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct C_RNTI_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_ConfigInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->rootSequenceIndex, &_buffer[*_lidx], _lidx);
	_serSysDecPRACH_ConfigInfo_PRACH_Config_prach_ConfigInfo_Optional(_buffer, _size, _lidx, &p->prach_ConfigInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(RSRP_Range));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value* p, enum PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->fdd_r13 = (PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_fdd_r13_e)_tmp;
		}
	}
	if (d == PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->tdd_r13 = (PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_tdd_r13_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Sel)_tmp;
	}
	_serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PRACH_ParametersCE_r13));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPRACH_ParametersCE_r13(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_Config_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(_buffer, _size, _lidx, _mem, &p->rsrp_ThresholdsPrachInfoList_r13);
	_serSysDecPRACH_Config_v1310_mpdcch_startSF_CSS_RA_r13_mpdcch_startSF_CSS_RA_r13_Optional(_buffer, _size, _lidx, &p->mpdcch_startSF_CSS_RA_r13);
	_serSysDecUint8_t_PRACH_Config_v1310_prach_HoppingOffset_r13_Optional(_buffer, _size, _lidx, &p->prach_HoppingOffset_r13);
	_serSysDecPRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(_buffer, _size, _lidx, _mem, &p->prach_ParametersListCE_r13);
	_serSysDecUint8_t_PRACH_Config_v1310_initial_CE_level_r13_Optional(_buffer, _size, _lidx, &p->initial_CE_level_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1310_prach_Config_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_Config_v1310_prach_Config_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_Config_v1310(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_v1430_prach_Config_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PRACH_Config_v1430_prach_Config_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_Config_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPRACH_Config(_buffer, _size, _lidx, &p->prach_Config);
	_serSysDecPRACH_Config_v1310_prach_Config_v1310_Optional(_buffer, _size, _lidx, _mem, &p->prach_Config_v1310);
	_serSysDecPRACH_Config_v1430_prach_Config_v1430_Optional(_buffer, _size, _lidx, &p->prach_Config_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PRACH_Config_Type_Value* p, enum PRACH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PRACH_Config_Type_R8andLater) {
		_serSysDecPRACH_Config_R8andLater_Type(_buffer, _size, _lidx, _mem, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PRACH_Config_Type_Sel)_tmp;
	}
	_serSysDecPRACH_Config_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPRACH_Config_Type_Prach_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PRACH_Config_Type_Prach_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPRACH_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigCommon_v1310(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigCommon(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serSysDecPUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, _mem, &p->pucch_ConfigCommon_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigCommon_Type_Value* p, enum PUCCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigCommon_Type_R8andLater) {
		_serSysDecPUCCH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, _mem, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigCommon_Type_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigCommon_Type_Common_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_ackNackRepetition_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_ackNackRepetition_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repetitionFactor = (PUCCH_ConfigDedicated_ackNackRepetition_setup_repetitionFactor_e)_tmp;
	}
	NTOH_16(p->n1PUCCH_AN_Rep, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_ackNackRepetition_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_ackNackRepetition_Value* p, enum PUCCH_ConfigDedicated_ackNackRepetition_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_ackNackRepetition_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_ackNackRepetition_setup) {
		_serSysDecPUCCH_ConfigDedicated_ackNackRepetition_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_ackNackRepetition(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_ackNackRepetition* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_ackNackRepetition_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_ackNackRepetition_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_ackNackRepetition(_buffer, _size, _lidx, &p->ackNackRepetition);
	_serSysDecPUCCH_ConfigDedicated_tdd_AckNackFeedbackMode_e_tdd_AckNackFeedbackMode_Optional(_buffer, _size, _lidx, &p->tdd_AckNackFeedbackMode);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_16(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->n3PUCCH_AN_ListP1_r13.d, &_buffer[*_lidx], _lidx);
	p->n3PUCCH_AN_ListP1_r13.v = serMalloc(_mem, p->n3PUCCH_AN_ListP1_r13.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->n3PUCCH_AN_ListP1_r13.d; i1++) {
		NTOH_16(p->n3PUCCH_AN_ListP1_r13.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Format3_Conf_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Format3_Conf_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->n3PUCCH_AN_List_r13);
	_serSysDecPUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(_buffer, _size, _lidx, _mem, &p->twoAntennaPortActivatedPUCCH_Format3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->n1PUCCH_AN_CS_List_r10.d, &_buffer[*_lidx], _lidx);
	p->n1PUCCH_AN_CS_List_r10.v = serMalloc(_mem, p->n1PUCCH_AN_CS_List_r10.d * sizeof(N1PUCCH_AN_CS_r10));
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r10.d; i1++) {
		NTOH_32(p->n1PUCCH_AN_CS_List_r10.v[i1].d, &_buffer[*_lidx], _lidx);
		p->n1PUCCH_AN_CS_List_r10.v[i1].v = serMalloc(_mem, p->n1PUCCH_AN_CS_List_r10.v[i1].d * sizeof(uint16_t));
		for (size_t i2 = 0; i2 < p->n1PUCCH_AN_CS_List_r10.v[i1].d; i2++) {
			NTOH_16(p->n1PUCCH_AN_CS_List_r10.v[i1].v[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup) {
		_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(_buffer, _size, _lidx, _mem, &p->n1PUCCH_AN_CS_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_format3_r10) {
		_serSysDecPUCCH_Format3_Conf_r13(_buffer, _size, _lidx, _mem, &p->format3_r10);
	}
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10) {
		_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(_buffer, _size, _lidx, _mem, &p->channelSelection_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(_buffer, _size, _lidx, _mem, &p->pucch_Format_r10);
	_serSysDecPUCCH_ConfigDedicated_v1020_twoAntennaPortActivatedPUCCH_Format1a1b_r10_e_twoAntennaPortActivatedPUCCH_Format1a1b_r10_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format1a1b_r10);
	_serSysDecPUCCH_ConfigDedicated_v1020_simultaneousPUCCH_PUSCH_r10_e_simultaneousPUCCH_PUSCH_r10_Optional(_buffer, _size, _lidx, &p->simultaneousPUCCH_PUSCH_r10);
	_serSysDecUint16_t_PUCCH_ConfigDedicated_v1020_n1PUCCH_AN_RepP1_r10_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_RepP1_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1020(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->n1PUCCH_AN_CS_ListP1_r11.d, &_buffer[*_lidx], _lidx);
	p->n1PUCCH_AN_CS_ListP1_r11.v = serMalloc(_mem, p->n1PUCCH_AN_CS_ListP1_r11.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_ListP1_r11.d; i1++) {
		NTOH_16(p->n1PUCCH_AN_CS_ListP1_r11.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value* p, enum PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup) {
		_serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nPUCCH_Identity_r11, &_buffer[*_lidx], _lidx);
	NTOH_16(p->n1PUCCH_AN_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value* p, enum PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup) {
		_serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(_buffer, _size, _lidx, _mem, &p->n1PUCCH_AN_CS_v1130);
	_serSysDecPUCCH_ConfigDedicated_v1130_nPUCCH_Param_r11_nPUCCH_Param_r11_Optional(_buffer, _size, _lidx, &p->nPUCCH_Param_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1130(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nkaPUCCH_AN_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value* p, enum PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup) {
		_serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_v1250_nkaPUCCH_Param_r12(_buffer, _size, _lidx, &p->nkaPUCCH_Param_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated(_buffer, _size, _lidx, &p->pucch_ConfigDedicated);
	_serSysDecPUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, _mem, &p->pucch_ConfigDedicated_v1020);
	_serSysDecPUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(_buffer, _size, _lidx, _mem, &p->pucch_ConfigDedicated_v1130);
	_serSysDecPUCCH_ConfigDedicated_v1250_pucch_ConfigDedicated_v1250_Optional(_buffer, _size, _lidx, &p->pucch_ConfigDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repetitionFactor_r13 = (PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup_repetitionFactor_r13_e)_tmp;
	}
	NTOH_16(p->n1PUCCH_AN_Rep_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value* p, enum PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_ackNackRepetition_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_16(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->n3PUCCH_AN_ListP1_r13.d, &_buffer[*_lidx], _lidx);
	p->n3PUCCH_AN_ListP1_r13.v = serMalloc(_mem, p->n3PUCCH_AN_ListP1_r13.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->n3PUCCH_AN_ListP1_r13.d; i1++) {
		NTOH_16(p->n3PUCCH_AN_ListP1_r13.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->n3PUCCH_AN_List_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(_buffer, _size, _lidx, _mem, &p->twoAntennaPortActivatedPUCCH_Format3_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->n1PUCCH_AN_CS_List_r13.d, &_buffer[*_lidx], _lidx);
	p->n1PUCCH_AN_CS_List_r13.v = serMalloc(_mem, p->n1PUCCH_AN_CS_List_r13.d * sizeof(N1PUCCH_AN_CS_r10));
	for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r13.d; i1++) {
		NTOH_32(p->n1PUCCH_AN_CS_List_r13.v[i1].d, &_buffer[*_lidx], _lidx);
		p->n1PUCCH_AN_CS_List_r13.v[i1].v = serMalloc(_mem, p->n1PUCCH_AN_CS_List_r13.v[i1].d * sizeof(uint16_t));
		for (size_t i2 = 0; i2 < p->n1PUCCH_AN_CS_List_r13.v[i1].d; i2++) {
			NTOH_16(p->n1PUCCH_AN_CS_List_r13.v[i1].v[i2], &_buffer[*_lidx], _lidx);
		}
	}
	NTOH_32(p->dummy1.d, &_buffer[*_lidx], _lidx);
	p->dummy1.v = serMalloc(_mem, p->dummy1.d * sizeof(uint16_t));
	for (size_t i1 = 0; i1 < p->dummy1.d; i1++) {
		NTOH_16(p->dummy1.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(_buffer, _size, _lidx, _mem, &p->n1PUCCH_AN_CS_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecFormat4_resource_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Format4_resource_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->startingPRB_format4_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->numberOfPRB_format4_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Format4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct Format4_resource_r13));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecFormat4_resource_r13(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 4; i1++) {
		_serSysDecFormat4_resource_r13(_buffer, _size, _lidx, &p->format4_resourceConfiguration_r13[i1]);
	}
	_serSysDecFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->format4_MultiCSI_resourceConfiguration_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecFormat5_resource_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Format5_resource_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->startingPRB_format5_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cdm_index_format5_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecFormat5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Format5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecFormat5_resource_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 4; i1++) {
		_serSysDecFormat5_resource_r13(_buffer, _size, _lidx, &p->format5_resourceConfiguration_r13[i1]);
	}
	_serSysDecFormat5_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13_format5_MultiCSI_resourceConfiguration_r13_Optional(_buffer, _size, _lidx, &p->format5_MultiCSI_resourceConfiguration_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_r13_pucch_Format_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(_buffer, _size, _lidx, _mem, &p->format3_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(_buffer, _size, _lidx, _mem, &p->channelSelection_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(_buffer, _size, _lidx, _mem, &p->format4_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_format5_r13(_buffer, _size, _lidx, &p->format5_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nPUCCH_Identity_r13, &_buffer[*_lidx], _lidx);
	NTOH_16(p->n1PUCCH_AN_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value* p, enum PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nkaPUCCH_AN_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value* p, enum PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pucch_NumRepetitionCE_format1_r13 = (PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA_pucch_NumRepetitionCE_format1_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pucch_NumRepetitionCE_format2_r13 = (PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA_pucch_NumRepetitionCE_format2_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pucch_NumRepetitionCE_format1_r13 = (PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB_pucch_NumRepetitionCE_format1_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pucch_NumRepetitionCE_format2_r13 = (PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB_pucch_NumRepetitionCE_format2_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeA(_buffer, _size, _lidx, &p->modeA);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_modeB(_buffer, _size, _lidx, &p->modeB);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup) {
		_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_r13_ackNackRepetition_r13(_buffer, _size, _lidx, &p->ackNackRepetition_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_tdd_AckNackFeedbackMode_r13_e_tdd_AckNackFeedbackMode_r13_Optional(_buffer, _size, _lidx, &p->tdd_AckNackFeedbackMode_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(_buffer, _size, _lidx, _mem, &p->pucch_Format_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_twoAntennaPortActivatedPUCCH_Format1a1b_r13_e_twoAntennaPortActivatedPUCCH_Format1a1b_r13_Optional(_buffer, _size, _lidx, &p->twoAntennaPortActivatedPUCCH_Format1a1b_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_simultaneousPUCCH_PUSCH_r13_e_simultaneousPUCCH_PUSCH_r13_Optional(_buffer, _size, _lidx, &p->simultaneousPUCCH_PUSCH_r13);
	_serSysDecUint16_t_PUCCH_ConfigDedicated_r13_n1PUCCH_AN_RepP1_r13_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN_RepP1_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_nPUCCH_Param_r13_nPUCCH_Param_r13_Optional(_buffer, _size, _lidx, &p->nPUCCH_Param_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_nkaPUCCH_Param_r13_nkaPUCCH_Param_r13_Optional(_buffer, _size, _lidx, &p->nkaPUCCH_Param_r13);
	NTOH_8(p->spatialBundlingPUCCH_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->spatialBundlingPUSCH_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->harq_TimingTDD_r13, &_buffer[*_lidx], _lidx);
	_serSysDecPUCCH_ConfigDedicated_r13_codebooksizeDetermination_r13_e_codebooksizeDetermination_r13_Optional(_buffer, _size, _lidx, &p->codebooksizeDetermination_r13);
	_serSysDecUint8_t_PUCCH_ConfigDedicated_r13_maximumPayloadCoderate_r13_Optional(_buffer, _size, _lidx, &p->maximumPayloadCoderate_r13);
	_serSysDecPUCCH_ConfigDedicated_r13_pucch_NumRepetitionCE_r13_pucch_NumRepetitionCE_r13_Optional(_buffer, _size, _lidx, &p->pucch_NumRepetitionCE_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_R13andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_R13andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigDedicated_r13(_buffer, _size, _lidx, _mem, &p->pucch_ConfigDedicated_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PUCCH_ConfigDedicated_Type_Value* p, enum PUCCH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUCCH_ConfigDedicated_Type_R8andLater) {
		_serSysDecPUCCH_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, _mem, &p->R8andLater);
	}
	if (d == PUCCH_ConfigDedicated_Type_R13andLater) {
		_serSysDecPUCCH_ConfigDedicated_R13andLater_Type(_buffer, _size, _lidx, _mem, &p->R13andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUCCH_ConfigDedicated_Type_Sel)_tmp;
	}
	_serSysDecPUCCH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_ConfigDedicated_Type_Dedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_ConfigDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_ConfigDedicated_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUCCH_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, _mem, &p->Common);
	_serSysDecPUCCH_ConfigDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, _mem, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUCCH_Configuration_Type_Pucch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PUCCH_Configuration_Type_Pucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUCCH_Configuration_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigCommon_v1270(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigCommon_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigCommon(_buffer, _size, _lidx, &p->pusch_ConfigCommon);
	_serSysDecPUSCH_ConfigCommon_v1270_pusch_ConfigCommon_v1270_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1270);
	_serSysDecPUSCH_ConfigCommon_v1310_pusch_ConfigCommon_v1310_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigCommon_Type_Value* p, enum PUSCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigCommon_Type_R8andLater) {
		_serSysDecPUSCH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigCommon_Type_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigCommon_Type_Common_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_RI_Index, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020_betaOffsetMC_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_MC_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_RI_Index_MC_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_MC_r10, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated_v1020_betaOffsetMC_r10_betaOffsetMC_r10_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r10);
	_serSysDecPUSCH_ConfigDedicated_v1020_groupHoppingDisabled_r10_e_groupHoppingDisabled_r10_Optional(_buffer, _size, _lidx, &p->groupHoppingDisabled_r10);
	_serSysDecPUSCH_ConfigDedicated_v1020_dmrs_WithOCC_Activated_r10_e_dmrs_WithOCC_Activated_r10_Optional(_buffer, _size, _lidx, &p->dmrs_WithOCC_Activated_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nPUSCH_Identity_r11, &_buffer[*_lidx], _lidx);
	NTOH_16(p->nDMRS_CSH_Identity_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value* p, enum PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup) {
		_serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated_v1130_pusch_DMRS_r11(_buffer, _size, _lidx, &p->pusch_DMRS_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_MC_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_RI_Index_MC_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_MC_SubframeSet2_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_RI_Index_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	_serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value* p, enum PUSCH_ConfigDedicated_v1250_uciOnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_v1250_uciOnPUSCH_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup) {
		_serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250_uciOnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigDedicated_v1250_uciOnPUSCH_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated_v1250_uciOnPUSCH(_buffer, _size, _lidx, &p->uciOnPUSCH);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated(_buffer, _size, _lidx, &p->pusch_ConfigDedicated);
	_serSysDecPUSCH_ConfigDedicated_v1020_pusch_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1020);
	_serSysDecPUSCH_ConfigDedicated_v1130_pusch_ConfigDedicated_v1130_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1130);
	_serSysDecPUSCH_ConfigDedicated_v1250_pusch_ConfigDedicated_v1250_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_betaOffsetMC_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_betaOffsetMC_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_MC_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffset2_ACK_Index_MC_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_MC_r13);
	NTOH_8(p->betaOffset_RI_Index_MC_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_MC_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_r13_betaOffsetMC_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->nPUSCH_Identity_r13, &_buffer[*_lidx], _lidx);
	NTOH_16(p->nDMRS_CSH_Identity_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value* p, enum PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup) {
		_serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_MC_SubframeSet2_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffset2_ACK_Index_MC_SubframeSet2_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_MC_SubframeSet2_r13);
	NTOH_8(p->betaOffset_RI_Index_MC_SubframeSet2_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_MC_SubframeSet2_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_SubframeSet2_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffset2_ACK_Index_SubframeSet2_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_SubframeSet2_r13);
	NTOH_8(p->betaOffset_RI_Index_SubframeSet2_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_SubframeSet2_r13, &_buffer[*_lidx], _lidx);
	_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup_betaOffsetMC_r12_betaOffsetMC_r12_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigDedicated_r13_uciOnPUSCH_Value* p, enum PUSCH_ConfigDedicated_r13_uciOnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_r13_uciOnPUSCH_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PUSCH_ConfigDedicated_r13_uciOnPUSCH_setup) {
		_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_uciOnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigDedicated_r13_uciOnPUSCH_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->betaOffset_ACK_Index_r13, &_buffer[*_lidx], _lidx);
	_serSysDecUint8_t_PUSCH_ConfigDedicated_r13_betaOffset2_ACK_Index_r13_Optional(_buffer, _size, _lidx, &p->betaOffset2_ACK_Index_r13);
	NTOH_8(p->betaOffset_RI_Index_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->betaOffset_CQI_Index_r13, &_buffer[*_lidx], _lidx);
	_serSysDecPUSCH_ConfigDedicated_r13_betaOffsetMC_r13_betaOffsetMC_r13_Optional(_buffer, _size, _lidx, &p->betaOffsetMC_r13);
	_serSysDecPUSCH_ConfigDedicated_r13_groupHoppingDisabled_r13_e_groupHoppingDisabled_r13_Optional(_buffer, _size, _lidx, &p->groupHoppingDisabled_r13);
	_serSysDecPUSCH_ConfigDedicated_r13_dmrs_WithOCC_Activated_r13_e_dmrs_WithOCC_Activated_r13_Optional(_buffer, _size, _lidx, &p->dmrs_WithOCC_Activated_r13);
	_serSysDecPUSCH_ConfigDedicated_r13_pusch_DMRS_r11_pusch_DMRS_r11_Optional(_buffer, _size, _lidx, &p->pusch_DMRS_r11);
	_serSysDecPUSCH_ConfigDedicated_r13_uciOnPUSCH_uciOnPUSCH_Optional(_buffer, _size, _lidx, &p->uciOnPUSCH);
	_serSysDecPUSCH_ConfigDedicated_r13_pusch_HoppingConfig_r13_e_pusch_HoppingConfig_r13_Optional(_buffer, _size, _lidx, &p->pusch_HoppingConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (TDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (TDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_PUSCH_UpPTS_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecTDD_PUSCH_UpPTS_r14_setup_symPUSCH_UpPTS_r14_e_symPUSCH_UpPTS_r14_Optional(_buffer, _size, _lidx, &p->symPUSCH_UpPTS_r14);
	_serSysDecTDD_PUSCH_UpPTS_r14_setup_dmrs_LessUpPTS_Config_r14_e_dmrs_LessUpPTS_Config_r14_Optional(_buffer, _size, _lidx, &p->dmrs_LessUpPTS_Config_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TDD_PUSCH_UpPTS_r14_Value* p, enum TDD_PUSCH_UpPTS_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TDD_PUSCH_UpPTS_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == TDD_PUSCH_UpPTS_r14_setup) {
		_serSysDecTDD_PUSCH_UpPTS_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_PUSCH_UpPTS_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TDD_PUSCH_UpPTS_r14_Sel)_tmp;
	}
	_serSysDecTDD_PUSCH_UpPTS_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecTDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTDD_PUSCH_UpPTS_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_setup_tpc_SubframeSet_Configured_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->subframeSet1_DCI_Format0_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeSet1_DCI_Format4_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeSet2_DCI_Format0_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeSet2_DCI_Format4_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->dci_Format0_r14, &_buffer[*_lidx], _lidx);
	NTOH_8(p->dci_Format4_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union Enable256QAM_r14_setup_Value* p, enum Enable256QAM_r14_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Enable256QAM_r14_setup_tpc_SubframeSet_Configured_r14) {
		_serSysDecEnable256QAM_r14_setup_tpc_SubframeSet_Configured_r14(_buffer, _size, _lidx, &p->tpc_SubframeSet_Configured_r14);
	}
	if (d == Enable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14) {
		_serSysDecEnable256QAM_r14_setup_tpc_SubframeSet_NotConfigured_r14(_buffer, _size, _lidx, &p->tpc_SubframeSet_NotConfigured_r14);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Enable256QAM_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Enable256QAM_r14_setup_Sel)_tmp;
	}
	_serSysDecEnable256QAM_r14_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union Enable256QAM_r14_Value* p, enum Enable256QAM_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Enable256QAM_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == Enable256QAM_r14_setup) {
		_serSysDecEnable256QAM_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Enable256QAM_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Enable256QAM_r14_Sel)_tmp;
	}
	_serSysDecEnable256QAM_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEnable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Enable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEnable256QAM_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated_v1430_ce_PUSCH_NB_MaxTBS_r14_e_ce_PUSCH_NB_MaxTBS_r14_Optional(_buffer, _size, _lidx, &p->ce_PUSCH_NB_MaxTBS_r14);
	_serSysDecPUSCH_ConfigDedicated_v1430_ce_PUSCH_MaxBandwidth_r14_e_ce_PUSCH_MaxBandwidth_r14_Optional(_buffer, _size, _lidx, &p->ce_PUSCH_MaxBandwidth_r14);
	_serSysDecTDD_PUSCH_UpPTS_r14_PUSCH_ConfigDedicated_v1430_tdd_PUSCH_UpPTS_r14_Optional(_buffer, _size, _lidx, &p->tdd_PUSCH_UpPTS_r14);
	NTOH_8(p->ul_DMRS_IFDMA_r14, &_buffer[*_lidx], _lidx);
	_serSysDecEnable256QAM_r14_PUSCH_ConfigDedicated_v1430_enable256QAM_r14_Optional(_buffer, _size, _lidx, &p->enable256QAM_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_R13andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_R13andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigDedicated_r13(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_r13);
	_serSysDecPUSCH_ConfigDedicated_v1430_pusch_ConfigDedicated_v1430_Optional(_buffer, _size, _lidx, &p->pusch_ConfigDedicated_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PUSCH_ConfigDedicated_Type_Value* p, enum PUSCH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PUSCH_ConfigDedicated_Type_R8andLater) {
		_serSysDecPUSCH_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == PUSCH_ConfigDedicated_Type_R13andLater) {
		_serSysDecPUSCH_ConfigDedicated_R13andLater_Type(_buffer, _size, _lidx, &p->R13andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PUSCH_ConfigDedicated_Type_Sel)_tmp;
	}
	_serSysDecPUSCH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_ConfigDedicated_Type_Dedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_ConfigDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPUSCH_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serSysDecPUSCH_ConfigDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysDecPUSCH_Configuration_Type_Pusch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PUSCH_Configuration_Type_Pusch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPUSCH_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_TimingAdvanceConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SS_TimingAdvanceConfig_Type_Value* p, enum SS_TimingAdvanceConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SS_TimingAdvanceConfig_Type_InitialValue) {
		NTOH_16(p->InitialValue, &_buffer[*_lidx], _lidx);
	}
	if (d == SS_TimingAdvanceConfig_Type_Relative) {
		NTOH_8(p->Relative, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_TimingAdvanceConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_TimingAdvanceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SS_TimingAdvanceConfig_Type_Sel)_tmp;
	}
	_serSysDecSS_TimingAdvanceConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_TimingAdvanceConfig_Type_TimingAdvance_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_TimingAdvanceConfig_Type_TimingAdvance_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSS_TimingAdvanceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SoundingRS_UL_ConfigCommon_Type_Value* p, enum SoundingRS_UL_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigCommon_Type_R8) {
		_serSysDecSoundingRS_UL_ConfigCommon(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigCommon_Type_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicated_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_Bandwidth = (SoundingRS_UL_ConfigDedicated_setup_srs_Bandwidth_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_HoppingBandwidth = (SoundingRS_UL_ConfigDedicated_setup_srs_HoppingBandwidth_e)_tmp;
	}
	NTOH_8(p->freqDomainPosition, &_buffer[*_lidx], _lidx);
	NTOH_8(p->duration, &_buffer[*_lidx], _lidx);
	NTOH_16(p->srs_ConfigIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->transmissionComb, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cyclicShift = (SoundingRS_UL_ConfigDedicated_setup_cyclicShift_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SoundingRS_UL_ConfigDedicated_Value* p, enum SoundingRS_UL_ConfigDedicated_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicated_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicated_setup) {
		_serSysDecSoundingRS_UL_ConfigDedicated_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigDedicated_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigDedicated_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSoundingRS_UL_ConfigDedicated(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_AntennaPort_r10 = (SRS_AntennaPort_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSoundingRS_UL_ConfigDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSRS_ConfigAp_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SRS_ConfigAp_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_AntennaPortAp_r10 = (SRS_AntennaPort_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->srs_BandwidthAp_r10 = (SRS_ConfigAp_r10_srs_BandwidthAp_r10_e)_tmp;
	}
	NTOH_8(p->freqDomainPositionAp_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->transmissionCombAp_r10, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cyclicShiftAp_r10 = (SRS_ConfigAp_r10_cyclicShiftAp_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SRS_ConfigAp_r10));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->srs_ConfigApDCI_Format0_r10);
	_serSysDecSRS_ConfigAp_r10(_buffer, _size, _lidx, &p->srs_ConfigApDCI_Format1a2b2c_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup) {
		_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_ConfigIndexAp_r10, &_buffer[*_lidx], _lidx);
	_serSysDecSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ConfigApDCI_Format4_r10);
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ActivateAp_r10_srs_ActivateAp_r10_Optional(_buffer, _size, _lidx, &p->srs_ActivateAp_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SoundingRS_UL_ConfigDedicatedAperiodic_r10_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup) {
		_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SoundingRS_UL_ConfigDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSoundingRS_UL_ConfigDedicated_soundingRS_UL_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicated);
	_serSysDecSoundingRS_UL_ConfigDedicated_v1020_soundingRS_UL_ConfigDedicated_v1020_Optional(_buffer, _size, _lidx, &p->soundingRS_UL_ConfigDedicated_v1020);
	_serSysDecSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(_buffer, _size, _lidx, _mem, &p->soundingRS_UL_ConfigDedicatedAperiodic_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SoundingRS_UL_ConfigDedicated_Type_Value* p, enum SoundingRS_UL_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SoundingRS_UL_ConfigDedicated_Type_R8andLater) {
		_serSysDecSoundingRS_UL_ConfigDedicated_R8andLater_Type(_buffer, _size, _lidx, _mem, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSoundingRS_UL_ConfigDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SoundingRS_UL_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SoundingRS_UL_ConfigDedicated_Type_Sel)_tmp;
	}
	_serSysDecSoundingRS_UL_ConfigDedicated_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSRS_UL_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SRS_UL_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSoundingRS_UL_ConfigCommon_Type(_buffer, _size, _lidx, &p->Common);
	_serSysDecSoundingRS_UL_ConfigDedicated_Type(_buffer, _size, _lidx, _mem, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serSysDecSRS_UL_Config_Type_SRS_UL_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SRS_UL_Config_Type_SRS_UL_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSRS_UL_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->sr_PUCCH_ResourceIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sr_ConfigIndex, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dsr_TransMax = (SchedulingRequestConfig_setup_dsr_TransMax_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SchedulingRequestConfig_Value* p, enum SchedulingRequestConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingRequestConfig_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SchedulingRequestConfig_setup) {
		_serSysDecSchedulingRequestConfig_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SchedulingRequestConfig_Sel)_tmp;
	}
	_serSysDecSchedulingRequestConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_SchedulingRequestConfig_v1020_sr_PUCCH_ResourceIndexP1_r10_Optional(_buffer, _size, _lidx, &p->sr_PUCCH_ResourceIndexP1_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSchedulingRequestConfig_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecSchedulingRequestConfig(_buffer, _size, _lidx, &p->schedulingRequestConfig);
	_serSysDecSchedulingRequestConfig_v1020_schedulingRequestConfig_v1020_Optional(_buffer, _size, _lidx, &p->schedulingRequestConfig_v1020);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SchedulingRequestConfig_Type_Value* p, enum SchedulingRequestConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingRequestConfig_Type_R8andLater) {
		_serSysDecSchedulingRequestConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SchedulingRequestConfig_Type_Sel)_tmp;
	}
	_serSysDecSchedulingRequestConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingRequestConfig_Type_SR_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingRequestConfig_Type_SR_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSchedulingRequestConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportModeAperiodic_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->k, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value* p, enum CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_widebandCQI) {
		NTOH_8(p->widebandCQI, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI) {
		_serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_subbandCQI(_buffer, _size, _lidx, &p->subbandCQI);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cqi_PUCCH_ResourceIndex, &_buffer[*_lidx], _lidx);
	NTOH_16(p->cqi_pmi_ConfigIndex, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodic_setup_cqi_FormatIndicatorPeriodic(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic);
	_serSysDecUint16_t_CQI_ReportPeriodic_setup_ri_ConfigIndex_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex);
	NTOH_8(p->simultaneousAckNackAndCQI, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodic_Value* p, enum CQI_ReportPeriodic_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportPeriodic_setup) {
		_serSysDecCQI_ReportPeriodic_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodic_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodic_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportPeriodic(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportModeAperiodic_e_CQI_ReportConfig_cqi_ReportModeAperiodic_Optional(_buffer, _size, _lidx, &p->cqi_ReportModeAperiodic);
	NTOH_8(p->nomPDSCH_RS_EPRE_Offset, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodic_CQI_ReportConfig_cqi_ReportPeriodic_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodic);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportConfig_v920_cqi_Mask_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportConfig_v920_pmi_RI_Report_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportConfig_v920_cqi_Mask_r9_e_cqi_Mask_r9_Optional(_buffer, _size, _lidx, &p->cqi_Mask_r9);
	_serSysDecCQI_ReportConfig_v920_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r9);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportConfig(_buffer, _size, _lidx, &p->cqi_ReportConfig);
	_serSysDecCQI_ReportConfig_v920_cqi_ReportConfig_v920_Optional(_buffer, _size, _lidx, &p->cqi_ReportConfig_v920);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->trigger1_r10[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->trigger2_r10[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cqi_ReportModeAperiodic_r10 = (CQI_ReportModeAperiodic_e)_tmp;
	}
	_serSysDecCQI_ReportAperiodic_r10_setup_aperiodicCSI_Trigger_r10_aperiodicCSI_Trigger_r10_Optional(_buffer, _size, _lidx, &p->aperiodicCSI_Trigger_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportAperiodic_r10_Value* p, enum CQI_ReportAperiodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportAperiodic_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportAperiodic_r10_setup) {
		_serSysDecCQI_ReportAperiodic_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportAperiodic_r10_Sel)_tmp;
	}
	_serSysDecCQI_ReportAperiodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportAperiodic_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10_csi_ReportMode_r10_e_csi_ReportMode_r10_Optional(_buffer, _size, _lidx, &p->csi_ReportMode_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->k, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicityFactor_r10 = (CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10_periodicityFactor_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value* p, enum CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10) {
		_serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_widebandCQI_r10(_buffer, _size, _lidx, &p->widebandCQI_r10);
	}
	if (d == CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10) {
		_serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_subbandCQI_r10(_buffer, _size, _lidx, &p->subbandCQI_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cqi_pmi_ConfigIndex2_r10, &_buffer[*_lidx], _lidx);
	_serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup_ri_ConfigIndex2_r10_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex2_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value* p, enum CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup) {
		_serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cqi_PUCCH_ResourceIndex_r10, &_buffer[*_lidx], _lidx);
	_serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_cqi_PUCCH_ResourceIndexP1_r10_Optional(_buffer, _size, _lidx, &p->cqi_PUCCH_ResourceIndexP1_r10);
	NTOH_16(p->cqi_pmi_ConfigIndex, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodic_r10_setup_cqi_FormatIndicatorPeriodic_r10(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic_r10);
	_serSysDecUint16_t_CQI_ReportPeriodic_r10_setup_ri_ConfigIndex_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex);
	NTOH_8(p->simultaneousAckNackAndCQI, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodic_r10_setup_cqi_Mask_r9_e_cqi_Mask_r9_Optional(_buffer, _size, _lidx, &p->cqi_Mask_r9);
	_serSysDecCQI_ReportPeriodic_r10_setup_csi_ConfigIndex_r10_csi_ConfigIndex_r10_Optional(_buffer, _size, _lidx, &p->csi_ConfigIndex_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodic_r10_Value* p, enum CQI_ReportPeriodic_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodic_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportPeriodic_r10_setup) {
		_serSysDecCQI_ReportPeriodic_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodic_r10_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodic_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportPeriodic_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportConfig_r10_pmi_RI_Report_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMeasSubframePattern_r10(_buffer, _size, _lidx, &p->csi_MeasSubframeSet1_r10);
	_serSysDecMeasSubframePattern_r10(_buffer, _size, _lidx, &p->csi_MeasSubframeSet2_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value* p, enum CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup) {
		_serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Sel)_tmp;
	}
	_serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportAperiodic_r10_CQI_ReportConfig_r10_cqi_ReportAperiodic_r10_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodic_r10);
	NTOH_8(p->nomPDSCH_RS_EPRE_Offset, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodic_r10_CQI_ReportConfig_r10_cqi_ReportPeriodic_r10_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodic_r10);
	_serSysDecCQI_ReportConfig_r10_pmi_RI_Report_r9_e_pmi_RI_Report_r9_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r9);
	_serSysDecCQI_ReportConfig_r10_csi_SubframePatternConfig_r10_csi_SubframePatternConfig_r10_Optional(_buffer, _size, _lidx, &p->csi_SubframePatternConfig_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CQI_ReportPeriodicProcExtId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11_csi_ReportMode_r11_e_csi_ReportMode_r11_Optional(_buffer, _size, _lidx, &p->csi_ReportMode_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->k, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicityFactor_r11 = (CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11_periodicityFactor_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value* p, enum CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11) {
		_serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_widebandCQI_r11(_buffer, _size, _lidx, &p->widebandCQI_r11);
	}
	if (d == CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11) {
		_serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_subbandCQI_r11(_buffer, _size, _lidx, &p->subbandCQI_r11);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cqi_pmi_ConfigIndex2_r11, &_buffer[*_lidx], _lidx);
	_serSysDecUint16_t_CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup_ri_ConfigIndex2_r11_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex2_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value* p, enum CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup) {
		_serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Sel)_tmp;
	}
	_serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRI_ReportConfig_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRI_ReportConfig_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->cri_ConfigIndex_r13, &_buffer[*_lidx], _lidx);
	_serSysDecCRI_ConfigIndex_r13_CRI_ReportConfig_r13_setup_cri_ConfigIndex2_r13_Optional(_buffer, _size, _lidx, &p->cri_ConfigIndex2_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRI_ReportConfig_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CRI_ReportConfig_r13_Value* p, enum CRI_ReportConfig_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CRI_ReportConfig_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CRI_ReportConfig_r13_setup) {
		_serSysDecCRI_ReportConfig_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCRI_ReportConfig_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRI_ReportConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CRI_ReportConfig_r13_Sel)_tmp;
	}
	_serSysDecCRI_ReportConfig_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCRI_ReportConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExt_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportPeriodicProcExt_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->cqi_ReportPeriodicProcExtId_r11, &_buffer[*_lidx], _lidx);
	NTOH_16(p->cqi_pmi_ConfigIndex_r11, &_buffer[*_lidx], _lidx);
	_serSysDecCQI_ReportPeriodicProcExt_r11_cqi_FormatIndicatorPeriodic_r11(_buffer, _size, _lidx, &p->cqi_FormatIndicatorPeriodic_r11);
	_serSysDecUint16_t_CQI_ReportPeriodicProcExt_r11_ri_ConfigIndex_r11_Optional(_buffer, _size, _lidx, &p->ri_ConfigIndex_r11);
	_serSysDecCQI_ReportPeriodicProcExt_r11_csi_ConfigIndex_r11_csi_ConfigIndex_r11_Optional(_buffer, _size, _lidx, &p->csi_ConfigIndex_r11);
	_serSysDecCRI_ReportConfig_r13_CQI_ReportPeriodicProcExt_r11_cri_ReportConfig_r13_Optional(_buffer, _size, _lidx, &p->cri_ReportConfig_r13);
	_serSysDecCQI_ReportPeriodicProcExt_r11_periodicityFactorWB_r13_e_periodicityFactorWB_r13_Optional(_buffer, _size, _lidx, &p->periodicityFactorWB_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CQI_ReportPeriodicProcExt_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCQI_ReportPeriodicProcExt_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportPeriodic_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportPeriodic_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportPeriodic_v1130_simultaneousAckNackAndCQI_Format3_r11_e_simultaneousAckNackAndCQI_Format3_r11_Optional(_buffer, _size, _lidx, &p->simultaneousAckNackAndCQI_Format3_r11);
	_serSysDecCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(_buffer, _size, _lidx, _mem, &p->cqi_ReportPeriodicProcExtToReleaseList_r11);
	_serSysDecCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(_buffer, _size, _lidx, _mem, &p->cqi_ReportPeriodicProcExtToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_IM_ConfigId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_Config_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_IM_Config_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_IM_ConfigId_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->resourceConfig_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeConfig_r11, &_buffer[*_lidx], _lidx);
	_serSysDecBool_CSI_IM_Config_r11_interferenceMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->interferenceMeasRestriction_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_IM_Config_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCSI_IM_Config_r11(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_ProcessId_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p_C_r11, &_buffer[*_lidx], _lidx);
	NTOH_32(p->codebookSubsetRestriction_r11.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction_r11.v = serMalloc(_mem, p->codebookSubsetRestriction_r11.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction_r11.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction_r11.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportBothProc_r11_pmi_RI_Report_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBothProc_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportBothProc_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_ProcessId_r11_CQI_ReportBothProc_r11_ri_Ref_CSI_ProcessId_r11_Optional(_buffer, _size, _lidx, &p->ri_Ref_CSI_ProcessId_r11);
	_serSysDecCQI_ReportBothProc_r11_pmi_RI_Report_r11_e_pmi_RI_Report_r11_Optional(_buffer, _size, _lidx, &p->pmi_RI_Report_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportBothProc_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodicProc_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodicProc_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cqi_ReportModeAperiodic_r11 = (CQI_ReportModeAperiodic_e)_tmp;
	}
	NTOH_8(p->trigger01_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger10_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger11_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportAperiodicProc_r11(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_Process_r11_csi_IM_ConfigIdList_r12_Value* p, enum CSI_Process_r11_csi_IM_ConfigIdList_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_csi_IM_ConfigIdList_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_Process_r11_csi_IM_ConfigIdList_r12_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = serMalloc(_mem, p->setup.d * sizeof(CSI_IM_ConfigId_r12));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_Process_r11_csi_IM_ConfigIdList_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_Process_r11_csi_IM_ConfigIdList_r12_Sel)_tmp;
	}
	_serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc2_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_r12_setup) {
		_serSysDecCQI_ReportAperiodicProc_r11(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc2_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_Process_r11_cqi_ReportAperiodicProc2_r12_Sel)_tmp;
	}
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodicProc_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodicProc_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->trigger001_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger010_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger011_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger100_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger101_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger110_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->trigger111_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc_v1310_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc_v1310_setup) {
		_serSysDecCQI_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_Process_r11_cqi_ReportAperiodicProc_v1310_Sel)_tmp;
	}
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value* p, enum CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_setup) {
		_serSysDecCQI_ReportAperiodicProc_v1310(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc2_v1310* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Sel)_tmp;
	}
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->codebookSubsetRestriction1_r13.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction1_r13.v = serMalloc(_mem, p->codebookSubsetRestriction1_r13.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction1_r13.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction1_r13.v[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->codebookSubsetRestriction2_r13.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction2_r13.v = serMalloc(_mem, p->codebookSubsetRestriction2_r13.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction2_r13.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction2_r13.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->codebookSubsetRestriction3_r13.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction3_r13.v = serMalloc(_mem, p->codebookSubsetRestriction3_r13.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction3_r13.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction3_r13.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->codebookSubsetRestriction_r13.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction_r13.v = serMalloc(_mem, p->codebookSubsetRestriction_r13.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction_r13.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction_r13.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union P_C_AndCBSR_r13_cbsr_Selection_r13_Value* p, enum P_C_AndCBSR_r13_cbsr_Selection_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13) {
		_serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(_buffer, _size, _lidx, _mem, &p->nonPrecoded_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13) {
		_serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(_buffer, _size, _lidx, _mem, &p->beamformedK1a_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13) {
		_serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(_buffer, _size, _lidx, _mem, &p->beamformedKN_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r13_cbsr_Selection_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum P_C_AndCBSR_r13_cbsr_Selection_r13_Sel)_tmp;
	}
	_serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p_C_r13, &_buffer[*_lidx], _lidx);
	_serSysDecP_C_AndCBSR_r13_cbsr_Selection_r13(_buffer, _size, _lidx, _mem, &p->cbsr_Selection_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct P_C_AndCBSR_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecP_C_AndCBSR_r13(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_IM_ConfigId_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NZP_FrequencyDensity_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_ResourceConfig_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_ResourceConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->resourceConfig_r13, &_buffer[*_lidx], _lidx);
	_serSysDecNZP_TransmissionComb_r14_NZP_ResourceConfig_r13_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysDecNZP_FrequencyDensity_r14_e_NZP_ResourceConfig_r13_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->nzp_resourceConfigList_r13.d, &_buffer[*_lidx], _lidx);
	p->nzp_resourceConfigList_r13.v = serMalloc(_mem, p->nzp_resourceConfigList_r13.d * sizeof(struct NZP_ResourceConfig_r13));
	for (size_t i2 = 0; i2 < p->nzp_resourceConfigList_r13.d; i2++) {
		_serSysDecNZP_ResourceConfig_r13(_buffer, _size, _lidx, &p->nzp_resourceConfigList_r13.v[i2]);
	}
	_serSysDecCSI_RS_ConfigNZP_EMIMO_r13_setup_cdmType_r13_e_cdmType_r13_Optional(_buffer, _size, _lidx, &p->cdmType_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigNZP_EMIMO_r13_Value* p, enum CSI_RS_ConfigNZP_EMIMO_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigNZP_EMIMO_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigNZP_EMIMO_r13_setup) {
		_serSysDecCSI_RS_ConfigNZP_EMIMO_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigNZP_EMIMO_r13_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigNZP_EMIMO_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_EMIMO_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNonPrecoded_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(_buffer, _size, _lidx, _mem, &p->p_C_AndCBSRList_r13);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->codebookConfigN1_r13 = (CSI_RS_ConfigNonPrecoded_r13_codebookConfigN1_r13_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->codebookConfigN2_r13 = (CSI_RS_ConfigNonPrecoded_r13_codebookConfigN2_r13_e)_tmp;
	}
	_serSysDecCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O1_r13_e_codebookOverSamplingRateConfig_O1_r13_Optional(_buffer, _size, _lidx, &p->codebookOverSamplingRateConfig_O1_r13);
	_serSysDecCSI_RS_ConfigNonPrecoded_r13_codebookOverSamplingRateConfig_O2_r13_e_codebookOverSamplingRateConfig_O2_r13_Optional(_buffer, _size, _lidx, &p->codebookOverSamplingRateConfig_O2_r13);
	NTOH_8(p->codebookConfig_r13, &_buffer[*_lidx], _lidx);
	_serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigIdList_r13);
	_serSysDecCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZP_EMIMO_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_RS_ConfigNZPId_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_IM_ConfigId_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(P_C_AndCBSR_Pair_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2].d, &_buffer[*_lidx], _lidx);
		p->v.v[i2].v = serMalloc(_mem, p->v.v[i2].d * sizeof(struct P_C_AndCBSR_r13));
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			_serSysDecP_C_AndCBSR_r13(_buffer, _size, _lidx, _mem, &p->v.v[i2].v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct bool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(bool));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigBeamformed_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZPIdListExt_r13);
	_serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigIdList_r13);
	_serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p_C_AndCBSR_PerResourceConfigList_r13);
	_serSysDecBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(_buffer, _size, _lidx, _mem, &p->ace_For4Tx_PerResourceConfigList_r13);
	_serSysDecCSI_RS_ConfigBeamformed_r13_alternativeCodebookEnabledBeamformed_r13_e_alternativeCodebookEnabledBeamformed_r13_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledBeamformed_r13);
	_serSysDecCSI_RS_ConfigBeamformed_r13_channelMeasRestriction_r13_e_channelMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->channelMeasRestriction_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_r13_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_r13_setup_Value* p, enum CSI_RS_ConfigEMIMO_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_r13_setup_nonPrecoded_r13) {
		_serSysDecCSI_RS_ConfigNonPrecoded_r13(_buffer, _size, _lidx, _mem, &p->nonPrecoded_r13);
	}
	if (d == CSI_RS_ConfigEMIMO_r13_setup_beamformed_r13) {
		_serSysDecCSI_RS_ConfigBeamformed_r13(_buffer, _size, _lidx, _mem, &p->beamformed_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_r13_setup_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_r13_setup_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_r13_Value* p, enum CSI_RS_ConfigEMIMO_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_r13_setup) {
		_serSysDecCSI_RS_ConfigEMIMO_r13_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_r13_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_r13_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO_r13(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->nzp_resourceConfigListExt_r14.d, &_buffer[*_lidx], _lidx);
	p->nzp_resourceConfigListExt_r14.v = serMalloc(_mem, p->nzp_resourceConfigListExt_r14.d * sizeof(struct NZP_ResourceConfig_r13));
	for (size_t i2 = 0; i2 < p->nzp_resourceConfigListExt_r14.d; i2++) {
		_serSysDecNZP_ResourceConfig_r13(_buffer, _size, _lidx, &p->nzp_resourceConfigListExt_r14.v[i2]);
	}
	_serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_cdmType_v1430_e_cdmType_v1430_Optional(_buffer, _size, _lidx, &p->cdmType_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_EMIMO_v1430(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NZP_FrequencyDensity_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_NZP_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_NZP_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecNZP_TransmissionComb_r14_CSI_RS_Config_NZP_v1430_transmissionComb_r14_Optional(_buffer, _size, _lidx, &p->transmissionComb_r14);
	_serSysDecNZP_FrequencyDensity_r14_e_CSI_RS_Config_NZP_v1430_frequencyDensity_r14_Optional(_buffer, _size, _lidx, &p->frequencyDensity_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNonPrecoded_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZP_EMIMO_v1430);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->codebookConfigN1_v1430 = (CSI_RS_ConfigNonPrecoded_v1430_codebookConfigN1_v1430_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->codebookConfigN2_v1430 = (CSI_RS_ConfigNonPrecoded_v1430_codebookConfigN2_v1430_e)_tmp;
	}
	_serSysDecCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->nzp_ResourceConfigTM9_Original_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_RS_ConfigNZP_r11));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_Activation_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZP_Activation_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->csi_RS_NZP_mode_r14 = (CSI_RS_ConfigNZP_Activation_r14_csi_RS_NZP_mode_r14_e)_tmp;
	}
	NTOH_8(p->activatedResources_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_Activation_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigBeamformed_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZP_ApList_r14);
	_serSysDecCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_v1430_nzp_ResourceConfigOriginal_v1430_Optional(_buffer, _size, _lidx, &p->nzp_ResourceConfigOriginal_v1430);
	_serSysDecCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_v1430_csi_RS_NZP_Activation_r14_Optional(_buffer, _size, _lidx, &p->csi_RS_NZP_Activation_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1430_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1430_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1430_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1430_setup_nonPrecoded_v1430) {
		_serSysDecCSI_RS_ConfigNonPrecoded_v1430(_buffer, _size, _lidx, _mem, &p->nonPrecoded_v1430);
	}
	if (d == CSI_RS_ConfigEMIMO_v1430_setup_beamformed_v1430) {
		_serSysDecCSI_RS_ConfigBeamformed_v1430(_buffer, _size, _lidx, _mem, &p->beamformed_v1430);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1430_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1430_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1430_setup_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1430_setup_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1430_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1430_Value* p, enum CSI_RS_ConfigEMIMO_v1430_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1430_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1430_setup) {
		_serSysDecCSI_RS_ConfigEMIMO_v1430_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1430_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1430_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO_v1430(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_RS_ConfigNZPId_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(CSI_IM_ConfigId_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(P_C_AndCBSR_Pair_r13));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2].d, &_buffer[*_lidx], _lidx);
		p->v.v[i2].v = serMalloc(_mem, p->v.v[i2].d * sizeof(struct P_C_AndCBSR_r13));
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			_serSysDecP_C_AndCBSR_r13(_buffer, _size, _lidx, _mem, &p->v.v[i2].v[i3]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct bool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(bool));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_RS_ConfigNZP_r11));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecCSI_RS_ConfigNZP_r11(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_Activation_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigBeamformed_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigBeamformed_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZPIdListExt_r14);
	_serSysDecCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigIdList_r14);
	_serSysDecP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p_C_AndCBSR_PerResourceConfigList_r14);
	_serSysDecBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->ace_For4Tx_PerResourceConfigList_r14);
	_serSysDecCSI_RS_ConfigBeamformed_r14_alternativeCodebookEnabledBeamformed_r14_e_alternativeCodebookEnabledBeamformed_r14_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledBeamformed_r14);
	_serSysDecCSI_RS_ConfigBeamformed_r14_channelMeasRestriction_r14_e_channelMeasRestriction_r14_Optional(_buffer, _size, _lidx, &p->channelMeasRestriction_r14);
	_serSysDecCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZP_ApList_r14);
	_serSysDecCSI_RS_Config_NZP_v1430_CSI_RS_ConfigBeamformed_r14_nzp_ResourceConfigOriginal_v1430_Optional(_buffer, _size, _lidx, &p->nzp_ResourceConfigOriginal_v1430);
	_serSysDecCSI_RS_ConfigNZP_Activation_r14_CSI_RS_ConfigBeamformed_r14_csi_RS_NZP_Activation_r14_Optional(_buffer, _size, _lidx, &p->csi_RS_NZP_Activation_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO2_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO2_r14_Value* p, enum CSI_RS_ConfigEMIMO2_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO2_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO2_r14_setup) {
		_serSysDecCSI_RS_ConfigBeamformed_r14(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO2_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO2_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO2_r14_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO2_r14_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO2_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_Hybrid_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_periodicityOffsetIndex_r14_Optional(_buffer, _size, _lidx, &p->periodicityOffsetIndex_r14);
	_serSysDecCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(_buffer, _size, _lidx, _mem, &p->eMIMO_Type2_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_Hybrid_r14_Value* p, enum CSI_RS_ConfigEMIMO_Hybrid_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_Hybrid_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_Hybrid_r14_setup) {
		_serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_Hybrid_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_Hybrid_r14_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigNZP_EMIMO_v1430(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_v1480(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNonPrecoded_v1480* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(_buffer, _size, _lidx, _mem, &p->csi_RS_ConfigNZP_EMIMO_v1480);
	_serSysDecCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN1_v1480_e_codebookConfigN1_v1480_Optional(_buffer, _size, _lidx, &p->codebookConfigN1_v1480);
	_serSysDecCSI_RS_ConfigNonPrecoded_v1480_codebookConfigN2_r1480_e_codebookConfigN2_r1480_Optional(_buffer, _size, _lidx, &p->codebookConfigN2_r1480);
	_serSysDecCSI_RS_Config_NZP_v1430(_buffer, _size, _lidx, &p->nzp_ResourceConfigTM9_Original_v1480);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1480_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1480_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1480_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1480_setup_nonPrecoded_v1480) {
		_serSysDecCSI_RS_ConfigNonPrecoded_v1480(_buffer, _size, _lidx, _mem, &p->nonPrecoded_v1480);
	}
	if (d == CSI_RS_ConfigEMIMO_v1480_setup_beamformed_v1480) {
		_serSysDecCSI_RS_ConfigBeamformed_v1430(_buffer, _size, _lidx, _mem, &p->beamformed_v1480);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1480_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1480_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1480_setup_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1480_setup_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1480_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1480_Value* p, enum CSI_RS_ConfigEMIMO_v1480_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1480_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1480_setup) {
		_serSysDecCSI_RS_ConfigEMIMO_v1480_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1480(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1480* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1480_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1480_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO_v1480(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p_C_r15, &_buffer[*_lidx], _lidx);
	NTOH_32(p->codebookSubsetRestriction4_r15.d, &_buffer[*_lidx], _lidx);
	p->codebookSubsetRestriction4_r15.v = serMalloc(_mem, p->codebookSubsetRestriction4_r15.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->codebookSubsetRestriction4_r15.d; i3++) {
		NTOH_8(p->codebookSubsetRestriction4_r15.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct P_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct P_C_AndCBSR_r15));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serSysDecP_C_AndCBSR_r15(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigNonPrecoded_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigNonPrecoded_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(_buffer, _size, _lidx, _mem, &p->p_C_AndCBSRList_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1530_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1530_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1530_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1530_setup_nonPrecoded_v1530) {
		_serSysDecCSI_RS_ConfigNonPrecoded_v1530(_buffer, _size, _lidx, _mem, &p->nonPrecoded_v1530);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1530_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1530_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1530_setup_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1530_setup_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1530_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CSI_RS_ConfigEMIMO_v1530_Value* p, enum CSI_RS_ConfigEMIMO_v1530_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CSI_RS_ConfigEMIMO_v1530_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CSI_RS_ConfigEMIMO_v1530_setup) {
		_serSysDecCSI_RS_ConfigEMIMO_v1530_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1530(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1530* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CSI_RS_ConfigEMIMO_v1530_Sel)_tmp;
	}
	_serSysDecCSI_RS_ConfigEMIMO_v1530_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_RS_ConfigEMIMO_v1530(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_Process_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_Process_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_ProcessId_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->csi_RS_ConfigNZPId_r11, &_buffer[*_lidx], _lidx);
	NTOH_8(p->csi_IM_ConfigId_r11, &_buffer[*_lidx], _lidx);
	NTOH_32(p->p_C_AndCBSRList_r11.d, &_buffer[*_lidx], _lidx);
	p->p_C_AndCBSRList_r11.v = serMalloc(_mem, p->p_C_AndCBSRList_r11.d * sizeof(struct P_C_AndCBSR_r11));
	for (size_t i2 = 0; i2 < p->p_C_AndCBSRList_r11.d; i2++) {
		_serSysDecP_C_AndCBSR_r11(_buffer, _size, _lidx, _mem, &p->p_C_AndCBSRList_r11.v[i2]);
	}
	_serSysDecCQI_ReportBothProc_r11_CSI_Process_r11_cqi_ReportBothProc_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportBothProc_r11);
	_serSysDecUint8_t_CSI_Process_r11_cqi_ReportPeriodicProcId_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportPeriodicProcId_r11);
	_serSysDecCQI_ReportAperiodicProc_r11_CSI_Process_r11_cqi_ReportAperiodicProc_r11_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc_r11);
	_serSysDecCSI_Process_r11_alternativeCodebookEnabledFor4TXProc_r12_e_alternativeCodebookEnabledFor4TXProc_r12_Optional(_buffer, _size, _lidx, &p->alternativeCodebookEnabledFor4TXProc_r12);
	_serSysDecCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigIdList_r12);
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_r12_cqi_ReportAperiodicProc2_r12_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc2_r12);
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc_v1310_cqi_ReportAperiodicProc_v1310_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc_v1310);
	_serSysDecCSI_Process_r11_cqi_ReportAperiodicProc2_v1310_cqi_ReportAperiodicProc2_v1310_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodicProc2_v1310);
	_serSysDecCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(_buffer, _size, _lidx, _mem, &p->eMIMO_Type_r13);
	_serSysDecCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(_buffer, _size, _lidx, _mem, &p->dummy);
	_serSysDecCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(_buffer, _size, _lidx, _mem, &p->eMIMO_Hybrid_r14);
	_serSysDecBool_CSI_Process_r11_advancedCodebookEnabled_r14_Optional(_buffer, _size, _lidx, &p->advancedCodebookEnabled_r14);
	_serSysDecCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(_buffer, _size, _lidx, _mem, &p->eMIMO_Type_v1480);
	_serSysDecBool_CSI_Process_r11_feCOMP_CSI_Enabled_v1530_Optional(_buffer, _size, _lidx, &p->feCOMP_CSI_Enabled_v1530);
	_serSysDecCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(_buffer, _size, _lidx, _mem, &p->eMIMO_Type_v1530);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct CSI_Process_r11));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecCSI_Process_r11(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBoth_r11(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportBoth_r11* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigToReleaseList_r11);
	_serSysDecCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(_buffer, _size, _lidx, _mem, &p->csi_IM_ConfigToAddModList_r11);
	_serSysDecCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(_buffer, _size, _lidx, _mem, &p->csi_ProcessToReleaseList_r11);
	_serSysDecCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(_buffer, _size, _lidx, _mem, &p->csi_ProcessToAddModList_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportConfig_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportPeriodic_v1130(_buffer, _size, _lidx, _mem, &p->cqi_ReportPeriodic_v1130);
	_serSysDecCQI_ReportBoth_r11(_buffer, _size, _lidx, _mem, &p->cqi_ReportBoth_r11);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_v1130(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 10; i1++) {
		NTOH_8(p->csi_MeasSubframeSets_r12[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value* p, enum CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup) {
		_serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Sel)_tmp;
	}
	_serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigExt_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_IM_ConfigExt_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_IM_ConfigId_v1250, &_buffer[*_lidx], _lidx);
	NTOH_8(p->resourceConfig_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->subframeConfig_r12, &_buffer[*_lidx], _lidx);
	_serSysDecBool_CSI_IM_ConfigExt_r12_interferenceMeasRestriction_r13_Optional(_buffer, _size, _lidx, &p->interferenceMeasRestriction_r13);
	_serSysDecCSI_IM_ConfigId_v1310_CSI_IM_ConfigExt_r12_csi_IM_ConfigId_v1310_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigId_v1310);

	return SIDL_STATUS_OK;
}

static int _serSysDecCSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCSI_IM_ConfigExt_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBoth_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportBoth_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCSI_IM_ConfigId_v1250_CQI_ReportBoth_v1250_csi_IM_ConfigToReleaseListExt_r12_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToReleaseListExt_r12);
	_serSysDecCSI_IM_ConfigExt_r12_CQI_ReportBoth_v1250_csi_IM_ConfigToAddModListExt_r12_Optional(_buffer, _size, _lidx, &p->csi_IM_ConfigToAddModListExt_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportBoth_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->trigger_SubframeSetIndicator_r12 = (CQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250_trigger_SubframeSetIndicator_r12_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->trigger1_SubframeSetIndicator_r12[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->trigger2_SubframeSetIndicator_r12[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_v1250_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_v1250_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportAperiodic_v1250_setup_aperiodicCSI_Trigger_v1250(_buffer, _size, _lidx, &p->aperiodicCSI_Trigger_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_v1250_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CQI_ReportAperiodic_v1250_Value* p, enum CQI_ReportAperiodic_v1250_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportAperiodic_v1250_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == CQI_ReportAperiodic_v1250_setup) {
		_serSysDecCQI_ReportAperiodic_v1250_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportAperiodic_v1250_Sel)_tmp;
	}
	_serSysDecCQI_ReportAperiodic_v1250_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportAperiodic_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (CQI_ReportConfig_v1250_altCQI_Table_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportConfig_v1250_csi_SubframePatternConfig_r12_csi_SubframePatternConfig_r12_Optional(_buffer, _size, _lidx, &p->csi_SubframePatternConfig_r12);
	_serSysDecCQI_ReportBoth_v1250_CQI_ReportConfig_v1250_cqi_ReportBoth_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportBoth_v1250);
	_serSysDecCQI_ReportAperiodic_v1250_CQI_ReportConfig_v1250_cqi_ReportAperiodic_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportAperiodic_v1250);
	_serSysDecCQI_ReportConfig_v1250_altCQI_Table_r12_e_altCQI_Table_r12_Optional(_buffer, _size, _lidx, &p->altCQI_Table_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_R10andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportConfig_R10andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCQI_ReportConfig_r10(_buffer, _size, _lidx, &p->cqi_ReportConfig_r10);
	_serSysDecCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(_buffer, _size, _lidx, _mem, &p->cqi_ReportConfig_v1130);
	_serSysDecCQI_ReportConfig_v1250_cqi_ReportConfig_v1250_Optional(_buffer, _size, _lidx, &p->cqi_ReportConfig_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CQI_ReportConfig_Type_Value* p, enum CQI_ReportConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CQI_ReportConfig_Type_R8andLater) {
		_serSysDecCQI_ReportConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == CQI_ReportConfig_Type_R10andLater) {
		_serSysDecCQI_ReportConfig_R10andLater_Type(_buffer, _size, _lidx, _mem, &p->R10andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CQI_ReportConfig_Type_Sel)_tmp;
	}
	_serSysDecCQI_ReportConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCQI_ReportConfig_Type_CQI_ReportConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CQI_ReportConfig_Type_CQI_ReportConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCQI_ReportConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommon_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommonSCell_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommonSCell_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->deltaPreambleMsg3_r11, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommonSCell_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommonPSCell_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommonPSCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format3_r12 = (UplinkPowerControlCommonPSCell_r12_deltaF_PUCCH_Format3_r12_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaF_PUCCH_Format1bCS_r12 = (UplinkPowerControlCommonPSCell_r12_deltaF_PUCCH_Format1bCS_r12_e)_tmp;
	}
	NTOH_8(p->p0_NominalPUCCH_r12, &_buffer[*_lidx], _lidx);
	_serSysDecDeltaFList_PUCCH(_buffer, _size, _lidx, &p->deltaFList_PUCCH_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommonPSCell_r12(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUplinkPowerControlCommon(_buffer, _size, _lidx, &p->uplinkPowerControlCommon);
	_serSysDecUplinkPowerControlCommon_v1020_uplinkPowerControlCommon_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommon_v1020);
	_serSysDecUplinkPowerControlCommonSCell_v1130_uplinkPowerControlCommonSCell_v1130_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommonSCell_v1130);
	_serSysDecUplinkPowerControlCommonPSCell_r12_uplinkPowerControlCommonPSCell_r12_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlCommonPSCell_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UplinkPowerControlCommon_Type_Value* p, enum UplinkPowerControlCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlCommon_Type_R8andLater) {
		_serSysDecUplinkPowerControlCommon_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UplinkPowerControlCommon_Type_Sel)_tmp;
	}
	_serSysDecUplinkPowerControlCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecFilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (FilterCoefficient_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p0_UE_PUSCH, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaMCS_Enabled = (UplinkPowerControlDedicated_deltaMCS_Enabled_e)_tmp;
	}
	NTOH_8(p->accumulationEnabled, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p0_UE_PUCCH, &_buffer[*_lidx], _lidx);
	NTOH_8(p->pSRS_Offset, &_buffer[*_lidx], _lidx);
	_serSysDecFilterCoefficient_e_UplinkPowerControlDedicated_filterCoefficient_Optional(_buffer, _size, _lidx, &p->filterCoefficient);

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaTxD_OffsetListPUCCH_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaTxD_OffsetListPUCCH_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaTxD_OffsetPUCCH_Format1_r10 = (DeltaTxD_OffsetListPUCCH_r10_deltaTxD_OffsetPUCCH_Format1_r10_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaTxD_OffsetPUCCH_Format1a1b_r10 = (DeltaTxD_OffsetListPUCCH_r10_deltaTxD_OffsetPUCCH_Format1a1b_r10_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaTxD_OffsetPUCCH_Format22a2b_r10 = (DeltaTxD_OffsetListPUCCH_r10_deltaTxD_OffsetPUCCH_Format22a2b_r10_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaTxD_OffsetPUCCH_Format3_r10 = (DeltaTxD_OffsetListPUCCH_r10_deltaTxD_OffsetPUCCH_Format3_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDeltaTxD_OffsetListPUCCH_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1020(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1020* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDeltaTxD_OffsetListPUCCH_r10_UplinkPowerControlDedicated_v1020_deltaTxD_OffsetListPUCCH_r10_Optional(_buffer, _size, _lidx, &p->deltaTxD_OffsetListPUCCH_r10);
	_serSysDecUint8_t_UplinkPowerControlDedicated_v1020_pSRS_OffsetAp_r10_Optional(_buffer, _size, _lidx, &p->pSRS_OffsetAp_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlDedicated_v1020(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SCellPathlossReferenceLinking_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaTxD_OffsetListPUCCH_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaTxD_OffsetListPUCCH_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->deltaTxD_OffsetPUCCH_Format1bCS_r11 = (DeltaTxD_OffsetListPUCCH_v1130_deltaTxD_OffsetPUCCH_Format1bCS_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDeltaTxD_OffsetListPUCCH_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1130(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1130* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint8_t_UplinkPowerControlDedicated_v1130_pSRS_Offset_v1130_Optional(_buffer, _size, _lidx, &p->pSRS_Offset_v1130);
	_serSysDecUint8_t_UplinkPowerControlDedicated_v1130_pSRS_OffsetAp_v1130_Optional(_buffer, _size, _lidx, &p->pSRS_OffsetAp_v1130);
	_serSysDecDeltaTxD_OffsetListPUCCH_v1130_UplinkPowerControlDedicated_v1130_deltaTxD_OffsetListPUCCH_v1130_Optional(_buffer, _size, _lidx, &p->deltaTxD_OffsetListPUCCH_v1130);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlDedicated_v1130(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 10; i1++) {
		NTOH_8(p->tpc_SubframeSet_r12[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->p0_NominalPUSCH_SubframeSet2_r12, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->alpha_SubframeSet2_r12 = (Alpha_r12_e)_tmp;
	}
	NTOH_8(p->p0_UE_PUSCH_SubframeSet2_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value* p, enum UplinkPowerControlDedicated_v1250_set2PowerControlParameter_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlDedicated_v1250_set2PowerControlParameter_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == UplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup) {
		_serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1250_set2PowerControlParameter* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UplinkPowerControlDedicated_v1250_set2PowerControlParameter_Sel)_tmp;
	}
	_serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUplinkPowerControlDedicated_v1250_set2PowerControlParameter(_buffer, _size, _lidx, &p->set2PowerControlParameter);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUplinkPowerControlDedicated(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated);
	_serSysDecUplinkPowerControlDedicated_v1020_uplinkPowerControlDedicated_v1020_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1020);
	_serSysDecSCellPathlossReferenceLinking_Type_pathlossReferenceLinking_Optional(_buffer, _size, _lidx, &p->pathlossReferenceLinking);
	_serSysDecUplinkPowerControlDedicated_v1130_uplinkPowerControlDedicated_v1130_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1130);
	_serSysDecUplinkPowerControlDedicated_v1250_uplinkPowerControlDedicated_v1250_Optional(_buffer, _size, _lidx, &p->uplinkPowerControlDedicated_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UplinkPowerControlDedicated_Type_Value* p, enum UplinkPowerControlDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkPowerControlDedicated_Type_R8andLater) {
		_serSysDecUplinkPowerControlDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UplinkPowerControlDedicated_Type_Sel)_tmp;
	}
	_serSysDecUplinkPowerControlDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkPowerControlDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysicalLayerConfigUL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysicalLayerConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPRACH_Config_Type_Prach_Optional(_buffer, _size, _lidx, _mem, &p->Prach);
	_serSysDecPUCCH_Configuration_Type_Pucch_Optional(_buffer, _size, _lidx, _mem, &p->Pucch);
	_serSysDecPUSCH_Configuration_Type_Pusch_Optional(_buffer, _size, _lidx, &p->Pusch);
	_serSysDecSS_TimingAdvanceConfig_Type_TimingAdvance_Optional(_buffer, _size, _lidx, &p->TimingAdvance);
	_serSysDecSRS_UL_Config_Type_SRS_UL_Config_Optional(_buffer, _size, _lidx, _mem, &p->SRS_UL_Config);
	_serSysDecSchedulingRequestConfig_Type_SR_Config_Optional(_buffer, _size, _lidx, &p->SR_Config);
	_serSysDecCQI_ReportConfig_Type_CQI_ReportConfig_Optional(_buffer, _size, _lidx, _mem, &p->CQI_ReportConfig);
	_serSysDecUplinkPowerControlCommon_Type_UplinkPowerControlCommon_Optional(_buffer, _size, _lidx, &p->UplinkPowerControlCommon);
	_serSysDecUplinkPowerControlDedicated_Type_UplinkPowerControlDedicated_Optional(_buffer, _size, _lidx, &p->UplinkPowerControlDedicated);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPhysicalLayerConfigUL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_ConfigCommon_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RACH_ConfigCommon_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->rach_ConfigCommon);
	_serSysDecRACH_ConfigCommon_v1250_rach_ConfigCommon_v1250_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union RACH_ConfigCommon_Type_Value* p, enum RACH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RACH_ConfigCommon_Type_R8andLater) {
		_serSysDecRACH_ConfigCommon_R8andLater_Type(_buffer, _size, _lidx, _mem, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RACH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RACH_ConfigCommon_Type_Sel)_tmp;
	}
	_serSysDecRACH_ConfigCommon_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RACH_ConfigCommon_Type_RACH_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_ConfigCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ra_PreambleIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ra_PRACH_MaskIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RACH_ConfigDedicated_Type_Value* p, enum RACH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RACH_ConfigDedicated_Type_R8) {
		_serSysDecRACH_ConfigDedicated(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RACH_ConfigDedicated_Type_Sel)_tmp;
	}
	_serSysDecRACH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRACH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRAR_RapIdCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RAR_RapIdCtrl_Type_Value* p, enum RAR_RapIdCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RAR_RapIdCtrl_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
	}
	if (d == RAR_RapIdCtrl_Type_Unmatched) {
		NTOH_8(p->Unmatched, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRAR_RapIdCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RAR_RapIdCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RAR_RapIdCtrl_Type_Sel)_tmp;
	}
	_serSysDecRAR_RapIdCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkGrant_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->HoppingFlag[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 10; i3++) {
		NTOH_8(p->RB_Allocation[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		NTOH_8(p->ModAndCodScheme[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->TPC_Command[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->UL_Delay[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->CQI_Req[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTempC_RNTI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TempC_RNTI_Type_Value* p, enum TempC_RNTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TempC_RNTI_Type_SameAsC_RNTI) {
		NTOH_8(p->SameAsC_RNTI, &_buffer[*_lidx], _lidx);
	}
	if (d == TempC_RNTI_Type_Explicit) {
		for (size_t i3 = 0; i3 < 16; i3++) {
			NTOH_8(p->Explicit[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTempC_RNTI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TempC_RNTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TempC_RNTI_Type_Sel)_tmp;
	}
	_serSysDecTempC_RNTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkGrantCE_ModeA_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkGrantCE_ModeA_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 4; i3++) {
		NTOH_8(p->Msg3_PUSCH_NB_Index[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		NTOH_8(p->Msg3_PUSCH_ResAllocation[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->Msg3_PUSCH_Repetitions[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->MCS[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->TPC_Command[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->CSI_Req[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->UL_Delay[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->Msg3_4_MPDCCH_NB_Index[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkGrantCE_ModeB_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkGrantCE_ModeB_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->Msg3_PUSCH_NB_Index[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->Msg3_PUSCH_ResAllocation[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->Msg3_PUSCH_Repetitions[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->TBS[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 2; i3++) {
		NTOH_8(p->Msg3_4_MPDCCH_NB_Index[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkGrantCE_Mode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkGrantCE_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUplinkGrantCE_ModeA_Type(_buffer, _size, _lidx, &p->CE_ModeA);
	_serSysDecUplinkGrantCE_ModeB_Type(_buffer, _size, _lidx, &p->CE_ModeB);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkGrantCE_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponseParameters_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RandomAccessResponseParameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);
	_serSysDecUplinkGrant_Type(_buffer, _size, _lidx, &p->InitialGrant);
	NTOH_16(p->TimingAdvance, &_buffer[*_lidx], _lidx);
	_serSysDecTempC_RNTI_Type(_buffer, _size, _lidx, &p->TempC_RNTI);
	_serSysDecUplinkGrantCE_Mode_Type_InitialGrantCE_Mode_Optional(_buffer, _size, _lidx, &p->InitialGrantCE_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponse_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union RandomAccessResponse_Type_Value* p, enum RandomAccessResponse_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessResponse_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == RandomAccessResponse_Type_List) {
		NTOH_32(p->List.d, &_buffer[*_lidx], _lidx);
		p->List.v = serMalloc(_mem, p->List.d * sizeof(struct RandomAccessResponseParameters_Type));
		for (size_t i2 = 0; i2 < p->List.d; i2++) {
			_serSysDecRandomAccessResponseParameters_Type(_buffer, _size, _lidx, &p->List.v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponse_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RandomAccessResponse_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RandomAccessResponse_Type_Sel)_tmp;
	}
	_serSysDecRandomAccessResponse_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessBackoffIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RandomAccessBackoffIndicator_Type_Value* p, enum RandomAccessBackoffIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessBackoffIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == RandomAccessBackoffIndicator_Type_Index) {
		NTOH_8(p->Index, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessBackoffIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RandomAccessBackoffIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RandomAccessBackoffIndicator_Type_Sel)_tmp;
	}
	_serSysDecRandomAccessBackoffIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponseCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RandomAccessResponseCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciDlInfoCommon_Type(_buffer, _size, _lidx, _mem, &p->DciInfo);
	_serSysDecRandomAccessResponse_Type(_buffer, _size, _lidx, _mem, &p->Rar);
	_serSysDecRandomAccessBackoffIndicator_Type(_buffer, _size, _lidx, &p->BackoffInd);

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponseConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union RandomAccessResponseConfig_Type_Value* p, enum RandomAccessResponseConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RandomAccessResponseConfig_Type_Ctrl) {
		_serSysDecRandomAccessResponseCtrl_Type(_buffer, _size, _lidx, _mem, &p->Ctrl);
	}
	if (d == RandomAccessResponseConfig_Type_Ctrl_CRC_Error) {
		_serSysDecRandomAccessResponseCtrl_Type(_buffer, _size, _lidx, _mem, &p->Ctrl_CRC_Error);
	}
	if (d == RandomAccessResponseConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRandomAccessResponseConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RandomAccessResponseConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RandomAccessResponseConfig_Type_Sel)_tmp;
	}
	_serSysDecRandomAccessResponseConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolution_ContainedId_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union ContentionResolution_ContainedId_Type_Value* p, enum ContentionResolution_ContainedId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolution_ContainedId_Type_XorMask) {
		NTOH_32(p->XorMask.d, &_buffer[*_lidx], _lidx);
		p->XorMask.v = serMalloc(_mem, p->XorMask.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->XorMask.d; i2++) {
			NTOH_8(p->XorMask.v[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedId_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolution_ContainedId_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ContentionResolution_ContainedId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ContentionResolution_ContainedId_Type_Sel)_tmp;
	}
	_serSysDecContentionResolution_ContainedId_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolution_ContainedDlschSdu_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union ContentionResolution_ContainedDlschSdu_Type_Value* p, enum ContentionResolution_ContainedDlschSdu_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolution_ContainedDlschSdu_Type_RlcPduCCCH) {
		NTOH_32(p->RlcPduCCCH.d, &_buffer[*_lidx], _lidx);
		p->RlcPduCCCH.v = serMalloc(_mem, p->RlcPduCCCH.d * sizeof(OCTET_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->RlcPduCCCH.d; i2++) {
			NTOH_8(p->RlcPduCCCH.v[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedDlschSdu_Type_PdcpSduDCCH) {
		NTOH_32(p->PdcpSduDCCH.d, &_buffer[*_lidx], _lidx);
		p->PdcpSduDCCH.v = serMalloc(_mem, p->PdcpSduDCCH.d * sizeof(OCTET_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->PdcpSduDCCH.d; i2++) {
			NTOH_8(p->PdcpSduDCCH.v[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == ContentionResolution_ContainedDlschSdu_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolution_ContainedDlschSdu_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ContentionResolution_ContainedDlschSdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ContentionResolution_ContainedDlschSdu_Type_Sel)_tmp;
	}
	_serSysDecContentionResolution_ContainedDlschSdu_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecTCRNTI_ContentionResolutionMacPdu_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct TCRNTI_ContentionResolutionMacPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecContentionResolution_ContainedId_Type(_buffer, _size, _lidx, _mem, &p->ContainedId);
	_serSysDecContentionResolution_ContainedDlschSdu_Type(_buffer, _size, _lidx, _mem, &p->ContainedRlcPdu);

	return SIDL_STATUS_OK;
}

static int _serSysDecTCRNTI_ContentionResolutionCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union TCRNTI_ContentionResolutionCtrl_Type_Value* p, enum TCRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu) {
		_serSysDecTCRNTI_ContentionResolutionMacPdu_Type(_buffer, _size, _lidx, _mem, &p->MacPdu);
	}
	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu_CRC_Error) {
		_serSysDecTCRNTI_ContentionResolutionMacPdu_Type(_buffer, _size, _lidx, _mem, &p->MacPdu_CRC_Error);
	}
	if (d == TCRNTI_ContentionResolutionCtrl_Type_NoContResolID) {
		NTOH_8(p->NoContResolID, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTCRNTI_ContentionResolutionCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct TCRNTI_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TCRNTI_ContentionResolutionCtrl_Type_Sel)_tmp;
	}
	_serSysDecTCRNTI_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecImcs_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union Imcs_Type_Value* p, enum Imcs_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Imcs_Type_Value) {
		NTOH_8(p->Value, &_buffer[*_lidx], _lidx);
	}
	if (d == Imcs_Type_NotUsed) {
		NTOH_8(p->NotUsed, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecImcs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Imcs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Imcs_Type_Sel)_tmp;
	}
	_serSysDecImcs_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRetransmissionAsynchronous_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RetransmissionAsynchronous_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->RedundencyVer, &_buffer[*_lidx], _lidx);
	NTOH_32(p->SubframeOffset, &_buffer[*_lidx], _lidx);
	NTOH_8(p->RepetitionNumber, &_buffer[*_lidx], _lidx);
	NTOH_8(p->DCISubframeRepetitionNumber, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_TransRetransmission_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UL_TransRetransmission_Type_Value* p, enum UL_TransRetransmission_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_TransRetransmission_Type_NewTransmission) {
		NTOH_8(p->NewTransmission, &_buffer[*_lidx], _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionAdaptive) {
		NTOH_8(p->ReTransmissionAdaptive, &_buffer[*_lidx], _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionNonAdaptive) {
		NTOH_8(p->ReTransmissionNonAdaptive, &_buffer[*_lidx], _lidx);
	}
	if (d == UL_TransRetransmission_Type_ReTransmissionNonAdaptiveFixedRV) {
		NTOH_8(p->ReTransmissionNonAdaptiveFixedRV, &_buffer[*_lidx], _lidx);
	}
	if (d == UL_TransRetransmission_Type_RetransmissionAsynchronous) {
		_serSysDecRetransmissionAsynchronous_Type(_buffer, _size, _lidx, &p->RetransmissionAsynchronous);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_TransRetransmission_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_TransRetransmission_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UL_TransRetransmission_Type_Sel)_tmp;
	}
	_serSysDecUL_TransRetransmission_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecFreqDomainSchedulExplicit_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct FreqDomainSchedulExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->FirstRbIndex, &_buffer[*_lidx], _lidx);
	NTOH_32(p->Nprb, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcchDciFormat_Type_Format_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdcchDciFormat_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PdcchDciFormat_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecInt32_t_HarqProcessId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_HarqProcessId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecB1_Type_PUSCH_TriggerA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B1_Type_PUSCH_TriggerA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB4_Type_TimingOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B4_Type_TimingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 4; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNumSchedSubframes_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NumSchedSubframes_Type_Value* p, enum NumSchedSubframes_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NumSchedSubframes_Type_MaxTwoSubframes) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->MaxTwoSubframes[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == NumSchedSubframes_Type_MaxFourSubframes) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			NTOH_8(p->MaxFourSubframes[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecNumSchedSubframes_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NumSchedSubframes_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NumSchedSubframes_Type_Sel)_tmp;
	}
	_serSysDecNumSchedSubframes_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecNumSchedSubframes_Type_NumberOfScheduledSubframes_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NumSchedSubframes_Type_NumberOfScheduledSubframes_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecNumSchedSubframes_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciUlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciUlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecImcs_Type(_buffer, _size, _lidx, &p->Imcs);
	NTOH_32(p->TransRetransmissionList.d, &_buffer[*_lidx], _lidx);
	p->TransRetransmissionList.v = serMalloc(_mem, p->TransRetransmissionList.d * sizeof(struct UL_TransRetransmission_Type));
	for (size_t i2 = 0; i2 < p->TransRetransmissionList.d; i2++) {
		_serSysDecUL_TransRetransmission_Type(_buffer, _size, _lidx, &p->TransRetransmissionList.v[i2]);
	}
	_serSysDecFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	_serSysDecPdcchDciFormat_Type_Format_Optional(_buffer, _size, _lidx, &p->Format);
	_serSysDecInt32_t_HarqProcessId_Optional(_buffer, _size, _lidx, &p->HarqProcessId);
	_serSysDecRepetitionNumber_Type_DciUlInfo_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysDecDCISubframeRepetitionNumber_Type_DciUlInfo_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);
	_serSysDecB1_Type_PUSCH_TriggerA_Optional(_buffer, _size, _lidx, &p->PUSCH_TriggerA);
	_serSysDecB4_Type_TimingOffset_Optional(_buffer, _size, _lidx, &p->TimingOffset);
	_serSysDecNumSchedSubframes_Type_NumberOfScheduledSubframes_Optional(_buffer, _size, _lidx, &p->NumberOfScheduledSubframes);

	return SIDL_STATUS_OK;
}

static int _serSysDecCRNTI_ContentionResolutionCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CRNTI_ContentionResolutionCtrl_Type_Value* p, enum CRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CRNTI_ContentionResolutionCtrl_Type_AutomaticGrant) {
		_serSysDecDciUlInfo_Type(_buffer, _size, _lidx, _mem, &p->AutomaticGrant);
	}
	if (d == CRNTI_ContentionResolutionCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCRNTI_ContentionResolutionCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CRNTI_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CRNTI_ContentionResolutionCtrl_Type_Sel)_tmp;
	}
	_serSysDecCRNTI_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolutionCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union ContentionResolutionCtrl_Type_Value* p, enum ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ContentionResolutionCtrl_Type_TCRNTI_Based) {
		_serSysDecTCRNTI_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, _mem, &p->TCRNTI_Based);
	}
	if (d == ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serSysDecCRNTI_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, _mem, &p->CRNTI_Based);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecContentionResolutionCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ContentionResolutionCtrl_Type_Sel)_tmp;
	}
	_serSysDecContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRachProcedure_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RachProcedure_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRandomAccessResponseConfig_Type(_buffer, _size, _lidx, _mem, &p->RAResponse);
	_serSysDecContentionResolutionCtrl_Type(_buffer, _size, _lidx, _mem, &p->ContentionResolutionCtrl);

	return SIDL_STATUS_OK;
}

static int _serSysDecRachProcedureList_Type_RachProcedureList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RachProcedureList_Type_RachProcedureList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct RachProcedure_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecRachProcedure_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRachProcedureConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RachProcedureConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->RACH_ConfigCommon);
	_serSysDecRACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->RACH_ConfigDedicated);
	_serSysDecRachProcedureList_Type_RachProcedureList_Optional(_buffer, _size, _lidx, _mem, &p->RachProcedureList);

	return SIDL_STATUS_OK;
}

static int _serSysDecRachProcedureConfig_Type_RachProcedureConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRachProcedureConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_setup_gapOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasGapConfig_setup_gapOffset_Value* p, enum MeasGapConfig_setup_gapOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_setup_gapOffset_gp0) {
		NTOH_8(p->gp0, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp1) {
		NTOH_8(p->gp1, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp2_r14) {
		NTOH_8(p->gp2_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp3_r14) {
		NTOH_8(p->gp3_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg0_r14) {
		NTOH_8(p->gp_ncsg0_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg1_r14) {
		NTOH_8(p->gp_ncsg1_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg2_r14) {
		NTOH_8(p->gp_ncsg2_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_ncsg3_r14) {
		NTOH_8(p->gp_ncsg3_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform1_r14) {
		NTOH_16(p->gp_nonUniform1_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform2_r14) {
		NTOH_16(p->gp_nonUniform2_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform3_r14) {
		NTOH_16(p->gp_nonUniform3_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp_nonUniform4_r14) {
		NTOH_16(p->gp_nonUniform4_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp4_r15) {
		NTOH_8(p->gp4_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp5_r15) {
		NTOH_8(p->gp5_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp6_r15) {
		NTOH_8(p->gp6_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp7_r15) {
		NTOH_8(p->gp7_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp8_r15) {
		NTOH_8(p->gp8_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp9_r15) {
		NTOH_8(p->gp9_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp10_r15) {
		NTOH_8(p->gp10_r15, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup_gapOffset_gp11_r15) {
		NTOH_8(p->gp11_r15, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_setup_gapOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapConfig_setup_gapOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasGapConfig_setup_gapOffset_Sel)_tmp;
	}
	_serSysDecMeasGapConfig_setup_gapOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapConfig_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMeasGapConfig_setup_gapOffset(_buffer, _size, _lidx, &p->gapOffset);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasGapConfig_Value* p, enum MeasGapConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapConfig_setup) {
		_serSysDecMeasGapConfig_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasGapConfig_Sel)_tmp;
	}
	_serSysDecMeasGapConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_mgta_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_mgta_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMeasGapConfig(_buffer, _size, _lidx, &p->measGapConfig);
	_serSysDecBool_mgta_Optional(_buffer, _size, _lidx, &p->mgta);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasGapConfig_Type_Value* p, enum MeasGapConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapConfig_Type_R8andLater) {
		_serSysDecMeasGapConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasGapConfig_Type_Sel)_tmp;
	}
	_serSysDecMeasGapConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasGapCtrl_Type_Value* p, enum MeasGapCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasGapCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasGapCtrl_Type_Config) {
		_serSysDecMeasGapConfig_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasGapCtrl_Type_Sel)_tmp;
	}
	_serSysDecMeasGapCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasGapCtrl_Type_MeasGapCtrl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasGapCtrl_Type_MeasGapCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasGapCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(RedundancyVersion_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMIMO_PrecodingBits_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MIMO_PrecodingBits_Type_Value* p, enum MIMO_PrecodingBits_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MIMO_PrecodingBits_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == MIMO_PrecodingBits_Type_Bit2) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->Bit2[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MIMO_PrecodingBits_Type_Bit3) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			NTOH_8(p->Bit3[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == MIMO_PrecodingBits_Type_Bit6) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			NTOH_8(p->Bit6[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMIMO_PrecodingBits_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MIMO_PrecodingBits_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MIMO_PrecodingBits_Type_Sel)_tmp;
	}
	_serSysDecMIMO_PrecodingBits_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMIMO_DciDlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MIMO_DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(_buffer, _size, _lidx, _mem, &p->RedundancyVersionList_2ndCW);
	for (size_t i1 = 0; i1 < 1; i1++) {
		NTOH_8(p->CodeWordSwapFlag[i1], &_buffer[*_lidx], _lidx);
	}
	_serSysDecMIMO_PrecodingBits_Type(_buffer, _size, _lidx, &p->PrecodingBits);

	return SIDL_STATUS_OK;
}

static int _serSysDecMIMO_DciDlInfo_Type_MimoInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct MIMO_DciDlInfo_Type_MimoInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMIMO_DciDlInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRepetitionNumber_Type_RepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RepetitionNumber_Type_RepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfoExplicit_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfoExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecImcs_Type(_buffer, _size, _lidx, &p->Imcs_1stCW);
	_serSysDecImcs_Type(_buffer, _size, _lidx, &p->Imcs_2ndCW);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (PdcchDciFormat_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ResourceAllocType = (PdcchResourceAllocation_Type)_tmp;
	}
	_serSysDecFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	NTOH_32(p->RedundancyVersionList.d, &_buffer[*_lidx], _lidx);
	p->RedundancyVersionList.v = serMalloc(_mem, p->RedundancyVersionList.d * sizeof(RedundancyVersion_Type));
	for (size_t i1 = 0; i1 < p->RedundancyVersionList.d; i1++) {
		NTOH_8(p->RedundancyVersionList.v[i1], &_buffer[*_lidx], _lidx);
	}
	_serSysDecMIMO_DciDlInfo_Type_MimoInfo_Optional(_buffer, _size, _lidx, _mem, &p->MimoInfo);
	_serSysDecRepetitionNumber_Type_RepetitionNumber_Optional(_buffer, _size, _lidx, &p->RepetitionNumber);
	_serSysDecDCISubframeRepetitionNumber_Type_DCISubframeRepetitionNumber_Optional(_buffer, _size, _lidx, &p->DCISubframeRepetitionNumber);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union DciDlInfo_Type_Value* p, enum DciDlInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DciDlInfo_Type_Auto) {
		_serSysDecDciDlInfoCommon_Type(_buffer, _size, _lidx, _mem, &p->Auto);
	}
	if (d == DciDlInfo_Type_Explicit) {
		_serSysDecDciDlInfoExplicit_Type(_buffer, _size, _lidx, _mem, &p->Explicit);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DciDlInfo_Type_Sel)_tmp;
	}
	_serSysDecDciDlInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciDlInfo_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciDlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDciDlInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_codebookSubsetRestriction_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaInfoDedicated_codebookSubsetRestriction_Value* p, enum AntennaInfoDedicated_codebookSubsetRestriction_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm3) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->n2TxAntenna_tm3[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm3) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			NTOH_8(p->n4TxAntenna_tm3[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm4) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			NTOH_8(p->n2TxAntenna_tm4[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm4) {
		for (size_t i1 = 0; i1 < 64; i1++) {
			NTOH_8(p->n4TxAntenna_tm4[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm5) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			NTOH_8(p->n2TxAntenna_tm5[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm5) {
		for (size_t i1 = 0; i1 < 16; i1++) {
			NTOH_8(p->n4TxAntenna_tm5[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n2TxAntenna_tm6) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			NTOH_8(p->n2TxAntenna_tm6[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_codebookSubsetRestriction_n4TxAntenna_tm6) {
		for (size_t i1 = 0; i1 < 16; i1++) {
			NTOH_8(p->n4TxAntenna_tm6[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_codebookSubsetRestriction(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_codebookSubsetRestriction* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoDedicated_codebookSubsetRestriction_Sel)_tmp;
	}
	_serSysDecAntennaInfoDedicated_codebookSubsetRestriction_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_codebookSubsetRestriction(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_ue_TransmitAntennaSelection_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaInfoDedicated_ue_TransmitAntennaSelection_Value* p, enum AntennaInfoDedicated_ue_TransmitAntennaSelection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_ue_TransmitAntennaSelection_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == AntennaInfoDedicated_ue_TransmitAntennaSelection_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (AntennaInfoDedicated_ue_TransmitAntennaSelection_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_ue_TransmitAntennaSelection(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_ue_TransmitAntennaSelection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoDedicated_ue_TransmitAntennaSelection_Sel)_tmp;
	}
	_serSysDecAntennaInfoDedicated_ue_TransmitAntennaSelection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->transmissionMode = (AntennaInfoDedicated_transmissionMode_e)_tmp;
	}
	_serSysDecAntennaInfoDedicated_codebookSubsetRestriction_codebookSubsetRestriction_Optional(_buffer, _size, _lidx, &p->codebookSubsetRestriction);
	_serSysDecAntennaInfoDedicated_ue_TransmitAntennaSelection(_buffer, _size, _lidx, &p->ue_TransmitAntennaSelection);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value* p, enum AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n2TxAntenna_tm8_r9) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			NTOH_8(p->n2TxAntenna_tm8_r9[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_n4TxAntenna_tm8_r9) {
		for (size_t i1 = 0; i1 < 32; i1++) {
			NTOH_8(p->n4TxAntenna_tm8_r9[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v920_codebookSubsetRestriction_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Sel)_tmp;
	}
	_serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v920(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v920* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoDedicated_v920_codebookSubsetRestriction_v920_codebookSubsetRestriction_v920_Optional(_buffer, _size, _lidx, &p->codebookSubsetRestriction_v920);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v920_antennaInfo_v920_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v920_antennaInfo_v920_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_v920(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoDedicated(_buffer, _size, _lidx, &p->antennaInfo);
	_serSysDecAntennaInfoDedicated_v920_antennaInfo_v920_Optional(_buffer, _size, _lidx, &p->antennaInfo_v920);

	return SIDL_STATUS_OK;
}

static int _serSysDecBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value* p, enum AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_r10_ue_TransmitAntennaSelection(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_r10_ue_TransmitAntennaSelection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Sel)_tmp;
	}
	_serSysDecAntennaInfoDedicated_r10_ue_TransmitAntennaSelection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AntennaInfoDedicated_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->transmissionMode_r10 = (AntennaInfoDedicated_r10_transmissionMode_r10_e)_tmp;
	}
	_serSysDecBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(_buffer, _size, _lidx, _mem, &p->codebookSubsetRestriction_r10);
	_serSysDecAntennaInfoDedicated_r10_ue_TransmitAntennaSelection(_buffer, _size, _lidx, &p->ue_TransmitAntennaSelection);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AntennaInfoUL_r10_transmissionModeUL_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AntennaInfoUL_r10_fourAntennaPortActivated_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoUL_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoUL_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoUL_r10_transmissionModeUL_r10_e_transmissionModeUL_r10_Optional(_buffer, _size, _lidx, &p->transmissionModeUL_r10);
	_serSysDecAntennaInfoUL_r10_fourAntennaPortActivated_r10_e_fourAntennaPortActivated_r10_Optional(_buffer, _size, _lidx, &p->fourAntennaPortActivated_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoUL_r10_antennaInfoUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoUL_r10_antennaInfoUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoUL_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v10i0(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v10i0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoDedicated_v10i0_maxLayersMIMO_r10_e_maxLayersMIMO_r10_Optional(_buffer, _size, _lidx, &p->maxLayersMIMO_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_v10i0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->alternativeCodebookEnabledFor4TX_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (AntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v1430(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v1430* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoDedicated_v1430_ce_UE_TxAntennaSelection_config_r14_e_ce_UE_TxAntennaSelection_config_r14_Optional(_buffer, _size, _lidx, &p->ce_UE_TxAntennaSelection_config_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct AntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_v1430(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_R10andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AntennaInfoDedicated_R10andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAntennaInfoDedicated_r10(_buffer, _size, _lidx, _mem, &p->antennaInfo);
	_serSysDecAntennaInfoUL_r10_antennaInfoUL_Optional(_buffer, _size, _lidx, &p->antennaInfoUL);
	_serSysDecAntennaInfoDedicated_v10i0_antennaInfoDedicated_v10i0_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v10i0);
	_serSysDecAntennaInfoDedicated_v1250_antennaInfoDedicated_v1250_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v1250);
	_serSysDecAntennaInfoDedicated_v1430_antennaInfoDedicated_v1430_Optional(_buffer, _size, _lidx, &p->antennaInfoDedicated_v1430);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union AntennaInfoDedicated_Type_Value* p, enum AntennaInfoDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AntennaInfoDedicated_Type_R8andLater) {
		_serSysDecAntennaInfoDedicated_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}
	if (d == AntennaInfoDedicated_Type_R10andLater) {
		_serSysDecAntennaInfoDedicated_R10andLater_Type(_buffer, _size, _lidx, _mem, &p->R10andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AntennaInfoDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AntennaInfoDedicated_Type_Sel)_tmp;
	}
	_serSysDecAntennaInfoDedicated_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAntennaInfoDedicated_Type_AntennaInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AntennaInfoDedicated_Type_AntennaInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAntennaInfoDedicated_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecHarqProcessConfigDL_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union HarqProcessConfigDL_Type_Value* p, enum HarqProcessConfigDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == HarqProcessConfigDL_Type_AllProcesses) {
		NTOH_8(p->AllProcesses, &_buffer[*_lidx], _lidx);
	}
	if (d == HarqProcessConfigDL_Type_SpecificSubset) {
		NTOH_32(p->SpecificSubset.d, &_buffer[*_lidx], _lidx);
		p->SpecificSubset.v = serMalloc(_mem, p->SpecificSubset.d * sizeof(HarqProcessId_Type));
		for (size_t i1 = 0; i1 < p->SpecificSubset.d; i1++) {
			NTOH_8(p->SpecificSubset.v[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecHarqProcessConfigDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct HarqProcessConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum HarqProcessConfigDL_Type_Sel)_tmp;
	}
	_serSysDecHarqProcessConfigDL_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecHarqProcessConfigDL_Type_HarqProcessConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct HarqProcessConfigDL_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecHarqProcessConfigDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfigDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciDlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);
	_serSysDecAntennaInfoDedicated_Type_AntennaInfo_Optional(_buffer, _size, _lidx, _mem, &p->AntennaInfo);
	_serSysDecHarqProcessConfigDL_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, _mem, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfigDL_Type_DL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfigDL_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCcchDcchDtchConfigDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDciUlInfo_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct DciUlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDciUlInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPucchHoppingBits_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PucchHoppingBits_Type_Value* p, enum PucchHoppingBits_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PucchHoppingBits_Type_OneBit) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->OneBit[i1], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == PucchHoppingBits_Type_TwoBits) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->TwoBits[i1], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPucchHoppingBits_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PucchHoppingBits_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PucchHoppingBits_Type_Sel)_tmp;
	}
	_serSysDecPucchHoppingBits_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkHoppingResourceParameters_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkHoppingResourceParameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPucchHoppingBits_Type(_buffer, _size, _lidx, &p->PucchHopping);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkHoppingControl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UplinkHoppingControl_Type_Value* p, enum UplinkHoppingControl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkHoppingControl_Type_Deactivated) {
		NTOH_8(p->Deactivated, &_buffer[*_lidx], _lidx);
	}
	if (d == UplinkHoppingControl_Type_Activated) {
		_serSysDecUplinkHoppingResourceParameters_Type(_buffer, _size, _lidx, &p->Activated);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkHoppingControl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkHoppingControl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UplinkHoppingControl_Type_Sel)_tmp;
	}
	_serSysDecUplinkHoppingControl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkHoppingControl_Type_Hopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkHoppingControl_Type_Hopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkHoppingControl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecTransmissionRepetition_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TransmissionRepetition_Type_Value* p, enum TransmissionRepetition_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionRepetition_Type_Continuous) {
		NTOH_8(p->Continuous, &_buffer[*_lidx], _lidx);
	}
	if (d == TransmissionRepetition_Type_NumOfCycles) {
		NTOH_32(p->NumOfCycles, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTransmissionRepetition_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TransmissionRepetition_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TransmissionRepetition_Type_Sel)_tmp;
	}
	_serSysDecTransmissionRepetition_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkTimeAlignment_AutoSynch_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkTimeAlignment_AutoSynch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->TimingAdvance, &_buffer[*_lidx], _lidx);
	NTOH_16(p->TA_Period, &_buffer[*_lidx], _lidx);
	_serSysDecTransmissionRepetition_Type(_buffer, _size, _lidx, &p->TA_Repetition);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkTimeAlignment_Synch_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UplinkTimeAlignment_Synch_Type_Value* p, enum UplinkTimeAlignment_Synch_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UplinkTimeAlignment_Synch_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == UplinkTimeAlignment_Synch_Type_Auto) {
		_serSysDecUplinkTimeAlignment_AutoSynch_Type(_buffer, _size, _lidx, &p->Auto);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkTimeAlignment_Synch_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkTimeAlignment_Synch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UplinkTimeAlignment_Synch_Type_Sel)_tmp;
	}
	_serSysDecUplinkTimeAlignment_Synch_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUplinkTimeAlignment_Synch_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecULGrant_Period_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ULGrant_Period_Type_Value* p, enum ULGrant_Period_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ULGrant_Period_Type_OnlyOnce) {
		NTOH_8(p->OnlyOnce, &_buffer[*_lidx], _lidx);
	}
	if (d == ULGrant_Period_Type_Duration) {
		NTOH_32(p->Duration, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecULGrant_Period_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ULGrant_Period_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ULGrant_Period_Type_Sel)_tmp;
	}
	_serSysDecULGrant_Period_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPeriodicGrant_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PeriodicGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecULGrant_Period_Type(_buffer, _size, _lidx, &p->Period);
	_serSysDecTransmissionRepetition_Type(_buffer, _size, _lidx, &p->NoOfRepetitions);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_GrantConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UL_GrantConfig_Type_Value* p, enum UL_GrantConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_GrantConfig_Type_OnSR_Reception) {
		NTOH_8(p->OnSR_Reception, &_buffer[*_lidx], _lidx);
	}
	if (d == UL_GrantConfig_Type_Periodic) {
		_serSysDecPeriodicGrant_Type(_buffer, _size, _lidx, &p->Periodic);
	}
	if (d == UL_GrantConfig_Type_PeriodicOnSR_Reception) {
		_serSysDecPeriodicGrant_Type(_buffer, _size, _lidx, &p->PeriodicOnSR_Reception);
	}
	if (d == UL_GrantConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_GrantConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_GrantConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UL_GrantConfig_Type_Sel)_tmp;
	}
	_serSysDecUL_GrantConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_GrantConfig_Type_UL_GrantConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_GrantConfig_Type_UL_GrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUL_GrantConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfigUL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDciUlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);
	_serSysDecUplinkHoppingControl_Type_Hopping_Optional(_buffer, _size, _lidx, &p->Hopping);
	_serSysDecUplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(_buffer, _size, _lidx, &p->PUCCH_Synch);
	_serSysDecUL_GrantConfig_Type_UL_GrantConfig_Optional(_buffer, _size, _lidx, &p->UL_GrantConfig);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfigUL_Type_UL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfigUL_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCcchDcchDtchConfigUL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_setup_longDRX_CycleStartOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DRX_Config_setup_longDRX_CycleStartOffset_Value* p, enum DRX_Config_setup_longDRX_CycleStartOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf10) {
		NTOH_8(p->sf10, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf20) {
		NTOH_8(p->sf20, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf32) {
		NTOH_8(p->sf32, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf40) {
		NTOH_8(p->sf40, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf64) {
		NTOH_8(p->sf64, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf80) {
		NTOH_8(p->sf80, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf128) {
		NTOH_8(p->sf128, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf160) {
		NTOH_8(p->sf160, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf256) {
		NTOH_8(p->sf256, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf320) {
		NTOH_16(p->sf320, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf512) {
		NTOH_16(p->sf512, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf640) {
		NTOH_16(p->sf640, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf1024) {
		NTOH_16(p->sf1024, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf1280) {
		NTOH_16(p->sf1280, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf2048) {
		NTOH_16(p->sf2048, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup_longDRX_CycleStartOffset_sf2560) {
		NTOH_16(p->sf2560, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_setup_longDRX_CycleStartOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_setup_longDRX_CycleStartOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DRX_Config_setup_longDRX_CycleStartOffset_Sel)_tmp;
	}
	_serSysDecDRX_Config_setup_longDRX_CycleStartOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_setup_shortDRX(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_setup_shortDRX* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->shortDRX_Cycle = (DRX_Config_setup_shortDRX_shortDRX_Cycle_e)_tmp;
	}
	NTOH_8(p->drxShortCycleTimer, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_setup_shortDRX_shortDRX_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_setup_shortDRX_shortDRX_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDRX_Config_setup_shortDRX(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->onDurationTimer = (DRX_Config_setup_onDurationTimer_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_InactivityTimer = (DRX_Config_setup_drx_InactivityTimer_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_RetransmissionTimer = (DRX_Config_setup_drx_RetransmissionTimer_e)_tmp;
	}
	_serSysDecDRX_Config_setup_longDRX_CycleStartOffset(_buffer, _size, _lidx, &p->longDRX_CycleStartOffset);
	_serSysDecDRX_Config_setup_shortDRX_shortDRX_Optional(_buffer, _size, _lidx, &p->shortDRX);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DRX_Config_Value* p, enum DRX_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == DRX_Config_setup) {
		_serSysDecDRX_Config_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DRX_Config_Sel)_tmp;
	}
	_serSysDecDRX_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_R8_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_R8_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDRX_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DRX_Config_r13_onDurationTimer_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DRX_Config_r13_drx_RetransmissionTimer_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (DRX_Config_r13_drx_ULRetransmissionTimer_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDRX_Config_r13_onDurationTimer_v1310_e_onDurationTimer_v1310_Optional(_buffer, _size, _lidx, &p->onDurationTimer_v1310);
	_serSysDecDRX_Config_r13_drx_RetransmissionTimer_v1310_e_drx_RetransmissionTimer_v1310_Optional(_buffer, _size, _lidx, &p->drx_RetransmissionTimer_v1310);
	_serSysDecDRX_Config_r13_drx_ULRetransmissionTimer_r13_e_drx_ULRetransmissionTimer_r13_Optional(_buffer, _size, _lidx, &p->drx_ULRetransmissionTimer_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_MainConfig_drx_Config_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MAC_MainConfig_drx_Config_r13_Value* p, enum MAC_MainConfig_drx_Config_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_drx_Config_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == MAC_MainConfig_drx_Config_r13_setup) {
		_serSysDecDRX_Config_r13(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, DRX_Config_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MAC_MainConfig_drx_Config_r13_Sel)_tmp;
	}
	_serSysDecMAC_MainConfig_drx_Config_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_r13_Type_R13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_r13_Type_R13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDRX_Config_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value* p, enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_sf5120) {
		NTOH_8(p->sf5120, &_buffer[*_lidx], _lidx);
	}
	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_sf10240) {
		NTOH_8(p->sf10240, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Sel)_tmp;
	}
	_serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value* p, enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup) {
		_serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEDRX_CycleStartOffset_r13_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, EDRX_CycleStartOffset_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Sel)_tmp;
	}
	_serSysDecMAC_MainConfig_eDRX_Config_CycleStartOffset_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEDRX_CycleStartOffset_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDRX_Config_R8_Optional(_buffer, _size, _lidx, &p->R8);
	_serSysDecDRX_Config_r13_Type_R13_Optional(_buffer, _size, _lidx, &p->R13);
	_serSysDecEDRX_CycleStartOffset_r13_Type_EDRX_CycleStartOffset_r13_Optional(_buffer, _size, _lidx, &p->EDRX_CycleStartOffset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DRX_Config_Type_Value* p, enum DRX_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DRX_Config_Type_R8andLater) {
		_serSysDecDRX_Config_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDRX_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DRX_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DRX_Config_Type_Sel)_tmp;
	}
	_serSysDecDRX_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDrxCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DrxCtrl_Type_Value* p, enum DrxCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DrxCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == DrxCtrl_Type_Config) {
		_serSysDecDRX_Config_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDrxCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DrxCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DrxCtrl_Type_Sel)_tmp;
	}
	_serSysDecDrxCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDrxCtrl_Type_DrxCtrl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DrxCtrl_Type_DrxCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDrxCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecE_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct E_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecTTI_BundlingConfig_R8andLater_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TTI_BundlingConfig_R8andLater_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->TTI_BundlingEnabled, &_buffer[*_lidx], _lidx);
	_serSysDecE_HARQ_Pattern_r12_Type_E_HARQ_Pattern_Optional(_buffer, _size, _lidx, &p->E_HARQ_Pattern);

	return SIDL_STATUS_OK;
}

static int _serSysDecTTI_BundlingConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TTI_BundlingConfig_Type_Value* p, enum TTI_BundlingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TTI_BundlingConfig_Type_R8) {
		NTOH_8(p->R8, &_buffer[*_lidx], _lidx);
	}
	if (d == TTI_BundlingConfig_Type_R8andLater) {
		_serSysDecTTI_BundlingConfig_R8andLater_Type(_buffer, _size, _lidx, &p->R8andLater);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecTTI_BundlingConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TTI_BundlingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TTI_BundlingConfig_Type_Sel)_tmp;
	}
	_serSysDecTTI_BundlingConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecTTI_BundlingConfig_Type_TtiBundling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TTI_BundlingConfig_Type_TtiBundling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTTI_BundlingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_CifPresence_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_CifPresence_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMeasGapCtrl_Type_MeasGapCtrl_Optional(_buffer, _size, _lidx, &p->MeasGapCtrl);
	_serSysDecCcchDcchDtchConfigDL_Type_DL_Optional(_buffer, _size, _lidx, _mem, &p->DL);
	_serSysDecCcchDcchDtchConfigUL_Type_UL_Optional(_buffer, _size, _lidx, _mem, &p->UL);
	_serSysDecDrxCtrl_Type_DrxCtrl_Optional(_buffer, _size, _lidx, &p->DrxCtrl);
	_serSysDecTTI_BundlingConfig_Type_TtiBundling_Optional(_buffer, _size, _lidx, &p->TtiBundling);
	_serSysDecBool_CifPresence_Optional(_buffer, _size, _lidx, &p->CifPresence);

	return SIDL_STATUS_OK;
}

static int _serSysDecCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCcchDcchDtchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePatternPCell_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MeasSubframePatternPCell_r10_Value* p, enum MeasSubframePatternPCell_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MeasSubframePatternPCell_r10_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == MeasSubframePatternPCell_r10_setup) {
		_serSysDecMeasSubframePattern_r10(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePatternPCell_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasSubframePatternPCell_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MeasSubframePatternPCell_r10_Sel)_tmp;
	}
	_serSysDecMeasSubframePatternPCell_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMeasSubframePatternPCell_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->cif_Presence_r10, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingCellId_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->pdsch_Start_r10, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value* p, enum CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10) {
		_serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_own_r10(_buffer, _size, _lidx, &p->own_r10);
	}
	if (d == CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10) {
		_serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_other_r10(_buffer, _size, _lidx, &p->other_r10);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Sel)_tmp;
	}
	_serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r10* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCrossCarrierSchedulingConfig_r10_schedulingCellInfo_r10(_buffer, _size, _lidx, &p->schedulingCellInfo_r10);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCrossCarrierSchedulingConfig_r10(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->cif_Presence_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingCellId_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->pdsch_Start_r13, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cif_InSchedulingCell_r13, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value* p, enum CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13) {
		_serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_own_r13(_buffer, _size, _lidx, &p->own_r13);
	}
	if (d == CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13) {
		_serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_other_r13(_buffer, _size, _lidx, &p->other_r13);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Sel)_tmp;
	}
	_serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCrossCarrierSchedulingConfig_r13_schedulingCellInfo_r13(_buffer, _size, _lidx, &p->schedulingCellInfo_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCrossCarrierSchedulingConfig_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierScheduledCellsList_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierScheduledCellsList_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCrossCarrierSchedulingConfig_r10_crossCarrierSchedulingConfig_r10_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_r10);
	_serSysDecCrossCarrierSchedulingConfig_r13_crossCarrierSchedulingConfig_r13_Optional(_buffer, _size, _lidx, &p->crossCarrierSchedulingConfig_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCrossCarrierScheduledCellsList_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPrimaryCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PrimaryCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->AssociatedScellList.d, &_buffer[*_lidx], _lidx);
	p->AssociatedScellList.v = serMalloc(_mem, p->AssociatedScellList.d * sizeof(EUTRA_CellId_Type));
	for (size_t i1 = 0; i1 < p->AssociatedScellList.d; i1++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->AssociatedScellList.v[i1] = (EUTRA_CellId_Type)_tmp;
		}
	}
	_serSysDecMeasSubframePatternPCell_r10_MeasSubframePatternPCell_Optional(_buffer, _size, _lidx, &p->MeasSubframePatternPCell);
	_serSysDecCrossCarrierScheduledCellsList_Type_CrossCarrierScheduledCellsList_Optional(_buffer, _size, _lidx, &p->CrossCarrierScheduledCellsList);

	return SIDL_STATUS_OK;
}

static int _serSysDecScell_Capability_Type_Scell_Capability_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Scell_Capability_Type_Scell_Capability_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Scell_Capability_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecScellDeactivationTimer_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ScellDeactivationTimer_Type_Value* p, enum ScellDeactivationTimer_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ScellDeactivationTimer_Type_NumberOfRadioFrames) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->NumberOfRadioFrames = (MAC_MainConfig_ScellDeactivationTimer_Type)_tmp;
		}
	}
	if (d == ScellDeactivationTimer_Type_Infinity) {
		NTOH_8(p->Infinity, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecScellDeactivationTimer_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ScellDeactivationTimer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ScellDeactivationTimer_Type_Sel)_tmp;
	}
	_serSysDecScellDeactivationTimer_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecScellDeactivationTimer_Type_ScellDeactivationTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ScellDeactivationTimer_Type_ScellDeactivationTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecScellDeactivationTimer_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossSchedulingCarrierInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, CrossSchedulingCarrierInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingCellId_r10, &_buffer[*_lidx], _lidx);
	NTOH_8(p->pdsch_Start_r10, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingCarrierConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SchedulingCarrierConfig_Type_Value* p, enum SchedulingCarrierConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SchedulingCarrierConfig_Type_Own) {
		_serSysDecCrossCarrierScheduledCellsList_Type(_buffer, _size, _lidx, &p->Own);
	}
	if (d == SchedulingCarrierConfig_Type_CrossScheduled) {
		_serSysDecCrossSchedulingCarrierInfo_Type(_buffer, _size, _lidx, &p->CrossScheduled);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSchedulingCarrierConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SchedulingCarrierConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SchedulingCarrierConfig_Type_Sel)_tmp;
	}
	_serSysDecSchedulingCarrierConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union CrossCarrierSchedulingConfig_Type_Value* p, enum CrossCarrierSchedulingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CrossCarrierSchedulingConfig_Type_Config) {
		_serSysDecSchedulingCarrierConfig_Type(_buffer, _size, _lidx, &p->Config);
	}
	if (d == CrossCarrierSchedulingConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CrossCarrierSchedulingConfig_Type_Sel)_tmp;
	}
	_serSysDecCrossCarrierSchedulingConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCrossCarrierSchedulingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSTAG_Id_r11_STAG_Id_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct STAG_Id_r11_STAG_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcell_Mode_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union Pcell_Mode_Type_Value* p, enum Pcell_Mode_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pcell_Mode_Type_FDD) {
		NTOH_8(p->FDD, &_buffer[*_lidx], _lidx);
	}
	if (d == Pcell_Mode_Type_TDD) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->TDD = (TDD_SubframeAssignment_Type)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPcell_Mode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Pcell_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Pcell_Mode_Type_Sel)_tmp;
	}
	_serSysDecPcell_Mode_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Pcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPcell_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecondaryCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SecondaryCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->AssociatedPcellId = (EUTRA_CellId_Type)_tmp;
	}
	NTOH_8(p->SCellIndex, &_buffer[*_lidx], _lidx);
	_serSysDecScell_Capability_Type_Scell_Capability_Optional(_buffer, _size, _lidx, &p->Scell_Capability);
	_serSysDecScellDeactivationTimer_Type_ScellDeactivationTimer_Optional(_buffer, _size, _lidx, &p->ScellDeactivationTimer);
	_serSysDecCrossCarrierSchedulingConfig_Type_SecondaryCellInfo_Type_CrossCarrierSchedulingConfig_Optional(_buffer, _size, _lidx, &p->CrossCarrierSchedulingConfig);
	_serSysDecSTAG_Id_r11_STAG_Id_Optional(_buffer, _size, _lidx, &p->STAG_Id);
	_serSysDecPcell_Mode_Type_SecondaryCellInfo_Type_Pcell_Mode_Optional(_buffer, _size, _lidx, &p->Pcell_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysDecCrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCrossCarrierSchedulingConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Pcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPcell_Mode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPSCellInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PSCellInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->AssociatedPcellId = (EUTRA_CellId_Type)_tmp;
	}
	NTOH_8(p->SCellIndex, &_buffer[*_lidx], _lidx);
	NTOH_32(p->AssociatedScellList.d, &_buffer[*_lidx], _lidx);
	p->AssociatedScellList.v = serMalloc(_mem, p->AssociatedScellList.d * sizeof(EUTRA_CellId_Type));
	for (size_t i1 = 0; i1 < p->AssociatedScellList.d; i1++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->AssociatedScellList.v[i1] = (EUTRA_CellId_Type)_tmp;
		}
	}
	_serSysDecCrossCarrierSchedulingConfig_Type_PSCellInfo_Type_CrossCarrierSchedulingConfig_Optional(_buffer, _size, _lidx, &p->CrossCarrierSchedulingConfig);
	_serSysDecPcell_Mode_Type_PSCellInfo_Type_Pcell_Mode_Optional(_buffer, _size, _lidx, &p->Pcell_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysDecServingCellConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union ServingCellConfig_Type_Value* p, enum ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ServingCellConfig_Type_PCell) {
		_serSysDecPrimaryCellInfo_Type(_buffer, _size, _lidx, _mem, &p->PCell);
	}
	if (d == ServingCellConfig_Type_SCell) {
		_serSysDecSecondaryCellInfo_Type(_buffer, _size, _lidx, &p->SCell);
	}
	if (d == ServingCellConfig_Type_PSCell) {
		_serSysDecPSCellInfo_Type(_buffer, _size, _lidx, _mem, &p->PSCell);
	}
	if (d == ServingCellConfig_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecServingCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ServingCellConfig_Type_Sel)_tmp;
	}
	_serSysDecServingCellConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecServingCellConfig_Type_ServingCellConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecServingCellConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecC_RNTI_SL_RNTI_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct C_RNTI_SL_RNTI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecN_PSCCH_Type_N_PSCCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct N_PSCCH_Type_N_PSCCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 6; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_Sci0Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_Sci0Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUplinkHoppingControl_Type(_buffer, _size, _lidx, &p->Hopping);
	_serSysDecFreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->FreqDomainSchedul);
	NTOH_8(p->Itrp, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_Sci0Config_Type_SL_Sheduling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SL_Sci0Config_Type_SL_Sheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_Sci0Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSci0SchedulingConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Sci0SchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecC_RNTI_SL_RNTI_r12_Optional(_buffer, _size, _lidx, &p->SL_RNTI_r12);
	_serSysDecN_PSCCH_Type_N_PSCCH_Optional(_buffer, _size, _lidx, &p->N_PSCCH);
	_serSysDecSL_Sci0Config_Type_SL_Sheduling_Optional(_buffer, _size, _lidx, &p->SL_Sheduling);

	return SIDL_STATUS_OK;
}

static int _serSysDecC_RNTI_SL_V_RNTI_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct C_RNTI_SL_V_RNTI_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB3_Type_CarrierIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B3_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBIT_STRING_LowestIndexOfChannelAllocation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct BIT_STRING_LowestIndexOfChannelAllocation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB2_Type_SL_Index_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_Type_SL_Index_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB3_Type_SL_SPS_ConfigurationIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B3_Type_SL_SPS_ConfigurationIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 3; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecB1_Type_SL_SPS_ActivationRelease_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B1_Type_SL_SPS_ActivationRelease_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_Sci1Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_Sci1Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->FreqResourceAllocation.d, &_buffer[*_lidx], _lidx);
	p->FreqResourceAllocation.v = serMalloc(_mem, p->FreqResourceAllocation.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->FreqResourceAllocation.d; i1++) {
		NTOH_8(p->FreqResourceAllocation.v[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 4; i1++) {
		NTOH_8(p->TimeGap[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SL_Sci1Config_Type_SL_SCI1_Scheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSL_Sci1Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSci1SchedulingConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Sci1SchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecC_RNTI_SL_V_RNTI_r12_Optional(_buffer, _size, _lidx, &p->SL_V_RNTI_r12);
	_serSysDecB3_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serSysDecBIT_STRING_LowestIndexOfChannelAllocation_Optional(_buffer, _size, _lidx, _mem, &p->LowestIndexOfChannelAllocation);
	_serSysDecB2_Type_SL_Index_Optional(_buffer, _size, _lidx, &p->SL_Index);
	_serSysDecB3_Type_SL_SPS_ConfigurationIndex_Optional(_buffer, _size, _lidx, &p->SL_SPS_ConfigurationIndex);
	_serSysDecB1_Type_SL_SPS_ActivationRelease_Optional(_buffer, _size, _lidx, &p->SL_SPS_ActivationRelease);
	_serSysDecSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(_buffer, _size, _lidx, _mem, &p->SL_SCI1_Scheduling);

	return SIDL_STATUS_OK;
}

static int _serSysDecSciSchedulingConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SciSchedulingConfig_Type_Value* p, enum SciSchedulingConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SciSchedulingConfig_Type_SCI0) {
		_serSysDecSci0SchedulingConfig_Type(_buffer, _size, _lidx, &p->SCI0);
	}
	if (d == SciSchedulingConfig_Type_SCI1) {
		_serSysDecSci1SchedulingConfig_Type(_buffer, _size, _lidx, _mem, &p->SCI1);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSciSchedulingConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SciSchedulingConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SciSchedulingConfig_Type_Sel)_tmp;
	}
	_serSysDecSciSchedulingConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSciSchedulingConfig_Type_SciSchedulingConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SciSchedulingConfig_Type_SciSchedulingConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSciSchedulingConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfig_r12_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EIMTA_MainConfig_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 16; i1++) {
		NTOH_8(p->eimta_RNTI_r12[i1], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->eimta_CommandPeriodicity_r12 = (EIMTA_MainConfig_r12_setup_eimta_CommandPeriodicity_r12_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 10; i1++) {
		NTOH_8(p->eimta_CommandSubframeSet_r12[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfig_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union EIMTA_MainConfig_r12_Value* p, enum EIMTA_MainConfig_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfig_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EIMTA_MainConfig_r12_setup) {
		_serSysDecEIMTA_MainConfig_r12_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfig_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EIMTA_MainConfig_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EIMTA_MainConfig_r12_Sel)_tmp;
	}
	_serSysDecEIMTA_MainConfig_r12_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->subframeConfigList_r12.d, &_buffer[*_lidx], _lidx);
	p->subframeConfigList_r12.v = serMalloc(_mem, p->subframeConfigList_r12.d * sizeof(struct MBSFN_SubframeConfig));
	for (size_t i1 = 0; i1 < p->subframeConfigList_r12.d; i1++) {
		_serSysDecMBSFN_SubframeConfig(_buffer, _size, _lidx, &p->subframeConfigList_r12.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value* p, enum EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup) {
		_serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Sel)_tmp;
	}
	_serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_MainConfigServCell_r12_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->eimta_UL_DL_ConfigIndex_r12, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->eimta_HARQ_ReferenceConfig_r12 = (EIMTA_MainConfigServCell_r12_setup_eimta_HARQ_ReferenceConfig_r12_e)_tmp;
	}
	_serSysDecEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList_v1250);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union EIMTA_MainConfigServCell_r12_Value* p, enum EIMTA_MainConfigServCell_r12_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == EIMTA_MainConfigServCell_r12_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == EIMTA_MainConfigServCell_r12_setup) {
		_serSysDecEIMTA_MainConfigServCell_r12_setup(_buffer, _size, _lidx, _mem, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_MainConfigServCell_r12(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_MainConfigServCell_r12* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum EIMTA_MainConfigServCell_r12_Sel)_tmp;
	}
	_serSysDecEIMTA_MainConfigServCell_r12_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEIMTA_MainConfig_r12(_buffer, _size, _lidx, &p->EIMTA_MainConfig_r12);
	_serSysDecEIMTA_MainConfigServCell_r12(_buffer, _size, _lidx, _mem, &p->EIMTA_MainConfigServCell_r12);

	return SIDL_STATUS_OK;
}

static int _serSysDecEIMTA_Config_Type_EIMTA_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct EIMTA_Config_Type_EIMTA_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEIMTA_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPhysicalConfigDedicated_ce_Mode_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PhysicalConfigDedicated_ce_Mode_r13_Value* p, enum PhysicalConfigDedicated_ce_Mode_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PhysicalConfigDedicated_ce_Mode_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PhysicalConfigDedicated_ce_Mode_r13_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (PhysicalConfigDedicated_ce_Mode_r13_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCE_Mode_r13_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, CE_Mode_r13_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PhysicalConfigDedicated_ce_Mode_r13_Sel)_tmp;
	}
	_serSysDecPhysicalConfigDedicated_ce_Mode_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCE_Mode_r13_Type_CE_Mode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CE_Mode_r13_Type_CE_Mode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecCE_Mode_r13_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecActiveCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ActiveCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecC_RNTI_C_RNTI_Optional(_buffer, _size, _lidx, &p->C_RNTI);
	_serSysDecPhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(_buffer, _size, _lidx, _mem, &p->PhysicalLayerConfigUL);
	_serSysDecRachProcedureConfig_Type_RachProcedureConfig_Optional(_buffer, _size, _lidx, _mem, &p->RachProcedureConfig);
	_serSysDecCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(_buffer, _size, _lidx, _mem, &p->CcchDcchDtchConfig);
	_serSysDecServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, _mem, &p->ServingCellConfig);
	_serSysDecSciSchedulingConfig_Type_SciSchedulingConfig_Optional(_buffer, _size, _lidx, _mem, &p->SciSchedulingConfig);
	_serSysDecEIMTA_Config_Type_EIMTA_Config_Optional(_buffer, _size, _lidx, _mem, &p->EIMTA_Config);
	_serSysDecCE_Mode_r13_Type_CE_Mode_Optional(_buffer, _size, _lidx, &p->CE_Mode);

	return SIDL_STATUS_OK;
}

static int _serSysDecActiveCellConfig_Type_Active_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct ActiveCellConfig_Type_Active_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecActiveCellConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecBasicCellConfig_Type_Basic_Optional(_buffer, _size, _lidx, _mem, &p->Basic);
	_serSysDecActiveCellConfig_Type_Active_Optional(_buffer, _size, _lidx, _mem, &p->Active);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellConfigRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union CellConfigRequest_Type_Value* p, enum CellConfigRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == CellConfigRequest_Type_AddOrReconfigure) {
		_serSysDecCellConfigInfo_Type(_buffer, _size, _lidx, _mem, &p->AddOrReconfigure);
	}
	if (d == CellConfigRequest_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecCellConfigRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CellConfigRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum CellConfigRequest_Type_Sel)_tmp;
	}
	_serSysDecCellConfigRequest_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecAttenuation_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Attenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Attenuation_Type_Sel)_tmp;
	}
	_serSysDecAttenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecTimingInfo_Type_TimingInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimingInfo_Type_TimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecCellAttenuationConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellAttenuationConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (EUTRA_CellId_Type)_tmp;
	}
	_serSysDecAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);
	_serSysDecTimingInfo_Type_TimingInfo_Optional(_buffer, _size, _lidx, &p->TimingInfo);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_discardTimer_e_discardTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_discardTimer_e_discardTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_discardTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_rlc_AM(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_rlc_AM* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->statusReportRequired, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_rlc_AM_rlc_AM_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_rlc_AM_rlc_AM_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_rlc_AM(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_rlc_UM(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_rlc_UM* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcp_SN_Size = (PDCP_Config_rlc_UM_pdcp_SN_Size_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_rlc_UM_rlc_UM_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_rlc_UM_rlc_UM_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_rlc_UM(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_headerCompression_rohc_profiles(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_headerCompression_rohc_profiles* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->profile0x0001, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0002, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0003, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0004, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0006, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0101, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0102, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0103, &_buffer[*_lidx], _lidx);
	NTOH_8(p->profile0x0104, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_headerCompression_rohc(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_headerCompression_rohc* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_PDCP_Config_headerCompression_rohc_maxCID_Optional(_buffer, _size, _lidx, &p->maxCID);
	_serSysDecPDCP_Config_headerCompression_rohc_profiles(_buffer, _size, _lidx, &p->profiles);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_headerCompression_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_headerCompression_Value* p, enum PDCP_Config_headerCompression_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_headerCompression_notUsed) {
		NTOH_8(p->notUsed, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_headerCompression_rohc) {
		_serSysDecPDCP_Config_headerCompression_rohc(_buffer, _size, _lidx, &p->rohc);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_headerCompression(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_headerCompression* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_headerCompression_Sel)_tmp;
	}
	_serSysDecPDCP_Config_headerCompression_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_rn_IntegrityProtection_r10_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_pdcp_SN_Size_v1130_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_t_Reordering_r12_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_DataSplitThreshold_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_ul_DataSplitThreshold_r13_Value* p, enum PDCP_Config_ul_DataSplitThreshold_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_ul_DataSplitThreshold_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_ul_DataSplitThreshold_r13_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (PDCP_Config_ul_DataSplitThreshold_r13_setup_e)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_DataSplitThreshold_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_DataSplitThreshold_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_ul_DataSplitThreshold_r13_Sel)_tmp;
	}
	_serSysDecPDCP_Config_ul_DataSplitThreshold_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_ul_DataSplitThreshold_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_pdcp_SN_Size_v1310_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_TypeForPolling_r13_e_statusPDU_TypeForPolling_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_TypeForPolling_r13);
	_serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type1_r13_e_statusPDU_Periodicity_Type1_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Type1_r13);
	_serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Type2_r13_e_statusPDU_Periodicity_Type2_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Type2_r13);
	_serSysDecPDCP_Config_statusFeedback_r13_setup_statusPDU_Periodicity_Offset_r13_e_statusPDU_Periodicity_Offset_r13_Optional(_buffer, _size, _lidx, &p->statusPDU_Periodicity_Offset_r13);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_statusFeedback_r13_Value* p, enum PDCP_Config_statusFeedback_r13_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_statusFeedback_r13_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_statusFeedback_r13_setup) {
		_serSysDecPDCP_Config_statusFeedback_r13_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_statusFeedback_r13_Sel)_tmp;
	}
	_serSysDecPDCP_Config_statusFeedback_r13_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_statusFeedback_r13(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_LWA_Config_r14_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_LWA_Config_r14_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ul_LWA_DRB_ViaWLAN_r14, &_buffer[*_lidx], _lidx);
	_serSysDecPDCP_Config_ul_LWA_Config_r14_setup_ul_LWA_DataSplitThreshold_r14_e_ul_LWA_DataSplitThreshold_r14_Optional(_buffer, _size, _lidx, &p->ul_LWA_DataSplitThreshold_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_LWA_Config_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_ul_LWA_Config_r14_Value* p, enum PDCP_Config_ul_LWA_Config_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_ul_LWA_Config_r14_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_ul_LWA_Config_r14_setup) {
		_serSysDecPDCP_Config_ul_LWA_Config_r14_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_LWA_Config_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_LWA_Config_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_ul_LWA_Config_r14_Sel)_tmp;
	}
	_serSysDecPDCP_Config_ul_LWA_Config_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_ul_LWA_Config_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->profile0x0006_r14, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUint16_t_PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_maxCID_r14_Optional(_buffer, _size, _lidx, &p->maxCID_r14);
	_serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14_profiles_r14(_buffer, _size, _lidx, &p->profiles_r14);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_uplinkOnlyHeaderCompression_r14_Value* p, enum PDCP_Config_uplinkOnlyHeaderCompression_r14_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_uplinkOnlyHeaderCompression_r14_notUsed_r14) {
		NTOH_8(p->notUsed_r14, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14) {
		_serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_rohc_r14(_buffer, _size, _lidx, &p->rohc_r14);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkOnlyHeaderCompression_r14* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_uplinkOnlyHeaderCompression_r14_Sel)_tmp;
	}
	_serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PDCP_Config_uplinkDataCompression_r15_dictionary_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkDataCompression_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkDataCompression_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->bufferSize_r15 = (PDCP_Config_uplinkDataCompression_r15_bufferSize_r15_e)_tmp;
	}
	_serSysDecPDCP_Config_uplinkDataCompression_r15_dictionary_r15_e_dictionary_r15_Optional(_buffer, _size, _lidx, &p->dictionary_r15);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_uplinkDataCompression_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_setup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_pdcp_DuplicationConfig_r15_setup* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdcp_Duplication_r15 = (PDCP_Config_pdcp_DuplicationConfig_r15_setup_pdcp_Duplication_r15_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_pdcp_DuplicationConfig_r15_Value* p, enum PDCP_Config_pdcp_DuplicationConfig_r15_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_pdcp_DuplicationConfig_r15_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Config_pdcp_DuplicationConfig_r15_setup) {
		_serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_setup(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_DuplicationConfig_r15(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_pdcp_DuplicationConfig_r15* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_pdcp_DuplicationConfig_r15_Sel)_tmp;
	}
	_serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Config_pdcp_DuplicationConfig_r15(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Common_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Common_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ehc_CID_Length_r16 = (EthernetHeaderCompression_r16_ehc_Common_r16_ehc_CID_Length_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (EthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Downlink_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16_drb_ContinueEHC_DL_r16_e_drb_ContinueEHC_DL_r16_Optional(_buffer, _size, _lidx, &p->drb_ContinueEHC_DL_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (EthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Uplink_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->maxCID_EHC_UL_r16, &_buffer[*_lidx], _lidx);
	_serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16_drb_ContinueEHC_UL_r16_e_drb_ContinueEHC_UL_r16_Optional(_buffer, _size, _lidx, &p->drb_ContinueEHC_UL_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecEthernetHeaderCompression_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct EthernetHeaderCompression_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecEthernetHeaderCompression_r16_ehc_Common_r16(_buffer, _size, _lidx, &p->ehc_Common_r16);
	_serSysDecEthernetHeaderCompression_r16_ehc_Downlink_r16_ehc_Downlink_r16_Optional(_buffer, _size, _lidx, &p->ehc_Downlink_r16);
	_serSysDecEthernetHeaderCompression_r16_ehc_Uplink_r16_ehc_Uplink_r16_Optional(_buffer, _size, _lidx, &p->ehc_Uplink_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value* p, enum SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
	}
	if (d == SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_setup) {
		_serSysDecEthernetHeaderCompression_r16(_buffer, _size, _lidx, &p->setup);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SetupRelease_PDCP_Config_ethernetHeaderCompression_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Sel)_tmp;
	}
	_serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDCP_Config_discardTimer_e_discardTimer_Optional(_buffer, _size, _lidx, &p->discardTimer);
	_serSysDecPDCP_Config_rlc_AM_rlc_AM_Optional(_buffer, _size, _lidx, &p->rlc_AM);
	_serSysDecPDCP_Config_rlc_UM_rlc_UM_Optional(_buffer, _size, _lidx, &p->rlc_UM);
	_serSysDecPDCP_Config_headerCompression(_buffer, _size, _lidx, &p->headerCompression);
	_serSysDecPDCP_Config_rn_IntegrityProtection_r10_e_rn_IntegrityProtection_r10_Optional(_buffer, _size, _lidx, &p->rn_IntegrityProtection_r10);
	_serSysDecPDCP_Config_pdcp_SN_Size_v1130_e_pdcp_SN_Size_v1130_Optional(_buffer, _size, _lidx, &p->pdcp_SN_Size_v1130);
	_serSysDecBool_PDCP_Config_ul_DataSplitDRB_ViaSCG_r12_Optional(_buffer, _size, _lidx, &p->ul_DataSplitDRB_ViaSCG_r12);
	_serSysDecPDCP_Config_t_Reordering_r12_e_t_Reordering_r12_Optional(_buffer, _size, _lidx, &p->t_Reordering_r12);
	_serSysDecPDCP_Config_ul_DataSplitThreshold_r13_ul_DataSplitThreshold_r13_Optional(_buffer, _size, _lidx, &p->ul_DataSplitThreshold_r13);
	_serSysDecPDCP_Config_pdcp_SN_Size_v1310_e_pdcp_SN_Size_v1310_Optional(_buffer, _size, _lidx, &p->pdcp_SN_Size_v1310);
	_serSysDecPDCP_Config_statusFeedback_r13_statusFeedback_r13_Optional(_buffer, _size, _lidx, &p->statusFeedback_r13);
	_serSysDecPDCP_Config_ul_LWA_Config_r14_ul_LWA_Config_r14_Optional(_buffer, _size, _lidx, &p->ul_LWA_Config_r14);
	_serSysDecPDCP_Config_uplinkOnlyHeaderCompression_r14_uplinkOnlyHeaderCompression_r14_Optional(_buffer, _size, _lidx, &p->uplinkOnlyHeaderCompression_r14);
	_serSysDecPDCP_Config_uplinkDataCompression_r15_uplinkDataCompression_r15_Optional(_buffer, _size, _lidx, &p->uplinkDataCompression_r15);
	_serSysDecPDCP_Config_pdcp_DuplicationConfig_r15_pdcp_DuplicationConfig_r15_Optional(_buffer, _size, _lidx, &p->pdcp_DuplicationConfig_r15);
	_serSysDecSetupRelease_PDCP_Config_ethernetHeaderCompression_r16_PDCP_Config_ethernetHeaderCompression_r16_Optional(_buffer, _size, _lidx, &p->ethernetHeaderCompression_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Config_Type_Value* p, enum PDCP_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Config_Type_R8) {
		_serSysDecPDCP_Config(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Config_Type_Sel)_tmp;
	}
	_serSysDecPDCP_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_RBConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_RBConfig_Type_Value* p, enum PDCP_RBConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_RBConfig_Type_Srb) {
		NTOH_8(p->Srb, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_RBConfig_Type_Drb) {
		_serSysDecPDCP_Config_Type(_buffer, _size, _lidx, &p->Drb);
	}
	if (d == PDCP_RBConfig_Type_Transparent) {
		NTOH_8(p->Transparent, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_RBConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_RBConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_RBConfig_Type_Sel)_tmp;
	}
	_serSysDecPDCP_RBConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_RBConfig_Type_Rb_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_RBConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_RBConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_ROHC_Mode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_ROHC_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->SN_Size = (PDCP_SNLength_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_NonROHC_Mode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_NonROHC_Mode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->SN_Size = (PDCP_SNLength_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_TestModeInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_TestModeInfo_Type_Value* p, enum PDCP_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_TestModeInfo_Type_PDCP_ROHC_Mode) {
		_serSysDecPDCP_ROHC_Mode_Type(_buffer, _size, _lidx, &p->PDCP_ROHC_Mode);
	}
	if (d == PDCP_TestModeInfo_Type_PDCP_NonROHC_Mode) {
		_serSysDecPDCP_NonROHC_Mode_Type(_buffer, _size, _lidx, &p->PDCP_NonROHC_Mode);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_TestModeInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_TestModeInfo_Type_Sel)_tmp;
	}
	_serSysDecPDCP_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_TestModeConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_TestModeConfig_Type_Value* p, enum PDCP_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_TestModeConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_TestModeConfig_Type_Info) {
		_serSysDecPDCP_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_TestModeConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_TestModeConfig_Type_Sel)_tmp;
	}
	_serSysDecPDCP_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_TestModeConfig_Type_TestMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_ConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_ConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDCP_RBConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serSysDecPDCP_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Configuration_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_Configuration_Type_Value* p, enum PDCP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_Configuration_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_Configuration_Type_Config) {
		_serSysDecPDCP_ConfigInfo_Type(_buffer, _size, _lidx, &p->Config);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_Configuration_Type_Sel)_tmp;
	}
	_serSysDecPDCP_Configuration_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_Configuration_Type_Pdcp_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_Configuration_Type_Pdcp_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPDCP_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_AM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_PollRetransmit = (T_PollRetransmit_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pollPDU = (PollPDU_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pollByte = (PollByte_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxRetxThreshold = (UL_AM_RLC_maxRetxThreshold_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_AM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UL_AM_RLC_Type_Value* p, enum UL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_AM_RLC_Type_R8) {
		_serSysDecUL_AM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_AM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UL_AM_RLC_Type_Sel)_tmp;
	}
	_serSysDecUL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_AM_RLC_Type_Tx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_AM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_AM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Reordering = (T_Reordering_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_StatusProhibit = (T_StatusProhibit_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_AM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DL_AM_RLC_Type_Value* p, enum DL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DL_AM_RLC_Type_R8) {
		_serSysDecDL_AM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_AM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DL_AM_RLC_Type_Sel)_tmp;
	}
	_serSysDecDL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_AM_RLC_Type_Rx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_AM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_Config_v1250(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_Config_v1250* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ul_extended_RLC_LI_Field_r12, &_buffer[*_lidx], _lidx);
	NTOH_8(p->dl_extended_RLC_LI_Field_r12, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_Config_v1250_ExtendedLI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_Config_v1250_ExtendedLI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRLC_Config_v1250(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RLC_AM_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_RLC_AM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUL_AM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serSysDecDL_AM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);
	_serSysDecRLC_Config_v1250_ExtendedLI_Optional(_buffer, _size, _lidx, &p->ExtendedLI);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_UM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sn_FieldLength = (SN_FieldLength_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_UM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UL_UM_RLC_Type_Value* p, enum UL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_UM_RLC_Type_R8) {
		_serSysDecUL_UM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_UM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UL_UM_RLC_Type_Sel)_tmp;
	}
	_serSysDecUL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_UM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sn_FieldLength = (SN_FieldLength_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Reordering = (T_Reordering_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_UM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DL_UM_RLC_Type_Value* p, enum DL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DL_UM_RLC_Type_R8) {
		_serSysDecDL_UM_RLC(_buffer, _size, _lidx, &p->R8);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_UM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DL_UM_RLC_Type_Sel)_tmp;
	}
	_serSysDecDL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RLC_UM_Bi_Directional_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_RLC_UM_Bi_Directional_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serSysDecDL_UM_RLC_Type_SS_RLC_UM_Bi_Directional_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serSysDecDL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecDL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RLC_UM_Uni_Directional_UL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_RLC_UM_Uni_Directional_UL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecDL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_UL_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecUL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecSS_RLC_UM_Uni_Directional_DL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SS_RLC_UM_Uni_Directional_DL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecUL_UM_RLC_Type_SS_RLC_UM_Uni_Directional_DL_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_RbConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RLC_RbConfig_Type_Value* p, enum RLC_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_RbConfig_Type_AM) {
		_serSysDecSS_RLC_AM_Type(_buffer, _size, _lidx, &p->AM);
	}
	if (d == RLC_RbConfig_Type_UM) {
		_serSysDecSS_RLC_UM_Bi_Directional_Type(_buffer, _size, _lidx, &p->UM);
	}
	if (d == RLC_RbConfig_Type_UM_OnlyUL) {
		_serSysDecSS_RLC_UM_Uni_Directional_UL_Type(_buffer, _size, _lidx, &p->UM_OnlyUL);
	}
	if (d == RLC_RbConfig_Type_UM_OnlyDL) {
		_serSysDecSS_RLC_UM_Uni_Directional_DL_Type(_buffer, _size, _lidx, &p->UM_OnlyDL);
	}
	if (d == RLC_RbConfig_Type_TM) {
		NTOH_8(p->TM, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_RbConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RLC_RbConfig_Type_Sel)_tmp;
	}
	_serSysDecRLC_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_RbConfig_Type_Rb_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_RbConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRLC_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_TestModeInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RLC_TestModeInfo_Type_Value* p, enum RLC_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_TestModeInfo_Type_AckProhibit) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->AckProhibit = (RLC_ACK_Prohibit_Type)_tmp;
		}
	}
	if (d == RLC_TestModeInfo_Type_NotACK_NextRLC_PDU) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->NotACK_NextRLC_PDU = (RLC_NotACK_NextRLC_PDU_Type)_tmp;
		}
	}
	if (d == RLC_TestModeInfo_Type_ModifyVTS) {
		NTOH_16(p->ModifyVTS, &_buffer[*_lidx], _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_UMDwith5BitSN) {
		NTOH_8(p->TransparentMode_UMDwith5BitSN, &_buffer[*_lidx], _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_UMDwith10BitSN) {
		NTOH_8(p->TransparentMode_UMDwith10BitSN, &_buffer[*_lidx], _lidx);
	}
	if (d == RLC_TestModeInfo_Type_TransparentMode_AMD) {
		NTOH_8(p->TransparentMode_AMD, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_TestModeInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RLC_TestModeInfo_Type_Sel)_tmp;
	}
	_serSysDecRLC_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_TestModeConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RLC_TestModeConfig_Type_Value* p, enum RLC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RLC_TestModeConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == RLC_TestModeConfig_Type_Info) {
		_serSysDecRLC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_TestModeConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RLC_TestModeConfig_Type_Sel)_tmp;
	}
	_serSysDecRLC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_TestModeConfig_Type_TestMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRLC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRLC_RbConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serSysDecRLC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysDecRLC_Configuration_Type_Rlc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RLC_Configuration_Type_Rlc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecRLC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecLogicalChannelId_Type_LogicalChannelId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct LogicalChannelId_Type_LogicalChannelId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecNull_Type_LAA_UL_Allowed_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Null_Type_LAA_UL_Allowed_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_LogicalChannelConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_LogicalChannelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->Priority, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->PrioritizedBitRate = (PrioritizedBitRate_Type)_tmp;
	}
	_serSysDecNull_Type_LAA_UL_Allowed_Optional(_buffer, _size, _lidx, &p->LAA_UL_Allowed);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_LogicalChannelConfig_Type_LogicalChannel_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_LogicalChannelConfig_Type_LogicalChannel_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMAC_LogicalChannelConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_Test_DLLogChID_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_Test_DLLogChID_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->LogChId, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ConfigLchId, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_TestModeInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMAC_Test_DLLogChID_Type(_buffer, _size, _lidx, &p->DiffLogChId);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->No_HeaderManipulation = (MAC_Test_SCH_NoHeaderManipulation_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_TestModeConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union MAC_TestModeConfig_Type_Value* p, enum MAC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == MAC_TestModeConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == MAC_TestModeConfig_Type_Info) {
		_serSysDecMAC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_TestModeConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum MAC_TestModeConfig_Type_Sel)_tmp;
	}
	_serSysDecMAC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_TestModeConfig_Type_TestMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMAC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecMAC_LogicalChannelConfig_Type_LogicalChannel_Optional(_buffer, _size, _lidx, &p->LogicalChannel);
	_serSysDecMAC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serSysDecMAC_Configuration_Type_Mac_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct MAC_Configuration_Type_Mac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecMAC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecBool_DiscardULData_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_DiscardULData_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearerConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RadioBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPDCP_Configuration_Type_Pdcp_Optional(_buffer, _size, _lidx, &p->Pdcp);
	_serSysDecRLC_Configuration_Type_Rlc_Optional(_buffer, _size, _lidx, &p->Rlc);
	_serSysDecLogicalChannelId_Type_LogicalChannelId_Optional(_buffer, _size, _lidx, &p->LogicalChannelId);
	_serSysDecMAC_Configuration_Type_Mac_Optional(_buffer, _size, _lidx, &p->Mac);
	_serSysDecBool_DiscardULData_Optional(_buffer, _size, _lidx, &p->DiscardULData);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearerConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RadioBearerConfig_Type_Value* p, enum RadioBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RadioBearerConfig_Type_AddOrReconfigure) {
		_serSysDecRadioBearerConfigInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
	}
	if (d == RadioBearerConfig_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearerConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RadioBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RadioBearerConfig_Type_Sel)_tmp;
	}
	_serSysDecRadioBearerConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecRadioBearer_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct RadioBearer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRadioBearerId_Type(_buffer, _size, _lidx, _mem, &p->Id);
	_serSysDecRadioBearerConfig_Type(_buffer, _size, _lidx, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpSQN_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdcpSQN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (PdcpCountFormat_Type)_tmp;
	}
	NTOH_32(p->Value, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_ActTime_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union PDCP_ActTime_Type_Value* p, enum PDCP_ActTime_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PDCP_ActTime_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
	}
	if (d == PDCP_ActTime_Type_SQN) {
		_serSysDecPdcpSQN_Type(_buffer, _size, _lidx, &p->SQN);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPDCP_ActTime_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PDCP_ActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PDCP_ActTime_Type_Sel)_tmp;
	}
	_serSysDecPDCP_ActTime_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecurityActTime_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SecurityActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRadioBearerId_Type(_buffer, _size, _lidx, _mem, &p->RadioBearerId);
	_serSysDecPDCP_ActTime_Type(_buffer, _size, _lidx, &p->UL);
	_serSysDecPDCP_ActTime_Type(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serSysDecSecurityActTimeList_Type_ActTimeList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct SecurityActTime_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecSecurityActTime_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_IntegrityInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_IntegrityInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Algorithm = (CipheringAlgorithm_r12_Type)_tmp;
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KRRCint[i1], &_buffer[*_lidx], _lidx);
	}
	_serSysDecSecurityActTimeList_Type_ActTimeList_Optional(_buffer, _size, _lidx, _mem, &p->ActTimeList);

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_IntegrityInfo_Type_Integrity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAS_IntegrityInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_CipheringInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_CipheringInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Algorithm = (CipheringAlgorithm_r12_Type)_tmp;
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KRRCenc[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KUPenc[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->ActTimeList.d, &_buffer[*_lidx], _lidx);
	p->ActTimeList.v = serMalloc(_mem, p->ActTimeList.d * sizeof(struct SecurityActTime_Type));
	for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
		_serSysDecSecurityActTime_Type(_buffer, _size, _lidx, _mem, &p->ActTimeList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_CipheringInfo_Type_Ciphering_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecAS_CipheringInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_SecStartRestart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_SecStartRestart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecAS_IntegrityInfo_Type_Integrity_Optional(_buffer, _size, _lidx, _mem, &p->Integrity);
	_serSysDecAS_CipheringInfo_Type_Ciphering_Optional(_buffer, _size, _lidx, _mem, &p->Ciphering);

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_Security_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union AS_Security_Type_Value* p, enum AS_Security_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == AS_Security_Type_StartRestart) {
		_serSysDecAS_SecStartRestart_Type(_buffer, _size, _lidx, _mem, &p->StartRestart);
	}
	if (d == AS_Security_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecAS_Security_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct AS_Security_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum AS_Security_Type_Sel)_tmp;
	}
	_serSysDecAS_Security_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecS_TMSI(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct S_TMSI* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 8; i2++) {
		NTOH_8(p->mmec[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		NTOH_8(p->m_TMSI[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingUE_Identity_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PagingUE_Identity_Value* p, enum PagingUE_Identity_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PagingUE_Identity_s_TMSI) {
		_serSysDecS_TMSI(_buffer, _size, _lidx, &p->s_TMSI);
	}
	if (d == PagingUE_Identity_imsi) {
		NTOH_32(p->imsi.d, &_buffer[*_lidx], _lidx);
		p->imsi.v = serMalloc(_mem, p->imsi.d * sizeof(IMSI_Digit));
		for (size_t i2 = 0; i2 < p->imsi.d; i2++) {
			NTOH_8(p->imsi.v[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == PagingUE_Identity_ng_5G_S_TMSI_r15) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			NTOH_8(p->ng_5G_S_TMSI_r15[i2], &_buffer[*_lidx], _lidx);
		}
	}
	if (d == PagingUE_Identity_fullI_RNTI_r15) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			NTOH_8(p->fullI_RNTI_r15[i2], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingUE_Identity(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PagingUE_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PagingUE_Identity_Sel)_tmp;
	}
	_serSysDecPagingUE_Identity_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecord(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PagingRecord* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPagingUE_Identity(_buffer, _size, _lidx, _mem, &p->ue_Identity);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cn_Domain = (PagingRecord_cn_Domain_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecordList_Paging_pagingRecordList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PagingRecordList_Paging_pagingRecordList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PagingRecord));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPagingRecord(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_systemInfoModification_e_systemInfoModification_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_systemInfoModification_e_systemInfoModification_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_systemInfoModification_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_etws_Indication_e_etws_Indication_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_etws_Indication_e_etws_Indication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_etws_Indication_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v920_IEs_cmas_Indication_r9_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v1130_IEs_eab_ParamModification_r11_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v1310_IEs_redistributionIndication_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v1310_IEs_systemInfoModification_eDRX_r13_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1530_IEs_accessType_e_accessType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1530_IEs_accessType_e_accessType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v1530_IEs_accessType_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecord_v1610_accessType_r16_e_accessType_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PagingRecord_v1610_accessType_r16_e_accessType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PagingRecord_v1610_accessType_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (PagingRecord_v1610_mt_EDT_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecord_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PagingRecord_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPagingRecord_v1610_accessType_r16_e_accessType_r16_Optional(_buffer, _size, _lidx, &p->accessType_r16);
	_serSysDecPagingRecord_v1610_mt_EDT_r16_e_mt_EDT_r16_Optional(_buffer, _size, _lidx, &p->mt_EDT_r16);

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(struct PagingRecord_v1610));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serSysDecPagingRecord_v1610(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (Paging_v1610_IEs_uac_ParamModification_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1610_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Paging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1610_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->pagingRecordList_v1610);
	_serSysDecPaging_v1610_IEs_uac_ParamModification_r16_e_uac_ParamModification_r16_Optional(_buffer, _size, _lidx, &p->uac_ParamModification_r16);
	_serSysDecPaging_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v1610_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1530_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1530_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPaging_v1530_IEs_accessType_e_accessType_Optional(_buffer, _size, _lidx, &p->accessType);
	_serSysDecPaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v1530_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1310_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1310_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPaging_v1310_IEs_redistributionIndication_r13_e_redistributionIndication_r13_Optional(_buffer, _size, _lidx, &p->redistributionIndication_r13);
	_serSysDecPaging_v1310_IEs_systemInfoModification_eDRX_r13_e_systemInfoModification_eDRX_r13_Optional(_buffer, _size, _lidx, &p->systemInfoModification_eDRX_r13);
	_serSysDecPaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v1310_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1130_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1130_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPaging_v1130_IEs_eab_ParamModification_r11_e_eab_ParamModification_r11_Optional(_buffer, _size, _lidx, &p->eab_ParamModification_r11);
	_serSysDecPaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v1130_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v920_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v920_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPaging_v920_IEs_cmas_Indication_r9_e_cmas_Indication_r9_Optional(_buffer, _size, _lidx, &p->cmas_Indication_r9);
	_serSysDecPaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v920_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v890_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v890_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serSysDecPaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging_v890_IEs_Paging_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging_v890_IEs_Paging_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPaging_v890_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPaging(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Paging* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPagingRecordList_Paging_pagingRecordList_Optional(_buffer, _size, _lidx, _mem, &p->pagingRecordList);
	_serSysDecPaging_systemInfoModification_e_systemInfoModification_Optional(_buffer, _size, _lidx, &p->systemInfoModification);
	_serSysDecPaging_etws_Indication_e_etws_Indication_Optional(_buffer, _size, _lidx, &p->etws_Indication);
	_serSysDecPaging_v890_IEs_Paging_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_MessageType_c1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PCCH_MessageType_c1_Value* p, enum PCCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PCCH_MessageType_c1_paging) {
		_serSysDecPaging(_buffer, _size, _lidx, _mem, &p->paging);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_MessageType_c1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PCCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PCCH_MessageType_c1_Sel)_tmp;
	}
	_serSysDecPCCH_MessageType_c1_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_MessageType_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PCCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_MessageType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PCCH_MessageType_Value* p, enum PCCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PCCH_MessageType_c1) {
		_serSysDecPCCH_MessageType_c1(_buffer, _size, _lidx, _mem, &p->c1);
	}
	if (d == PCCH_MessageType_messageClassExtension) {
		_serSysDecPCCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_MessageType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PCCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PCCH_MessageType_Sel)_tmp;
	}
	_serSysDecPCCH_MessageType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPCCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PCCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPCCH_MessageType(_buffer, _size, _lidx, _mem, &p->message);

	return SIDL_STATUS_OK;
}

static int _serSysDecSubframeOffsetList_Type_SubframeOffsetList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = serMalloc(_mem, p->v.d * sizeof(int32_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPagingTrigger_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PagingTrigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecPCCH_Message(_buffer, _size, _lidx, _mem, &p->Paging);
	_serSysDecSubframeOffsetList_Type_SubframeOffsetList_Optional(_buffer, _size, _lidx, _mem, &p->SubframeOffsetList);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCountGetReq_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union PdcpCountGetReq_Type_Value* p, enum PdcpCountGetReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == PdcpCountGetReq_Type_AllRBs) {
		NTOH_8(p->AllRBs, &_buffer[*_lidx], _lidx);
	}
	if (d == PdcpCountGetReq_Type_SingleRB) {
		_serSysDecRadioBearerId_Type(_buffer, _size, _lidx, _mem, &p->SingleRB);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCountGetReq_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcpCountGetReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum PdcpCountGetReq_Type_Sel)_tmp;
	}
	_serSysDecPdcpCountGetReq_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCount_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdcpCount_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (PdcpCountFormat_Type)_tmp;
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCount_Type_UL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdcpCount_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCount_Type_DL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PdcpCount_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serSysDecPdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcpCountInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct PdcpCountInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecRadioBearerId_Type(_buffer, _size, _lidx, _mem, &p->RadioBearerId);
	_serSysDecPdcpCount_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serSysDecPdcpCount_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcp_CountReq_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union Pdcp_CountReq_Type_Value* p, enum Pdcp_CountReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pdcp_CountReq_Type_Get) {
		_serSysDecPdcpCountGetReq_Type(_buffer, _size, _lidx, _mem, &p->Get);
	}
	if (d == Pdcp_CountReq_Type_Set) {
		NTOH_32(p->Set.d, &_buffer[*_lidx], _lidx);
		p->Set.v = serMalloc(_mem, p->Set.d * sizeof(struct PdcpCountInfo_Type));
		for (size_t i1 = 0; i1 < p->Set.d; i1++) {
			_serSysDecPdcpCountInfo_Type(_buffer, _size, _lidx, _mem, &p->Set.v[i1]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcp_CountReq_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Pdcp_CountReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Pdcp_CountReq_Type_Sel)_tmp;
	}
	_serSysDecPdcp_CountReq_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_Category_v1020_Type_ue_Category_V1020_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_Category_v1020_Type_ue_Category_V1020_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_Category_v1170_Type_ue_Category_v1170_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_Category_v1170_Type_ue_Category_v1170_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_Category_v11a0_Type_ue_Category_v11a0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_Category_v11a0_Type_ue_Category_v11a0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_Category_v1250_Type_ue_Category_v1250_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_Category_v1250_Type_ue_Category_v1250_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_CategoryDL_v1310_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (UE_CategoryDL_v1350_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serSysDecUE_CategoryInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_CategoryInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ue_Category, &_buffer[*_lidx], _lidx);
	_serSysDecUE_Category_v1020_Type_ue_Category_V1020_Optional(_buffer, _size, _lidx, &p->ue_Category_V1020);
	_serSysDecUE_Category_v1170_Type_ue_Category_v1170_Optional(_buffer, _size, _lidx, &p->ue_Category_v1170);
	_serSysDecUE_Category_v11a0_Type_ue_Category_v11a0_Optional(_buffer, _size, _lidx, &p->ue_Category_v11a0);
	_serSysDecUE_Category_v1250_Type_ue_Category_v1250_Optional(_buffer, _size, _lidx, &p->ue_Category_v1250);
	_serSysDecUE_CategoryDL_r12_Type_ue_CategoryDL_r12_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_r12);
	_serSysDecUE_CategoryDL_v1260_Type_ue_CategoryDL_v1260_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1260);
	_serSysDecUE_CategoryDL_v1310_Type_ue_CategoryDL_v1310_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1310);
	_serSysDecUE_CategoryDL_v1330_Type_ue_CategoryDL_v1330_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1330);
	_serSysDecUE_CategoryDL_v1350_Type_ue_CategoryDL_v1350_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1350);
	_serSysDecUE_CategoryDL_v1460_Type_ue_CategoryDL_v1460_Optional(_buffer, _size, _lidx, &p->ue_CategoryDL_v1460);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemRequest_Type_Value* p, enum SystemRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemRequest_Type_Cell) {
		_serSysDecCellConfigRequest_Type(_buffer, _size, _lidx, _mem, &p->Cell);
	}
	if (d == SystemRequest_Type_CellAttenuationList) {
		NTOH_32(p->CellAttenuationList.d, &_buffer[*_lidx], _lidx);
		p->CellAttenuationList.v = serMalloc(_mem, p->CellAttenuationList.d * sizeof(struct CellAttenuationConfig_Type));
		for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			_serSysDecCellAttenuationConfig_Type(_buffer, _size, _lidx, &p->CellAttenuationList.v[i1]);
		}
	}
	if (d == SystemRequest_Type_RadioBearerList) {
		NTOH_32(p->RadioBearerList.d, &_buffer[*_lidx], _lidx);
		p->RadioBearerList.v = serMalloc(_mem, p->RadioBearerList.d * sizeof(struct RadioBearer_Type));
		for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
			_serSysDecRadioBearer_Type(_buffer, _size, _lidx, _mem, &p->RadioBearerList.v[i1]);
		}
	}
	if (d == SystemRequest_Type_EnquireTiming) {
		NTOH_8(p->EnquireTiming, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemRequest_Type_AS_Security) {
		_serSysDecAS_Security_Type(_buffer, _size, _lidx, _mem, &p->AS_Security);
	}
	if (d == SystemRequest_Type_Paging) {
		_serSysDecPagingTrigger_Type(_buffer, _size, _lidx, _mem, &p->Paging);
	}
	if (d == SystemRequest_Type_PdcpCount) {
		_serSysDecPdcp_CountReq_Type(_buffer, _size, _lidx, _mem, &p->PdcpCount);
	}
	if (d == SystemRequest_Type_UE_Cat_Info) {
		_serSysDecUE_CategoryInfo_Type(_buffer, _size, _lidx, &p->UE_Cat_Info);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemRequest_Type_Sel)_tmp;
	}
	_serSysDecSystemRequest_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSYSTEM_CTRL_REQ(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SYSTEM_CTRL_REQ* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecReqAspCommonPart_Type(_buffer, _size, _lidx, _mem, &p->Common);
	_serSysDecSystemRequest_Type(_buffer, _size, _lidx, _mem, &p->Request);

	return SIDL_STATUS_OK;
}

int serSysProcessDecSrv(const unsigned char* _buffer, size_t _size, unsigned char* _arena, size_t _aSize, struct SYSTEM_CTRL_REQ** FromSS)
{
	(void)_size; // TODO: generate boundaries checking

	serMem_t _mem = serMemInit(_arena, _aSize);

	size_t __lidx = 0;
	size_t* _lidx = &__lidx;

	*FromSS = serMalloc(_mem, sizeof(struct SYSTEM_CTRL_REQ));
	_serSysDecSYSTEM_CTRL_REQ(_buffer, _size, _lidx, _mem, *FromSS);

	return SIDL_STATUS_OK;
}

static void _serSysFreePLMN_Identity(struct PLMN_Identity* p)
{
	if (p->mnc.v) {
		serFree(p->mnc.v);
	}
}

static void _serSysFreeTMGI_r9_plmn_Id_r9_Value(union TMGI_r9_plmn_Id_r9_Value* p, enum TMGI_r9_plmn_Id_r9_Sel d)
{
	if (d == TMGI_r9_plmn_Id_r9_explicitValue_r9) {
		_serSysFreePLMN_Identity(&p->explicitValue_r9);
	}
}

static void _serSysFreeTMGI_r9_plmn_Id_r9(struct TMGI_r9_plmn_Id_r9* p)
{
	_serSysFreeTMGI_r9_plmn_Id_r9_Value(&p->v, p->d);
}

static void _serSysFreeTMGI_r9(struct TMGI_r9* p)
{
	_serSysFreeTMGI_r9_plmn_Id_r9(&p->plmn_Id_r9);
}

static void _serSysFreeMBMSSessionInfo_r13(struct MBMSSessionInfo_r13* p)
{
	_serSysFreeTMGI_r9(&p->tmgi_r13);
}

static void _serSysFreeSC_MRB_Identity_Type(struct SC_MRB_Identity_Type* p)
{
	_serSysFreeMBMSSessionInfo_r13(&p->MbmsSessionInfo);
}

static void _serSysFreeRadioBearerId_Type_Value(union RadioBearerId_Type_Value* p, enum RadioBearerId_Type_Sel d)
{
	if (d == RadioBearerId_Type_ScMrb) {
		_serSysFreeSC_MRB_Identity_Type(&p->ScMrb);
	}
}

static void _serSysFreeRadioBearerId_Type(struct RadioBearerId_Type* p)
{
	_serSysFreeRadioBearerId_Type_Value(&p->v, p->d);
}

static void _serSysFreeRoutingInfo_Type_Value(union RoutingInfo_Type_Value* p, enum RoutingInfo_Type_Sel d)
{
	if (d == RoutingInfo_Type_RadioBearerId) {
		_serSysFreeRadioBearerId_Type(&p->RadioBearerId);
	}
}

static void _serSysFreeRoutingInfo_Type(struct RoutingInfo_Type* p)
{
	_serSysFreeRoutingInfo_Type_Value(&p->v, p->d);
}

static void _serSysFreeReqAspCommonPart_Type(struct ReqAspCommonPart_Type* p)
{
	_serSysFreeRoutingInfo_Type(&p->RoutingInfo);
}

static void _serSysFreeDownlinkAntennaGroupConfig_Type(struct DownlinkAntennaGroupConfig_Type* p)
{
	if (p->AntennaPort.v) {
		for (size_t i1 = 0; i1 < p->AntennaPort.d; i1++) {
		}
		serFree(p->AntennaPort.v);
	}
}

static void _serSysFreeDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(struct DownlinkAntennaGroupConfig_Type_AntennaGroup_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDownlinkAntennaGroupConfig_Type(&p->v);
}

static void _serSysFreePdcchCandidate_Type(struct PdcchCandidate_Type* p)
{
	if (p->CCE_StartIndexList.v) {
		for (size_t i2 = 0; i2 < p->CCE_StartIndexList.d; i2++) {
		}
		serFree(p->CCE_StartIndexList.v);
	}
}

static void _serSysFreePdcchCandidateList_Type_PdcchCandidateList_Optional(struct PdcchCandidateList_Type_PdcchCandidateList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreePdcchCandidate_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePdcchConfig_Type(struct PdcchConfig_Type* p)
{
	_serSysFreePdcchCandidateList_Type_PdcchCandidateList_Optional(&p->PdcchCandidateList);
}

static void _serSysFreePdcchConfig_Type_Pdcch_Optional(struct PdcchConfig_Type_Pdcch_Optional* p)
{
	if (!p->d) return;
	_serSysFreePdcchConfig_Type(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup* p)
{
	if (p->subframeConfigList.v) {
		for (size_t i2 = 0; i2 < p->subframeConfigList.d; i2++) {
		}
		serFree(p->subframeConfigList.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(union CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value* p, enum CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Sel d)
{
	if (d == CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup) {
		_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11* p)
{
	_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11* p)
{
	_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_mbsfn_SubframeConfigList_r11_mbsfn_SubframeConfigList_r11_Optional(&p->mbsfn_SubframeConfigList_r11);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(struct CSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup* p)
{
	if (p->subframeConfigList_v1430.v) {
		for (size_t i2 = 0; i2 < p->subframeConfigList_v1430.d; i2++) {
		}
		serFree(p->subframeConfigList_v1430.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(union CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value* p, enum CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Sel d)
{
	if (d == CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup) {
		_serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430* p)
{
	_serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(struct CSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11(struct CSI_RS_ConfigNZP_r11* p)
{
	_serSysFreeCSI_RS_ConfigNZP_r11_qcl_CRS_Info_r11_qcl_CRS_Info_r11_Optional(&p->qcl_CRS_Info_r11);
	_serSysFreeCSI_RS_ConfigNZP_r11_mbsfn_SubframeConfigList_v1430_mbsfn_SubframeConfigList_v1430_Optional(&p->mbsfn_SubframeConfigList_v1430);
}

static void _serSysFreeCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(struct CSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeCSI_RS_ConfigNZP_r11(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(struct CSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(struct CSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(struct CSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_Config_Type(struct CSI_RS_Config_Type* p)
{
	_serSysFreeCSI_RS_ConfigNZPToAddModList_r11_CSI_RS_ConfigNZPToAddModList_Optional(&p->CSI_RS_ConfigNZPToAddModList);
	_serSysFreeCSI_RS_ConfigNZPToReleaseList_r11_CSI_RS_ConfigNZPToReleaseModList_Optional(&p->CSI_RS_ConfigNZPToReleaseModList);
	_serSysFreeCSI_RS_ConfigZPToAddModList_r11_CSI_RS_ConfigZPToAddModList_Optional(&p->CSI_RS_ConfigZPToAddModList);
	_serSysFreeCSI_RS_ConfigZPToReleaseList_r11_CSI_RS_ConfigZPToReleaseModList_Optional(&p->CSI_RS_ConfigZPToReleaseModList);
}

static void _serSysFreeCSI_RS_Config_Type_CSI_RS_Config_Optional(struct CSI_RS_Config_Type_CSI_RS_Config_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_Config_Type(&p->v);
}

static void _serSysFreePdcchCandidateList_Type_ePdcchCandidateList_Optional(struct PdcchCandidateList_Type_ePdcchCandidateList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreePdcchCandidate_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(struct EPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(struct EPDCCH_SetConfig_r11_resourceBlockAssignment_r11* p)
{
	if (p->resourceBlockAssignment_r11.v) {
		serFree(p->resourceBlockAssignment_r11.v);
	}
}

static void _serSysFreeEPDCCH_SetConfig_r11(struct EPDCCH_SetConfig_r11* p)
{
	_serSysFreeEPDCCH_SetConfig_r11_resourceBlockAssignment_r11(&p->resourceBlockAssignment_r11);
}

static void _serSysFreeEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(struct EPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeEPDCCH_SetConfig_r11(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeEPDCCH_Config_r11_config_r11_setup(struct EPDCCH_Config_r11_config_r11_setup* p)
{
	_serSysFreeEPDCCH_SetConfigToReleaseList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToReleaseList_r11_Optional(&p->setConfigToReleaseList_r11);
	_serSysFreeEPDCCH_SetConfigToAddModList_r11_EPDCCH_Config_r11_config_r11_setup_setConfigToAddModList_r11_Optional(&p->setConfigToAddModList_r11);
}

static void _serSysFreeEPDCCH_Config_r11_config_r11_Value(union EPDCCH_Config_r11_config_r11_Value* p, enum EPDCCH_Config_r11_config_r11_Sel d)
{
	if (d == EPDCCH_Config_r11_config_r11_setup) {
		_serSysFreeEPDCCH_Config_r11_config_r11_setup(&p->setup);
	}
}

static void _serSysFreeEPDCCH_Config_r11_config_r11(struct EPDCCH_Config_r11_config_r11* p)
{
	_serSysFreeEPDCCH_Config_r11_config_r11_Value(&p->v, p->d);
}

static void _serSysFreeEPDCCH_Config_r11(struct EPDCCH_Config_r11* p)
{
	_serSysFreeEPDCCH_Config_r11_config_r11(&p->config_r11);
}

static void _serSysFreeEPDCCH_Config_r11_EPDCCH_Config_Optional(struct EPDCCH_Config_r11_EPDCCH_Config_Optional* p)
{
	if (!p->d) return;
	_serSysFreeEPDCCH_Config_r11(&p->v);
}

static void _serSysFreeEpdcchConfig_Type(struct EpdcchConfig_Type* p)
{
	_serSysFreePdcchCandidateList_Type_ePdcchCandidateList_Optional(&p->ePdcchCandidateList);
	_serSysFreeEPDCCH_Config_r11_EPDCCH_Config_Optional(&p->EPDCCH_Config);
}

static void _serSysFreeEpdcchConfig_Type_Epdcch_Optional(struct EpdcchConfig_Type_Epdcch_Optional* p)
{
	if (!p->d) return;
	_serSysFreeEpdcchConfig_Type(&p->v);
}

static void _serSysFreePhysicalLayerConfigDL_Type(struct PhysicalLayerConfigDL_Type* p)
{
	_serSysFreeDownlinkAntennaGroupConfig_Type_AntennaGroup_Optional(&p->AntennaGroup);
	_serSysFreePdcchConfig_Type_Pdcch_Optional(&p->Pdcch);
	_serSysFreeCSI_RS_Config_Type_CSI_RS_Config_Optional(&p->CSI_RS_Config);
	_serSysFreeEpdcchConfig_Type_Epdcch_Optional(&p->Epdcch);
}

static void _serSysFreePhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(struct PhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional* p)
{
	if (!p->d) return;
	_serSysFreePhysicalLayerConfigDL_Type(&p->v);
}

static void _serSysFreeDciDlInfoCommon_Type(struct DciDlInfoCommon_Type* p)
{
	if (p->RedundancyVersionList.v) {
		serFree(p->RedundancyVersionList.v);
	}
}

static void _serSysFreeDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(struct DciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDciDlInfoCommon_Type(&p->v);
}

static void _serSysFreeSib1Schedul_Type(struct Sib1Schedul_Type* p)
{
	_serSysFreeDciDlInfoCommon_Type_Sib1Schedul_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serSysFreeSib1Schedul_Type_Sib1Schedul_Optional(struct Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSib1Schedul_Type(&p->v);
}

static void _serSysFreeDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(struct DciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDciDlInfoCommon_Type(&p->v);
}

static void _serSysFreeSingleSiSchedul_Type(struct SingleSiSchedul_Type* p)
{
	_serSysFreeDciDlInfoCommon_Type_SingleSiSchedul_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serSysFreeSingleSiSchedul_Type_Window_DynamicOptional(struct SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSingleSiSchedul_Type(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSiSchedul_Type(struct SiSchedul_Type* p)
{
	_serSysFreeSingleSiSchedul_Type_Window_DynamicOptional(&p->Window);
}

static void _serSysFreeSiSchedulList_Type_SiList_Optional(struct SiSchedulList_Type_SiList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeSiSchedul_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSiSchedulList_Type_SegmentedSiList_Optional(struct SiSchedulList_Type_SegmentedSiList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeSiSchedul_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeAllSiSchedul_Type(struct AllSiSchedul_Type* p)
{
	_serSysFreeSiSchedulList_Type_SiList_Optional(&p->SiList);
	_serSysFreeSiSchedulList_Type_SegmentedSiList_Optional(&p->SegmentedSiList);
}

static void _serSysFreeAllSiSchedul_Type_SiSchedul_Optional(struct AllSiSchedul_Type_SiSchedul_Optional* p)
{
	if (!p->d) return;
	_serSysFreeAllSiSchedul_Type(&p->v);
}

static void _serSysFreeBcchToPdschConfig_Type(struct BcchToPdschConfig_Type* p)
{
	_serSysFreeSib1Schedul_Type_Sib1Schedul_Optional(&p->Sib1Schedul);
	_serSysFreeAllSiSchedul_Type_SiSchedul_Optional(&p->SiSchedul);
}

static void _serSysFreeBcchToPdschConfig_Type_Pdsch_Optional(struct BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcchToPdschConfig_Type(&p->v);
}

static void _serSysFreeRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(struct RACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeRACH_ConfigCommon(struct RACH_ConfigCommon* p)
{
	_serSysFreeRACH_CE_LevelInfoList_r13_RACH_ConfigCommon_rach_CE_LevelInfoList_r13_Optional(&p->rach_CE_LevelInfoList_r13);
}

static void _serSysFreePRACH_ParametersCE_r13(struct PRACH_ParametersCE_r13* p)
{
	if (p->mpdcch_NarrowbandsToMonitor_r13.v) {
		serFree(p->mpdcch_NarrowbandsToMonitor_r13.v);
	}
}

static void _serSysFreePRACH_ConfigSIB_v1310(struct PRACH_ConfigSIB_v1310* p)
{
	if (p->rsrp_ThresholdsPrachInfoList_r13.v) {
		serFree(p->rsrp_ThresholdsPrachInfoList_r13.v);
	}
	if (p->prach_ParametersListCE_r13.v) {
		for (size_t i2 = 0; i2 < p->prach_ParametersListCE_r13.d; i2++) {
			_serSysFreePRACH_ParametersCE_r13(&p->prach_ParametersListCE_r13.v[i2]);
		}
		serFree(p->prach_ParametersListCE_r13.v);
	}
}

static void _serSysFreePRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(struct PRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional* p)
{
	if (!p->d) return;
	_serSysFreePRACH_ConfigSIB_v1310(&p->v);
}

static void _serSysFreeN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(struct N1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePUCCH_ConfigCommon_v1310(struct PUCCH_ConfigCommon_v1310* p)
{
	_serSysFreeN1PUCCH_AN_InfoList_r13_PUCCH_ConfigCommon_v1310_n1PUCCH_AN_InfoList_r13_Optional(&p->n1PUCCH_AN_InfoList_r13);
}

static void _serSysFreePUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(struct PUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigCommon_v1310(&p->v);
}

static void _serSysFreeEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15* p)
{
	if (p->mpdcch_NarrowbandsToMonitor_r15.v) {
		serFree(p->mpdcch_NarrowbandsToMonitor_r15.v);
	}
}

static void _serSysFreeEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(struct EDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15(&p->v);
}

static void _serSysFreeEDT_PRACH_ParametersCE_r15(struct EDT_PRACH_ParametersCE_r15* p)
{
	_serSysFreeEDT_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_edt_PRACH_ParametersCE_r15_Optional(&p->edt_PRACH_ParametersCE_r15);
}

static void _serSysFreePRACH_ConfigSIB_v1530(struct PRACH_ConfigSIB_v1530* p)
{
	if (p->edt_PRACH_ParametersListCE_r15.v) {
		for (size_t i2 = 0; i2 < p->edt_PRACH_ParametersListCE_r15.d; i2++) {
			_serSysFreeEDT_PRACH_ParametersCE_r15(&p->edt_PRACH_ParametersListCE_r15.v[i2]);
		}
		serFree(p->edt_PRACH_ParametersListCE_r15.v);
	}
}

static void _serSysFreePRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(struct PRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional* p)
{
	if (!p->d) return;
	_serSysFreePRACH_ConfigSIB_v1530(&p->v);
}

static void _serSysFreeGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(struct GWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(struct GWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeGWUS_ResourceConfig_r16(struct GWUS_ResourceConfig_r16* p)
{
	_serSysFreeGWUS_NumGroupsList_r16_GWUS_ResourceConfig_r16_numGroupsList_r16_Optional(&p->numGroupsList_r16);
	_serSysFreeGWUS_GroupsForServiceList_r16_GWUS_ResourceConfig_r16_groupsForServiceList_r16_Optional(&p->groupsForServiceList_r16);
}

static void _serSysFreeGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeGWUS_ResourceConfig_r16(&p->v);
}

static void _serSysFreeGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(struct GWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeGWUS_ResourceConfig_r16(&p->v);
}

static void _serSysFreeGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(struct GWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(struct GWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeGWUS_Config_r16(struct GWUS_Config_r16* p)
{
	_serSysFreeGWUS_ResourceConfig_r16(&p->resourceConfigDRX_r16);
	_serSysFreeGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Short_r16_Optional(&p->resourceConfig_eDRX_Short_r16);
	_serSysFreeGWUS_ResourceConfig_r16_GWUS_Config_r16_resourceConfig_eDRX_Long_r16_Optional(&p->resourceConfig_eDRX_Long_r16);
	_serSysFreeGWUS_ProbThreshList_r16_GWUS_Config_r16_probThreshList_r16_Optional(&p->probThreshList_r16);
	_serSysFreeGWUS_GroupNarrowBandList_r16_GWUS_Config_r16_groupNarrowBandList_r16_Optional(&p->groupNarrowBandList_r16);
}

static void _serSysFreeGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(struct GWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeGWUS_Config_r16(&p->v);
}

static void _serSysFreeRadioResourceConfigCommonSIB(struct RadioResourceConfigCommonSIB* p)
{
	_serSysFreeRACH_ConfigCommon(&p->rach_ConfigCommon);
	_serSysFreePRACH_ConfigSIB_v1310_RadioResourceConfigCommonSIB_prach_ConfigCommon_v1310_Optional(&p->prach_ConfigCommon_v1310);
	_serSysFreePUCCH_ConfigCommon_v1310_RadioResourceConfigCommonSIB_pucch_ConfigCommon_v1310_Optional(&p->pucch_ConfigCommon_v1310);
	_serSysFreePRACH_ConfigSIB_v1530_RadioResourceConfigCommonSIB_prach_Config_v1530_Optional(&p->prach_Config_v1530);
	_serSysFreeGWUS_Config_r16_RadioResourceConfigCommonSIB_gwus_Config_r16_Optional(&p->gwus_Config_r16);
}

static void _serSysFreeMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(struct MBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(struct AC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeACDC_BarringForCommon_r13(struct ACDC_BarringForCommon_r13* p)
{
	if (p->barringPerACDC_CategoryList_r13.v) {
		for (size_t i2 = 0; i2 < p->barringPerACDC_CategoryList_r13.d; i2++) {
		}
		serFree(p->barringPerACDC_CategoryList_r13.v);
	}
}

static void _serSysFreeACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(struct ACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeACDC_BarringForCommon_r13(&p->v);
}

static void _serSysFreeACDC_BarringPerPLMN_r13(struct ACDC_BarringPerPLMN_r13* p)
{
	if (p->barringPerACDC_CategoryList_r13.v) {
		for (size_t i3 = 0; i3 < p->barringPerACDC_CategoryList_r13.d; i3++) {
		}
		serFree(p->barringPerACDC_CategoryList_r13.v);
	}
}

static void _serSysFreeACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(struct ACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeACDC_BarringPerPLMN_r13(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(struct UDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(struct CIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(struct MBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(struct PLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType2(struct SystemInformationBlockType2* p)
{
	_serSysFreeRadioResourceConfigCommonSIB(&p->radioResourceConfigCommon);
	_serSysFreeMBSFN_SubframeConfigList_SystemInformationBlockType2_mbsfn_SubframeConfigList_Optional(&p->mbsfn_SubframeConfigList);
	_serSysFreeOCTET_STRING_SystemInformationBlockType2_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeAC_BarringPerPLMN_List_r12_SystemInformationBlockType2_ac_BarringPerPLMN_List_r12_Optional(&p->ac_BarringPerPLMN_List_r12);
	_serSysFreeACDC_BarringForCommon_r13_SystemInformationBlockType2_acdc_BarringForCommon_r13_Optional(&p->acdc_BarringForCommon_r13);
	_serSysFreeACDC_BarringPerPLMN_List_r13_SystemInformationBlockType2_acdc_BarringPerPLMN_List_r13_Optional(&p->acdc_BarringPerPLMN_List_r13);
	_serSysFreeUDT_RestrictingPerPLMN_List_r13_SystemInformationBlockType2_udt_RestrictingPerPLMN_List_r13_Optional(&p->udt_RestrictingPerPLMN_List_r13);
	_serSysFreeCIOT_EPS_OptimisationInfo_r13_SystemInformationBlockType2_cIoT_EPS_OptimisationInfo_r13_Optional(&p->cIoT_EPS_OptimisationInfo_r13);
	_serSysFreeMBSFN_SubframeConfigList_v1430_SystemInformationBlockType2_mbsfn_SubframeConfigList_v1430_Optional(&p->mbsfn_SubframeConfigList_v1430);
	_serSysFreePLMN_InfoList_r15_SystemInformationBlockType2_plmn_InfoList_r15_Optional(&p->plmn_InfoList_r15);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType3(struct SystemInformationBlockType3* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType3_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(struct IntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(struct IntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(struct IntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeRSS_ConfigCarrierInfo_r16(struct RSS_ConfigCarrierInfo_r16* p)
{
	if (p->narrowbandIndex_r16.v) {
		serFree(p->narrowbandIndex_r16.v);
	}
}

static void _serSysFreeRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(struct RSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeRSS_ConfigCarrierInfo_r16(&p->v);
}

static void _serSysFreeIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(struct IntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType4(struct SystemInformationBlockType4* p)
{
	_serSysFreeIntraFreqNeighCellList_SystemInformationBlockType4_intraFreqNeighCellList_Optional(&p->intraFreqNeighCellList);
	_serSysFreeIntraFreqBlackCellList_SystemInformationBlockType4_intraFreqBlackCellList_Optional(&p->intraFreqBlackCellList);
	_serSysFreeOCTET_STRING_SystemInformationBlockType4_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeIntraFreqNeighHSDN_CellList_r15_SystemInformationBlockType4_intraFreqNeighHSDN_CellList_r15_Optional(&p->intraFreqNeighHSDN_CellList_r15);
	_serSysFreeRSS_ConfigCarrierInfo_r16_SystemInformationBlockType4_rss_ConfigCarrierInfo_r16_Optional(&p->rss_ConfigCarrierInfo_r16);
	_serSysFreeIntraFreqNeighCellList_v1610_SystemInformationBlockType4_intraFreqNeighCellList_v1610_Optional(&p->intraFreqNeighCellList_v1610);
}

static void _serSysFreeInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqInfo(struct InterFreqCarrierFreqInfo* p)
{
	_serSysFreeInterFreqNeighCellList_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(&p->interFreqNeighCellList);
	_serSysFreeInterFreqBlackCellList_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(&p->interFreqBlackCellList);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(struct InterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(struct InterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(struct InterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(struct MultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqInfo_r12(struct InterFreqCarrierFreqInfo_r12* p)
{
	_serSysFreeInterFreqNeighCellList_InterFreqCarrierFreqInfo_r12_interFreqNeighCellList_r12_Optional(&p->interFreqNeighCellList_r12);
	_serSysFreeInterFreqBlackCellList_InterFreqCarrierFreqInfo_r12_interFreqBlackCellList_r12_Optional(&p->interFreqBlackCellList_r12);
	_serSysFreeMultiBandInfoList_r11_InterFreqCarrierFreqInfo_r12_multiBandInfoList_r12_Optional(&p->multiBandInfoList_r12);
}

static void _serSysFreeInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(struct InterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(struct NS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(struct MultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			if (p->v.v[i3].v) {
				for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
				}
				serFree(p->v.v[i3].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqInfo_v10j0(struct InterFreqCarrierFreqInfo_v10j0* p)
{
	_serSysFreeNS_PmaxList_r10_InterFreqCarrierFreqInfo_v10j0_freqBandInfo_r10_Optional(&p->freqBandInfo_r10);
	_serSysFreeMultiBandInfoList_v10j0_InterFreqCarrierFreqInfo_v10j0_multiBandInfoList_v10j0_Optional(&p->multiBandInfoList_v10j0);
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(struct InterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v10j0(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(struct RedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeRedistributionInterFreqInfo_r13(struct RedistributionInterFreqInfo_r13* p)
{
	_serSysFreeRedistributionNeighCellList_r13_RedistributionInterFreqInfo_r13_redistributionNeighCellList_r13_Optional(&p->redistributionNeighCellList_r13);
}

static void _serSysFreeRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(struct RedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeRedistributionInterFreqInfo_r13(&p->v);
}

static void _serSysFreeInterFreqCarrierFreqInfo_v1310(struct InterFreqCarrierFreqInfo_v1310* p)
{
	_serSysFreeRedistributionInterFreqInfo_r13_InterFreqCarrierFreqInfo_v1310_redistributionInterFreqInfo_r13_Optional(&p->redistributionInterFreqInfo_r13);
}

static void _serSysFreeInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(struct InterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1310(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(struct InterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1310(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(struct InterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(struct InterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(struct InterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(struct InterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqInfo_v1530(struct InterFreqCarrierFreqInfo_v1530* p)
{
	_serSysFreeInterFreqNeighHSDN_CellList_r15_InterFreqCarrierFreqInfo_v1530_interFreqNeighHSDN_CellList_r15_Optional(&p->interFreqNeighHSDN_CellList_r15);
}

static void _serSysFreeInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(struct InterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1530(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(struct InterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1530(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(struct CellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(struct CellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMeasIdleCarrierEUTRA_r15(struct MeasIdleCarrierEUTRA_r15* p)
{
	_serSysFreeCellList_r15_MeasIdleCarrierEUTRA_r15_validityArea_r15_Optional(&p->validityArea_r15);
	_serSysFreeCellList_r15_MeasIdleCarrierEUTRA_r15_measCellList_r15_Optional(&p->measCellList_r15);
}

static void _serSysFreeMeasIdleConfigSIB_r15(struct MeasIdleConfigSIB_r15* p)
{
	if (p->measIdleCarrierListEUTRA_r15.v) {
		for (size_t i2 = 0; i2 < p->measIdleCarrierListEUTRA_r15.d; i2++) {
			_serSysFreeMeasIdleCarrierEUTRA_r15(&p->measIdleCarrierListEUTRA_r15.v[i2]);
		}
		serFree(p->measIdleCarrierListEUTRA_r15.v);
	}
}

static void _serSysFreeMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(struct MeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeMeasIdleConfigSIB_r15(&p->v);
}

static void _serSysFreeRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(struct RSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeRSS_ConfigCarrierInfo_r16(&p->v);
}

static void _serSysFreeInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(struct InterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqInfo_v1610(struct InterFreqCarrierFreqInfo_v1610* p)
{
	_serSysFreeRSS_ConfigCarrierInfo_r16_InterFreqCarrierFreqInfo_v1610_rss_ConfigCarrierInfo_r16_Optional(&p->rss_ConfigCarrierInfo_r16);
	_serSysFreeInterFreqNeighCellList_v1610_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(&p->interFreqNeighCellList_v1610);
}

static void _serSysFreeInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(struct InterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1610(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(struct InterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo_v1610(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(struct MultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(struct CellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSS_RSSI_Measurement_r15(struct SS_RSSI_Measurement_r15* p)
{
	if (p->measurementSlots_r15.v) {
		serFree(p->measurementSlots_r15.v);
	}
}

static void _serSysFreeSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(struct SS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSS_RSSI_Measurement_r15(&p->v);
}

static void _serSysFreeMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	_serSysFreeSS_RSSI_Measurement_r15_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(&p->ss_RSSI_Measurement_r16);
}

static void _serSysFreeMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(struct MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeMeasIdleCarrierNR_r16_ssb_MeasConfig_r16(&p->v);
}

static void _serSysFreeMeasIdleCarrierNR_r16(struct MeasIdleCarrierNR_r16* p)
{
	_serSysFreeMultiFrequencyBandListNR_r15_MeasIdleCarrierNR_r16_frequencyBandList_Optional(&p->frequencyBandList);
	_serSysFreeCellListNR_r16_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(&p->measCellListNR_r16);
	_serSysFreeMeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(&p->ssb_MeasConfig_r16);
}

static void _serSysFreeMeasIdleConfigSIB_NR_r16(struct MeasIdleConfigSIB_NR_r16* p)
{
	if (p->measIdleCarrierListNR_r16.v) {
		for (size_t i2 = 0; i2 < p->measIdleCarrierListNR_r16.d; i2++) {
			_serSysFreeMeasIdleCarrierNR_r16(&p->measIdleCarrierListNR_r16.v[i2]);
		}
		serFree(p->measIdleCarrierListNR_r16.v);
	}
}

static void _serSysFreeMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(struct MeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeMeasIdleConfigSIB_NR_r16(&p->v);
}

static void _serSysFreeSystemInformationBlockType5(struct SystemInformationBlockType5* p)
{
	if (p->interFreqCarrierFreqList.v) {
		for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
			_serSysFreeInterFreqCarrierFreqInfo(&p->interFreqCarrierFreqList.v[i2]);
		}
		serFree(p->interFreqCarrierFreqList.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType5_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeInterFreqCarrierFreqList_v1250_SystemInformationBlockType5_interFreqCarrierFreqList_v1250_Optional(&p->interFreqCarrierFreqList_v1250);
	_serSysFreeInterFreqCarrierFreqListExt_r12_SystemInformationBlockType5_interFreqCarrierFreqListExt_r12_Optional(&p->interFreqCarrierFreqListExt_r12);
	_serSysFreeInterFreqCarrierFreqListExt_v1280_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1280_Optional(&p->interFreqCarrierFreqListExt_v1280);
	_serSysFreeInterFreqCarrierFreqList_v1310_SystemInformationBlockType5_interFreqCarrierFreqList_v1310_Optional(&p->interFreqCarrierFreqList_v1310);
	_serSysFreeInterFreqCarrierFreqListExt_v1310_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1310_Optional(&p->interFreqCarrierFreqListExt_v1310);
	_serSysFreeInterFreqCarrierFreqList_v1350_SystemInformationBlockType5_interFreqCarrierFreqList_v1350_Optional(&p->interFreqCarrierFreqList_v1350);
	_serSysFreeInterFreqCarrierFreqListExt_v1350_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1350_Optional(&p->interFreqCarrierFreqListExt_v1350);
	_serSysFreeInterFreqCarrierFreqListExt_v1360_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1360_Optional(&p->interFreqCarrierFreqListExt_v1360);
	_serSysFreeInterFreqCarrierFreqList_v1530_SystemInformationBlockType5_interFreqCarrierFreqList_v1530_Optional(&p->interFreqCarrierFreqList_v1530);
	_serSysFreeInterFreqCarrierFreqListExt_v1530_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1530_Optional(&p->interFreqCarrierFreqListExt_v1530);
	_serSysFreeMeasIdleConfigSIB_r15_SystemInformationBlockType5_measIdleConfigSIB_r15_Optional(&p->measIdleConfigSIB_r15);
	_serSysFreeInterFreqCarrierFreqList_v1610_SystemInformationBlockType5_interFreqCarrierFreqList_v1610_Optional(&p->interFreqCarrierFreqList_v1610);
	_serSysFreeInterFreqCarrierFreqListExt_v1610_SystemInformationBlockType5_interFreqCarrierFreqListExt_v1610_Optional(&p->interFreqCarrierFreqListExt_v1610);
	_serSysFreeMeasIdleConfigSIB_NR_r16_SystemInformationBlockType5_measIdleConfigSIB_NR_r16_Optional(&p->measIdleConfigSIB_NR_r16);
}

static void _serSysFreeCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(struct CarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(struct CarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(struct CarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(struct FreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqUTRA_FDD_Ext_r12(struct CarrierFreqUTRA_FDD_Ext_r12* p)
{
	_serSysFreeFreqBandIndicator_UTRA_FDD_CarrierFreqUTRA_FDD_Ext_r12_multiBandInfoList_r12_DynamicOptional(&p->multiBandInfoList_r12);
}

static void _serSysFreeCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(struct CarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCarrierFreqUTRA_FDD_Ext_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(struct CarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType6(struct SystemInformationBlockType6* p)
{
	_serSysFreeCarrierFreqListUTRA_FDD_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Optional(&p->carrierFreqListUTRA_FDD);
	_serSysFreeCarrierFreqListUTRA_TDD_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Optional(&p->carrierFreqListUTRA_TDD);
	_serSysFreeOCTET_STRING_SystemInformationBlockType6_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_FDD_v1250_DynamicOptional(&p->carrierFreqListUTRA_FDD_v1250);
	_serSysFreeCarrierFreqInfoUTRA_v1250_SystemInformationBlockType6_carrierFreqListUTRA_TDD_v1250_DynamicOptional(&p->carrierFreqListUTRA_TDD_v1250);
	_serSysFreeCarrierFreqListUTRA_FDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_FDD_Ext_r12_Optional(&p->carrierFreqListUTRA_FDD_Ext_r12);
	_serSysFreeCarrierFreqListUTRA_TDD_Ext_r12_SystemInformationBlockType6_carrierFreqListUTRA_TDD_Ext_r12_Optional(&p->carrierFreqListUTRA_TDD_Ext_r12);
}

static void _serSysFreeCarrierFreqsGERAN_followingARFCNs_Value(union CarrierFreqsGERAN_followingARFCNs_Value* p, enum CarrierFreqsGERAN_followingARFCNs_Sel d)
{
	if (d == CarrierFreqsGERAN_followingARFCNs_explicitListOfARFCNs) {
		if (p->explicitListOfARFCNs.v) {
			serFree(p->explicitListOfARFCNs.v);
		}
	}
	if (d == CarrierFreqsGERAN_followingARFCNs_variableBitMapOfARFCNs) {
		if (p->variableBitMapOfARFCNs.v) {
			serFree(p->variableBitMapOfARFCNs.v);
		}
	}
}

static void _serSysFreeCarrierFreqsGERAN_followingARFCNs(struct CarrierFreqsGERAN_followingARFCNs* p)
{
	_serSysFreeCarrierFreqsGERAN_followingARFCNs_Value(&p->v, p->d);
}

static void _serSysFreeCarrierFreqsGERAN(struct CarrierFreqsGERAN* p)
{
	_serSysFreeCarrierFreqsGERAN_followingARFCNs(&p->followingARFCNs);
}

static void _serSysFreeCarrierFreqsInfoGERAN(struct CarrierFreqsInfoGERAN* p)
{
	_serSysFreeCarrierFreqsGERAN(&p->carrierFreqs);
}

static void _serSysFreeCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(struct CarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCarrierFreqsInfoGERAN(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType7(struct SystemInformationBlockType7* p)
{
	_serSysFreeCarrierFreqsInfoListGERAN_SystemInformationBlockType7_carrierFreqsInfoList_Optional(&p->carrierFreqsInfoList);
	_serSysFreeOCTET_STRING_SystemInformationBlockType7_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(struct SecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePreRegistrationInfoHRPD(struct PreRegistrationInfoHRPD* p)
{
	_serSysFreeSecondaryPreRegistrationZoneIdListHRPD_PreRegistrationInfoHRPD_secondaryPreRegistrationZoneIdList_Optional(&p->secondaryPreRegistrationZoneIdList);
}

static void _serSysFreeNeighCellsPerBandclassCDMA2000(struct NeighCellsPerBandclassCDMA2000* p)
{
	if (p->physCellIdList.v) {
		serFree(p->physCellIdList.v);
	}
}

static void _serSysFreeNeighCellCDMA2000(struct NeighCellCDMA2000* p)
{
	if (p->neighCellsPerFreqList.v) {
		for (size_t i3 = 0; i3 < p->neighCellsPerFreqList.d; i3++) {
			_serSysFreeNeighCellsPerBandclassCDMA2000(&p->neighCellsPerFreqList.v[i3]);
		}
		serFree(p->neighCellsPerFreqList.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000(struct CellReselectionParametersCDMA2000* p)
{
	if (p->bandClassList.v) {
		for (size_t i2 = 0; i2 < p->bandClassList.d; i2++) {
		}
		serFree(p->bandClassList.v);
	}
	if (p->neighCellList.v) {
		for (size_t i2 = 0; i2 < p->neighCellList.d; i2++) {
			_serSysFreeNeighCellCDMA2000(&p->neighCellList.v[i2]);
		}
		serFree(p->neighCellList.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000(&p->v);
}

static void _serSysFreeSystemInformationBlockType8_parametersHRPD(struct SystemInformationBlockType8_parametersHRPD* p)
{
	_serSysFreePreRegistrationInfoHRPD(&p->preRegistrationInfoHRPD);
	_serSysFreeCellReselectionParametersCDMA2000_SystemInformationBlockType8_parametersHRPD_cellReselectionParametersHRPD_Optional(&p->cellReselectionParametersHRPD);
}

static void _serSysFreeSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(struct SystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType8_parametersHRPD(&p->v);
}

static void _serSysFreeCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(struct CellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000(&p->v);
}

static void _serSysFreeSystemInformationBlockType8_parameters1XRTT(struct SystemInformationBlockType8_parameters1XRTT* p)
{
	_serSysFreeCellReselectionParametersCDMA2000_SystemInformationBlockType8_parameters1XRTT_cellReselectionParameters1XRTT_Optional(&p->cellReselectionParameters1XRTT);
}

static void _serSysFreeSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(struct SystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType8_parameters1XRTT(&p->v);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeNeighCellsPerBandclassCDMA2000_v920(struct NeighCellsPerBandclassCDMA2000_v920* p)
{
	if (p->physCellIdList_v920.v) {
		serFree(p->physCellIdList_v920.v);
	}
}

static void _serSysFreeNeighCellCDMA2000_v920(struct NeighCellCDMA2000_v920* p)
{
	if (p->neighCellsPerFreqList_v920.v) {
		for (size_t i3 = 0; i3 < p->neighCellsPerFreqList_v920.d; i3++) {
			_serSysFreeNeighCellsPerBandclassCDMA2000_v920(&p->neighCellsPerFreqList_v920.v[i3]);
		}
		serFree(p->neighCellsPerFreqList_v920.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000_v920(struct CellReselectionParametersCDMA2000_v920* p)
{
	if (p->neighCellList_v920.v) {
		for (size_t i2 = 0; i2 < p->neighCellList_v920.d; i2++) {
			_serSysFreeNeighCellCDMA2000_v920(&p->neighCellList_v920.v[i2]);
		}
		serFree(p->neighCellList_v920.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000_v920(&p->v);
}

static void _serSysFreeCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(struct CellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000_v920(&p->v);
}

static void _serSysFreeNeighCellsPerBandclassCDMA2000_r11(struct NeighCellsPerBandclassCDMA2000_r11* p)
{
	if (p->physCellIdList_r11.v) {
		serFree(p->physCellIdList_r11.v);
	}
}

static void _serSysFreeNeighCellCDMA2000_r11(struct NeighCellCDMA2000_r11* p)
{
	if (p->neighFreqInfoList_r11.v) {
		for (size_t i4 = 0; i4 < p->neighFreqInfoList_r11.d; i4++) {
			_serSysFreeNeighCellsPerBandclassCDMA2000_r11(&p->neighFreqInfoList_r11.v[i4]);
		}
		serFree(p->neighFreqInfoList_r11.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000_r11(struct CellReselectionParametersCDMA2000_r11* p)
{
	if (p->bandClassList.v) {
		for (size_t i3 = 0; i3 < p->bandClassList.d; i3++) {
		}
		serFree(p->bandClassList.v);
	}
	if (p->neighCellList_r11.v) {
		for (size_t i3 = 0; i3 < p->neighCellList_r11.d; i3++) {
			_serSysFreeNeighCellCDMA2000_r11(&p->neighCellList_r11.v[i3]);
		}
		serFree(p->neighCellList_r11.v);
	}
}

static void _serSysFreeCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000_r11(&p->v);
}

static void _serSysFreeParametersCDMA2000_r11_parametersHRPD_r11(struct ParametersCDMA2000_r11_parametersHRPD_r11* p)
{
	_serSysFreePreRegistrationInfoHRPD(&p->preRegistrationInfoHRPD_r11);
	_serSysFreeCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parametersHRPD_r11_cellReselectionParametersHRPD_r11_Optional(&p->cellReselectionParametersHRPD_r11);
}

static void _serSysFreeParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(struct ParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeParametersCDMA2000_r11_parametersHRPD_r11(&p->v);
}

static void _serSysFreeCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(struct CellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCellReselectionParametersCDMA2000_r11(&p->v);
}

static void _serSysFreeParametersCDMA2000_r11_parameters1XRTT_r11(struct ParametersCDMA2000_r11_parameters1XRTT_r11* p)
{
	_serSysFreeCellReselectionParametersCDMA2000_r11_ParametersCDMA2000_r11_parameters1XRTT_r11_cellReselectionParameters1XRTT_r11_Optional(&p->cellReselectionParameters1XRTT_r11);
}

static void _serSysFreeParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(struct ParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeParametersCDMA2000_r11_parameters1XRTT_r11(&p->v);
}

static void _serSysFreeParametersCDMA2000_r11(struct ParametersCDMA2000_r11* p)
{
	_serSysFreeParametersCDMA2000_r11_parametersHRPD_r11_parametersHRPD_r11_Optional(&p->parametersHRPD_r11);
	_serSysFreeParametersCDMA2000_r11_parameters1XRTT_r11_parameters1XRTT_r11_Optional(&p->parameters1XRTT_r11);
}

static void _serSysFreeSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(union SIB8_PerPLMN_r11_parametersCDMA2000_r11_Value* p, enum SIB8_PerPLMN_r11_parametersCDMA2000_r11_Sel d)
{
	if (d == SIB8_PerPLMN_r11_parametersCDMA2000_r11_explicitValue) {
		_serSysFreeParametersCDMA2000_r11(&p->explicitValue);
	}
}

static void _serSysFreeSIB8_PerPLMN_r11_parametersCDMA2000_r11(struct SIB8_PerPLMN_r11_parametersCDMA2000_r11* p)
{
	_serSysFreeSIB8_PerPLMN_r11_parametersCDMA2000_r11_Value(&p->v, p->d);
}

static void _serSysFreeSIB8_PerPLMN_r11(struct SIB8_PerPLMN_r11* p)
{
	_serSysFreeSIB8_PerPLMN_r11_parametersCDMA2000_r11(&p->parametersCDMA2000_r11);
}

static void _serSysFreeSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(struct SIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSIB8_PerPLMN_r11(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType8(struct SystemInformationBlockType8* p)
{
	_serSysFreeSystemInformationBlockType8_parametersHRPD_parametersHRPD_Optional(&p->parametersHRPD);
	_serSysFreeSystemInformationBlockType8_parameters1XRTT_parameters1XRTT_Optional(&p->parameters1XRTT);
	_serSysFreeOCTET_STRING_SystemInformationBlockType8_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParametersHRPD_v920_Optional(&p->cellReselectionParametersHRPD_v920);
	_serSysFreeCellReselectionParametersCDMA2000_v920_SystemInformationBlockType8_cellReselectionParameters1XRTT_v920_Optional(&p->cellReselectionParameters1XRTT_v920);
	_serSysFreeSIB8_PerPLMN_List_r11_SystemInformationBlockType8_sib8_PerPLMN_List_r11_Optional(&p->sib8_PerPLMN_List_r11);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(struct OCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType9(struct SystemInformationBlockType9* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType9_hnb_Name_Optional(&p->hnb_Name);
	_serSysFreeOCTET_STRING_SystemInformationBlockType9_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType10(struct SystemInformationBlockType10* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType10_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType11(struct SystemInformationBlockType11* p)
{
	if (p->warningMessageSegment.v) {
		serFree(p->warningMessageSegment.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType11_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(struct OCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType12_r9(struct SystemInformationBlockType12_r9* p)
{
	if (p->warningMessageSegment_r9.v) {
		serFree(p->warningMessageSegment_r9.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType12_r9_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeOCTET_STRING_SystemInformationBlockType12_r9_warningAreaCoordinatesSegment_r15_Optional(&p->warningAreaCoordinatesSegment_r15);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(struct MBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType13_r9(struct SystemInformationBlockType13_r9* p)
{
	if (p->mbsfn_AreaInfoList_r9.v) {
		for (size_t i2 = 0; i2 < p->mbsfn_AreaInfoList_r9.d; i2++) {
		}
		serFree(p->mbsfn_AreaInfoList_r9.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType13_r9_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeMBSFN_AreaInfoList_r16_SystemInformationBlockType13_r9_mbsfn_AreaInfoList_r16_Optional(&p->mbsfn_AreaInfoList_r16);
}

static void _serSysFreeSystemInformationBlockType14_r11_eab_Param_r11_Value(union SystemInformationBlockType14_r11_eab_Param_r11_Value* p, enum SystemInformationBlockType14_r11_eab_Param_r11_Sel d)
{
	if (d == SystemInformationBlockType14_r11_eab_Param_r11_eab_PerPLMN_List_r11) {
		if (p->eab_PerPLMN_List_r11.v) {
			for (size_t i2 = 0; i2 < p->eab_PerPLMN_List_r11.d; i2++) {
			}
			serFree(p->eab_PerPLMN_List_r11.v);
		}
	}
}

static void _serSysFreeSystemInformationBlockType14_r11_eab_Param_r11(struct SystemInformationBlockType14_r11_eab_Param_r11* p)
{
	_serSysFreeSystemInformationBlockType14_r11_eab_Param_r11_Value(&p->v, p->d);
}

static void _serSysFreeSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(struct SystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType14_r11_eab_Param_r11(&p->v);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType14_r11(struct SystemInformationBlockType14_r11* p)
{
	_serSysFreeSystemInformationBlockType14_r11_eab_Param_r11_eab_Param_r11_Optional(&p->eab_Param_r11);
	_serSysFreeOCTET_STRING_SystemInformationBlockType14_r11_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(struct MBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMBMS_SAI_InterFreq_r11(struct MBMS_SAI_InterFreq_r11* p)
{
	if (p->mbms_SAI_List_r11.v) {
		serFree(p->mbms_SAI_List_r11.v);
	}
}

static void _serSysFreeMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(struct MBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeMBMS_SAI_InterFreq_r11(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(struct MultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMBMS_SAI_InterFreq_v1140(struct MBMS_SAI_InterFreq_v1140* p)
{
	_serSysFreeMultiBandInfoList_r11_MBMS_SAI_InterFreq_v1140_multiBandInfoList_r11_Optional(&p->multiBandInfoList_r11);
}

static void _serSysFreeMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(struct MBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeMBMS_SAI_InterFreq_v1140(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(struct MBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType15_r11(struct SystemInformationBlockType15_r11* p)
{
	_serSysFreeMBMS_SAI_List_r11_SystemInformationBlockType15_r11_mbms_SAI_IntraFreq_r11_Optional(&p->mbms_SAI_IntraFreq_r11);
	_serSysFreeMBMS_SAI_InterFreqList_r11_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_r11_Optional(&p->mbms_SAI_InterFreqList_r11);
	_serSysFreeOCTET_STRING_SystemInformationBlockType15_r11_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeMBMS_SAI_InterFreqList_v1140_SystemInformationBlockType15_r11_mbms_SAI_InterFreqList_v1140_Optional(&p->mbms_SAI_InterFreqList_v1140);
	_serSysFreeMBMS_InterFreqCarrierTypeList_r14_SystemInformationBlockType15_r11_mbms_InterFreqCarrierTypeList_r14_Optional(&p->mbms_InterFreqCarrierTypeList_r14);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType16_r11(struct SystemInformationBlockType16_r11* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType16_r11_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(struct OCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeWLAN_Identifiers_r12(struct WLAN_Identifiers_r12* p)
{
	_serSysFreeOCTET_STRING_WLAN_Identifiers_r12_ssid_r12_Optional(&p->ssid_r12);
}

static void _serSysFreeWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(struct WLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeWLAN_Identifiers_r12(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeWLAN_OffloadInfoPerPLMN_r12(struct WLAN_OffloadInfoPerPLMN_r12* p)
{
	_serSysFreeWLAN_Id_List_r12_WLAN_OffloadInfoPerPLMN_r12_wlan_Id_List_r12_Optional(&p->wlan_Id_List_r12);
}

static void _serSysFreeWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(struct WLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeWLAN_OffloadInfoPerPLMN_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType17_r12(struct SystemInformationBlockType17_r12* p)
{
	_serSysFreeWLAN_OffloadInfoPerPLMN_r12_SystemInformationBlockType17_r12_wlan_OffloadInfoPerPLMN_List_r12_DynamicOptional(&p->wlan_OffloadInfoPerPLMN_List_r12);
	_serSysFreeOCTET_STRING_SystemInformationBlockType17_r12_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(struct SL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12* p)
{
	_serSysFreeSL_TRPT_Subset_r12_SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_trpt_Subset_r12_Optional(&p->trpt_Subset_r12);
}

static void _serSysFreeSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(struct SL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12(&p->v);
}

static void _serSysFreeSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(struct SL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePool_r12(struct SL_CommResourcePool_r12* p)
{
	_serSysFreeSL_CommResourcePool_r12_ue_SelectedResourceConfig_r12_ue_SelectedResourceConfig_r12_Optional(&p->ue_SelectedResourceConfig_r12);
	_serSysFreeSL_PriorityList_r13_SL_CommResourcePool_r12_priorityList_r13_Optional(&p->priorityList_r13);
}

static void _serSysFreeSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePool_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(struct SL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePool_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(struct SL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType18_r12_commConfig_r12(struct SystemInformationBlockType18_r12_commConfig_r12* p)
{
	if (p->commRxPool_r12.v) {
		for (size_t i2 = 0; i2 < p->commRxPool_r12.d; i2++) {
			_serSysFreeSL_CommResourcePool_r12(&p->commRxPool_r12.v[i2]);
		}
		serFree(p->commRxPool_r12.v);
	}
	_serSysFreeSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolNormalCommon_r12_Optional(&p->commTxPoolNormalCommon_r12);
	_serSysFreeSL_CommTxPoolList_r12_SystemInformationBlockType18_r12_commConfig_r12_commTxPoolExceptional_r12_Optional(&p->commTxPoolExceptional_r12);
	_serSysFreeSL_SyncConfigList_r12_SystemInformationBlockType18_r12_commConfig_r12_commSyncConfig_r12_Optional(&p->commSyncConfig_r12);
}

static void _serSysFreeSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(struct SystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType18_r12_commConfig_r12(&p->v);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(struct SL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePool_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType18_r12(struct SystemInformationBlockType18_r12* p)
{
	_serSysFreeSystemInformationBlockType18_r12_commConfig_r12_commConfig_r12_Optional(&p->commConfig_r12);
	_serSysFreeOCTET_STRING_SystemInformationBlockType18_r12_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeSL_CommTxPoolListExt_r13_SystemInformationBlockType18_r12_commTxPoolNormalCommonExt_r13_Optional(&p->commTxPoolNormalCommonExt_r13);
}

static void _serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup* p)
{
	if (p->physCellId_r13.v) {
		serFree(p->physCellId_r13.v);
	}
}

static void _serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(union SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Sel d)
{
	if (d == SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup) {
		_serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_setup(&p->setup);
	}
}

static void _serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13* p)
{
	_serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_Value(&p->v, p->d);
}

static void _serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(struct SL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13(&p->v);
}

static void _serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup* p)
{
	if (p->physCellId_r13.v) {
		serFree(p->physCellId_r13.v);
	}
}

static void _serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(union SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value* p, enum SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Sel d)
{
	if (d == SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup) {
		_serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_setup(&p->setup);
	}
}

static void _serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13* p)
{
	_serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_Value(&p->v, p->d);
}

static void _serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(struct SL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13(&p->v);
}

static void _serSysFreeSL_DiscResourcePool_r12(struct SL_DiscResourcePool_r12* p)
{
	_serSysFreeSL_DiscResourcePool_r12_rxParamsAddNeighFreq_r13_rxParamsAddNeighFreq_r13_Optional(&p->rxParamsAddNeighFreq_r13);
	_serSysFreeSL_DiscResourcePool_r12_txParamsAddNeighFreq_r13_txParamsAddNeighFreq_r13_Optional(&p->txParamsAddNeighFreq_r13);
}

static void _serSysFreeSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_DiscResourcePool_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(struct SL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfig_r12(struct SystemInformationBlockType19_r12_discConfig_r12* p)
{
	if (p->discRxPool_r12.v) {
		for (size_t i2 = 0; i2 < p->discRxPool_r12.d; i2++) {
			_serSysFreeSL_DiscResourcePool_r12(&p->discRxPool_r12.v[i2]);
		}
		serFree(p->discRxPool_r12.v);
	}
	_serSysFreeSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfig_r12_discTxPoolCommon_r12_Optional(&p->discTxPoolCommon_r12);
	_serSysFreeSL_SyncConfigList_r12_SystemInformationBlockType19_r12_discConfig_r12_discSyncConfig_r12_Optional(&p->discSyncConfig_r12);
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(struct SystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType19_r12_discConfig_r12(&p->v);
}

static void _serSysFreePLMN_IdentityInfo2_r12_Value(union PLMN_IdentityInfo2_r12_Value* p, enum PLMN_IdentityInfo2_r12_Sel d)
{
	if (d == PLMN_IdentityInfo2_r12_plmnIdentity_r12) {
		_serSysFreePLMN_Identity(&p->plmnIdentity_r12);
	}
}

static void _serSysFreePLMN_IdentityInfo2_r12(struct PLMN_IdentityInfo2_r12* p)
{
	_serSysFreePLMN_IdentityInfo2_r12_Value(&p->v, p->d);
}

static void _serSysFreePLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(struct PLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreePLMN_IdentityInfo2_r12(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CarrierFreqInfo_r12(struct SL_CarrierFreqInfo_r12* p)
{
	_serSysFreePLMN_IdentityList4_r12_SL_CarrierFreqInfo_r12_plmn_IdentityList_r12_Optional(&p->plmn_IdentityList_r12);
}

static void _serSysFreeSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(struct SL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CarrierFreqInfo_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(struct SL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_DiscResourcePool_r12(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_DiscTxResourcesInterFreq_r13_Value(union SL_DiscTxResourcesInterFreq_r13_Value* p, enum SL_DiscTxResourcesInterFreq_r13_Sel d)
{
	if (d == SL_DiscTxResourcesInterFreq_r13_discTxPoolCommon_r13) {
		if (p->discTxPoolCommon_r13.v) {
			for (size_t i3 = 0; i3 < p->discTxPoolCommon_r13.d; i3++) {
				_serSysFreeSL_DiscResourcePool_r12(&p->discTxPoolCommon_r13.v[i3]);
			}
			serFree(p->discTxPoolCommon_r13.v);
		}
	}
}

static void _serSysFreeSL_DiscTxResourcesInterFreq_r13(struct SL_DiscTxResourcesInterFreq_r13* p)
{
	_serSysFreeSL_DiscTxResourcesInterFreq_r13_Value(&p->v, p->d);
}

static void _serSysFreeSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(struct SL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_DiscTxResourcesInterFreq_r13(&p->v);
}

static void _serSysFreeSL_ResourcesInterFreq_r13(struct SL_ResourcesInterFreq_r13* p)
{
	_serSysFreeSL_DiscRxPoolList_r12_SL_ResourcesInterFreq_r13_discRxResourcesInterFreq_r13_Optional(&p->discRxResourcesInterFreq_r13);
	_serSysFreeSL_DiscTxResourcesInterFreq_r13_SL_ResourcesInterFreq_r13_discTxResourcesInterFreq_r13_Optional(&p->discTxResourcesInterFreq_r13);
}

static void _serSysFreeSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_ResourcesInterFreq_r13(&p->v);
}

static void _serSysFreeSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(struct SL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_ResourcesInterFreq_r13(&p->v);
}

static void _serSysFreeSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(struct SL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_DiscConfigOtherInterFreq_r13(struct SL_DiscConfigOtherInterFreq_r13* p)
{
	_serSysFreeSL_SyncConfigListNFreq_r13_SL_DiscConfigOtherInterFreq_r13_discSyncConfig_r13_Optional(&p->discSyncConfig_r13);
}

static void _serSysFreeSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(struct SL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_DiscConfigOtherInterFreq_r13(&p->v);
}

static void _serSysFreeSL_CarrierFreqInfo_v1310(struct SL_CarrierFreqInfo_v1310* p)
{
	_serSysFreeSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesNonPS_r13_Optional(&p->discResourcesNonPS_r13);
	_serSysFreeSL_ResourcesInterFreq_r13_SL_CarrierFreqInfo_v1310_discResourcesPS_r13_Optional(&p->discResourcesPS_r13);
	_serSysFreeSL_DiscConfigOtherInterFreq_r13_SL_CarrierFreqInfo_v1310_discConfigOther_r13_Optional(&p->discConfigOther_r13);
}

static void _serSysFreeSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(struct SL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CarrierFreqInfo_v1310(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfig_v1310(struct SystemInformationBlockType19_r12_discConfig_v1310* p)
{
	_serSysFreeSL_CarrierFreqInfoList_v1310_SystemInformationBlockType19_r12_discConfig_v1310_discInterFreqList_v1310_Optional(&p->discInterFreqList_v1310);
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(struct SystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType19_r12_discConfig_v1310(&p->v);
}

static void _serSysFreeSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(struct SL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_DiscResourcePool_r12(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfigPS_13(struct SystemInformationBlockType19_r12_discConfigPS_13* p)
{
	if (p->discRxPoolPS_r13.v) {
		for (size_t i2 = 0; i2 < p->discRxPoolPS_r13.d; i2++) {
			_serSysFreeSL_DiscResourcePool_r12(&p->discRxPoolPS_r13.v[i2]);
		}
		serFree(p->discRxPoolPS_r13.v);
	}
	_serSysFreeSL_DiscTxPoolList_r12_SystemInformationBlockType19_r12_discConfigPS_13_discTxPoolPS_Common_r13_Optional(&p->discTxPoolPS_Common_r13);
}

static void _serSysFreeSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(struct SystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType19_r12_discConfigPS_13(&p->v);
}

static void _serSysFreeSystemInformationBlockType19_r12(struct SystemInformationBlockType19_r12* p)
{
	_serSysFreeSystemInformationBlockType19_r12_discConfig_r12_discConfig_r12_Optional(&p->discConfig_r12);
	_serSysFreeSL_CarrierFreqInfoList_r12_SystemInformationBlockType19_r12_discInterFreqList_r12_Optional(&p->discInterFreqList_r12);
	_serSysFreeOCTET_STRING_SystemInformationBlockType19_r12_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeSystemInformationBlockType19_r12_discConfig_v1310_discConfig_v1310_Optional(&p->discConfig_v1310);
	_serSysFreeSystemInformationBlockType19_r12_discConfigPS_13_discConfigPS_13_Optional(&p->discConfigPS_13);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType20_r13(struct SystemInformationBlockType20_r13* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType20_r13_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSL_PPPP_TxConfigIndex_r14(struct SL_PPPP_TxConfigIndex_r14* p)
{
	if (p->tx_ConfigIndexList_r14.v) {
		serFree(p->tx_ConfigIndexList_r14.v);
	}
}

static void _serSysFreeSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(struct SL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_PPPP_TxConfigIndex_r14(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(struct SL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_MinT2Value_r15(struct SL_MinT2Value_r15* p)
{
	if (p->priorityList_r15.v) {
		serFree(p->priorityList_r15.v);
	}
}

static void _serSysFreeSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(struct SL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_MinT2Value_r15(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(struct MCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_PPPP_TxConfigIndex_v1530(struct SL_PPPP_TxConfigIndex_v1530* p)
{
	_serSysFreeMCS_PSSCH_Range_r15_SL_PPPP_TxConfigIndex_v1530_mcs_PSSCH_RangeList_r15_DynamicOptional(&p->mcs_PSSCH_RangeList_r15);
}

static void _serSysFreeSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(struct SL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_PPPP_TxConfigIndex_v1530(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePoolV2X_r14(struct SL_CommResourcePoolV2X_r14* p)
{
	_serSysFreeSL_CBR_PPPP_TxConfigList_r14_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_r14_Optional(&p->cbr_pssch_TxConfigList_r14);
	_serSysFreeSL_RestrictResourceReservationPeriodList_r14_SL_CommResourcePoolV2X_r14_restrictResourceReservationPeriod_r14_Optional(&p->restrictResourceReservationPeriod_r14);
	_serSysFreeSL_MinT2ValueList_r15_SL_CommResourcePoolV2X_r14_sl_MinT2ValueList_r15_Optional(&p->sl_MinT2ValueList_r15);
	_serSysFreeSL_CBR_PPPP_TxConfigList_v1530_SL_CommResourcePoolV2X_r14_cbr_pssch_TxConfigList_v1530_Optional(&p->cbr_pssch_TxConfigList_v1530);
}

static void _serSysFreeSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(struct SL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(struct SL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(struct SL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommResourcePoolV2X_r14(&p->v);
}

static void _serSysFreeSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(struct SL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePLMN_IdentityInfo(struct PLMN_IdentityInfo* p)
{
	_serSysFreePLMN_Identity(&p->plmn_Identity);
}

static void _serSysFreePLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(struct PLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreePLMN_IdentityInfo(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(struct SL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommResourcePoolV2X_r14(&p->v);
}

static void _serSysFreePhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(struct PhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(struct SL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(struct SL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i4]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i4]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(struct SL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
			_serSysFreeSL_CommResourcePoolV2X_r14(&p->v.v[i4]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(struct SL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommResourcePoolV2X_r14(&p->v);
}

static void _serSysFreeSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(struct SL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolSensingConfig_r14(struct SL_CommTxPoolSensingConfig_r14* p)
{
	if (p->pssch_TxConfigList_r14.v) {
		for (size_t i4 = 0; i4 < p->pssch_TxConfigList_r14.d; i4++) {
		}
		serFree(p->pssch_TxConfigList_r14.v);
	}
	_serSysFreeSL_RestrictResourceReservationPeriodList_r14_SL_CommTxPoolSensingConfig_r14_restrictResourceReservationPeriod_r14_Optional(&p->restrictResourceReservationPeriod_r14);
}

static void _serSysFreeSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(struct SL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommTxPoolSensingConfig_r14(&p->v);
}

static void _serSysFreeSL_V2X_InterFreqUE_Config_r14(struct SL_V2X_InterFreqUE_Config_r14* p)
{
	_serSysFreePhysCellIdList_r13_SL_V2X_InterFreqUE_Config_r14_physCellIdList_r14_Optional(&p->physCellIdList_r14);
	_serSysFreeSL_SyncConfigListNFreqV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_SyncConfig_r14_Optional(&p->v2x_SyncConfig_r14);
	_serSysFreeSL_CommRxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommRxPool_r14_Optional(&p->v2x_CommRxPool_r14);
	_serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolNormal_r14_Optional(&p->v2x_CommTxPoolNormal_r14);
	_serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_InterFreqUE_Config_r14_p2x_CommTxPoolNormal_r14_Optional(&p->p2x_CommTxPoolNormal_r14);
	_serSysFreeSL_CommResourcePoolV2X_r14_SL_V2X_InterFreqUE_Config_r14_v2x_CommTxPoolExceptional_r14_Optional(&p->v2x_CommTxPoolExceptional_r14);
	_serSysFreeSL_CommTxPoolSensingConfig_r14_SL_V2X_InterFreqUE_Config_r14_v2x_ResourceSelectionConfig_r14_Optional(&p->v2x_ResourceSelectionConfig_r14);
}

static void _serSysFreeSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(struct SL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_V2X_InterFreqUE_Config_r14(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_V2X_FreqSelectionConfig_r15(struct SL_V2X_FreqSelectionConfig_r15* p)
{
	if (p->priorityList_r15.v) {
		serFree(p->priorityList_r15.v);
	}
}

static void _serSysFreeSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(struct SL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serSysFreeSL_V2X_FreqSelectionConfig_r15(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_InterFreqInfoV2X_r14(struct SL_InterFreqInfoV2X_r14* p)
{
	_serSysFreePLMN_IdentityList_SL_InterFreqInfoV2X_r14_plmn_IdentityList_r14_Optional(&p->plmn_IdentityList_r14);
	_serSysFreeSL_CommResourcePoolV2X_r14_SL_InterFreqInfoV2X_r14_v2x_SchedulingPool_r14_Optional(&p->v2x_SchedulingPool_r14);
	_serSysFreeSL_V2X_UE_ConfigList_r14_SL_InterFreqInfoV2X_r14_v2x_UE_ConfigList_r14_Optional(&p->v2x_UE_ConfigList_r14);
	_serSysFreeSL_V2X_FreqSelectionConfigList_r15_SL_InterFreqInfoV2X_r14_v2x_FreqSelectionConfigList_r15_Optional(&p->v2x_FreqSelectionConfigList_r15);
}

static void _serSysFreeSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(struct SL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_InterFreqInfoV2X_r14(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(struct SL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CommTxPoolSensingConfig_r14(&p->v);
}

static void _serSysFreeSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(struct SL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_CBR_CommonTxConfigList_r14(struct SL_CBR_CommonTxConfigList_r14* p)
{
	if (p->cbr_RangeCommonConfigList_r14.v) {
		for (size_t i2 = 0; i2 < p->cbr_RangeCommonConfigList_r14.d; i2++) {
			if (p->cbr_RangeCommonConfigList_r14.v[i2].v) {
				serFree(p->cbr_RangeCommonConfigList_r14.v[i2].v);
			}
		}
		serFree(p->cbr_RangeCommonConfigList_r14.v);
	}
	if (p->sl_CBR_PSSCH_TxConfigList_r14.v) {
		for (size_t i2 = 0; i2 < p->sl_CBR_PSSCH_TxConfigList_r14.d; i2++) {
		}
		serFree(p->sl_CBR_PSSCH_TxConfigList_r14.v);
	}
}

static void _serSysFreeSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(struct SL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_CBR_CommonTxConfigList_r14(&p->v);
}

static void _serSysFreeSL_V2X_ConfigCommon_r14(struct SL_V2X_ConfigCommon_r14* p)
{
	_serSysFreeSL_CommRxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommRxPool_r14_Optional(&p->v2x_CommRxPool_r14);
	_serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolNormalCommon_r14_Optional(&p->v2x_CommTxPoolNormalCommon_r14);
	_serSysFreeSL_CommTxPoolListV2X_r14_SL_V2X_ConfigCommon_r14_p2x_CommTxPoolNormalCommon_r14_Optional(&p->p2x_CommTxPoolNormalCommon_r14);
	_serSysFreeSL_CommResourcePoolV2X_r14_SL_V2X_ConfigCommon_r14_v2x_CommTxPoolExceptional_r14_Optional(&p->v2x_CommTxPoolExceptional_r14);
	_serSysFreeSL_SyncConfigListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_SyncConfig_r14_Optional(&p->v2x_SyncConfig_r14);
	_serSysFreeSL_InterFreqInfoListV2X_r14_SL_V2X_ConfigCommon_r14_v2x_InterFreqInfoList_r14_Optional(&p->v2x_InterFreqInfoList_r14);
	_serSysFreeSL_CommTxPoolSensingConfig_r14_SL_V2X_ConfigCommon_r14_v2x_ResourceSelectionConfig_r14_Optional(&p->v2x_ResourceSelectionConfig_r14);
	_serSysFreeSL_AnchorCarrierFreqList_V2X_r14_SL_V2X_ConfigCommon_r14_anchorCarrierFreqList_r14_Optional(&p->anchorCarrierFreqList_r14);
	_serSysFreeSL_CBR_CommonTxConfigList_r14_SL_V2X_ConfigCommon_r14_cbr_CommonTxConfigList_r14_Optional(&p->cbr_CommonTxConfigList_r14);
}

static void _serSysFreeSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(struct SL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_V2X_ConfigCommon_r14(&p->v);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(struct SL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType21_r14(struct SystemInformationBlockType21_r14* p)
{
	_serSysFreeSL_V2X_ConfigCommon_r14_SystemInformationBlockType21_r14_sl_V2X_ConfigCommon_r14_Optional(&p->sl_V2X_ConfigCommon_r14);
	_serSysFreeOCTET_STRING_SystemInformationBlockType21_r14_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeSL_NR_AnchorCarrierFreqList_r16_SystemInformationBlockType21_r14_anchorCarrierFreqListNR_r16_Optional(&p->anchorCarrierFreqListNR_r16);
}

static void _serSysFreeMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(struct MultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(struct SS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSS_RSSI_Measurement_r15(&p->v);
}

static void _serSysFreeNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(struct NS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(struct MultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			if (p->v.v[i3].v) {
				for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
				}
				serFree(p->v.v[i3].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(struct MultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			if (p->v.v[i3].v) {
				for (size_t i4 = 0; i4 < p->v.v[i3].d; i4++) {
				}
				serFree(p->v.v[i3].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqNR_r15(struct CarrierFreqNR_r15* p)
{
	_serSysFreeMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoList_r15_Optional(&p->multiBandInfoList_r15);
	_serSysFreeMultiFrequencyBandListNR_r15_CarrierFreqNR_r15_multiBandInfoListSUL_r15_Optional(&p->multiBandInfoListSUL_r15);
	_serSysFreeSS_RSSI_Measurement_r15_CarrierFreqNR_r15_ss_RSSI_Measurement_r15_Optional(&p->ss_RSSI_Measurement_r15);
	_serSysFreeNS_PmaxListNR_r15_CarrierFreqNR_r15_ns_PmaxListNR_r15_Optional(&p->ns_PmaxListNR_r15);
	_serSysFreeMultiBandNsPmaxListNR_1_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_v1550_Optional(&p->multiBandNsPmaxListNR_v1550);
	_serSysFreeMultiBandNsPmaxListNR_v1550_CarrierFreqNR_r15_multiBandNsPmaxListNR_SUL_v1550_Optional(&p->multiBandNsPmaxListNR_SUL_v1550);
}

static void _serSysFreeCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(struct CarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCarrierFreqNR_r15(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(struct PhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMTC_SSB2_LP_NR_r16(struct MTC_SSB2_LP_NR_r16* p)
{
	_serSysFreePhysCellIdNR_r15_MTC_SSB2_LP_NR_r16_pci_List_r16_DynamicOptional(&p->pci_List_r16);
}

static void _serSysFreeMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(struct MTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional* p)
{
	if (!p->d) return;
	_serSysFreeMTC_SSB2_LP_NR_r16(&p->v);
}

static void _serSysFreeWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(struct WhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCarrierFreqNR_v1610(struct CarrierFreqNR_v1610* p)
{
	_serSysFreeMTC_SSB2_LP_NR_r16_CarrierFreqNR_v1610_smtc2_LP_r16_Optional(&p->smtc2_LP_r16);
	_serSysFreeWhiteCellListNR_r16_CarrierFreqNR_v1610_whiteCellListNR_r16_Optional(&p->whiteCellListNR_r16);
}

static void _serSysFreeCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(struct CarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCarrierFreqNR_v1610(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType24_r15(struct SystemInformationBlockType24_r15* p)
{
	_serSysFreeCarrierFreqListNR_r15_SystemInformationBlockType24_r15_carrierFreqListNR_r15_Optional(&p->carrierFreqListNR_r15);
	_serSysFreeOCTET_STRING_SystemInformationBlockType24_r15_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeCarrierFreqListNR_v1610_SystemInformationBlockType24_r15_carrierFreqListNR_v1610_Optional(&p->carrierFreqListNR_v1610);
}

static void _serSysFreeUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(struct UAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(union UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value* p, enum UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Sel d)
{
	if (d == UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_ExplicitAC_BarringList_r15) {
		if (p->uac_ExplicitAC_BarringList_r15.v) {
			for (size_t i3 = 0; i3 < p->uac_ExplicitAC_BarringList_r15.d; i3++) {
			}
			serFree(p->uac_ExplicitAC_BarringList_r15.v);
		}
	}
}

static void _serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15* p)
{
	_serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_Value(&p->v, p->d);
}

static void _serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(struct UAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15(&p->v);
}

static void _serSysFreeUAC_BarringPerPLMN_r15(struct UAC_BarringPerPLMN_r15* p)
{
	_serSysFreeUAC_BarringPerPLMN_r15_uac_AC_BarringListType_r15_uac_AC_BarringListType_r15_Optional(&p->uac_AC_BarringListType_r15);
}

static void _serSysFreeUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(struct UAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeUAC_BarringPerPLMN_r15(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(union SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value* p, enum SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Sel d)
{
	if (d == SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_individualPLMNList_r15) {
		if (p->individualPLMNList_r15.v) {
			serFree(p->individualPLMNList_r15.v);
		}
	}
}

static void _serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15* p)
{
	_serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_Value(&p->v, p->d);
}

static void _serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(struct SystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15(&p->v);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType25_r15(struct SystemInformationBlockType25_r15* p)
{
	_serSysFreeUAC_BarringPerCatList_r15_SystemInformationBlockType25_r15_uac_BarringForCommon_r15_Optional(&p->uac_BarringForCommon_r15);
	_serSysFreeUAC_BarringPerPLMN_List_r15_SystemInformationBlockType25_r15_uac_BarringPerPLMN_List_r15_Optional(&p->uac_BarringPerPLMN_List_r15);
	if (p->uac_BarringInfoSetList_r15.v) {
		for (size_t i2 = 0; i2 < p->uac_BarringInfoSetList_r15.d; i2++) {
		}
		serFree(p->uac_BarringInfoSetList_r15.v);
	}
	_serSysFreeSystemInformationBlockType25_r15_uac_AC1_SelectAssistInfo_r15_uac_AC1_SelectAssistInfo_r15_Optional(&p->uac_AC1_SelectAssistInfo_r15);
	_serSysFreeOCTET_STRING_SystemInformationBlockType25_r15_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(struct SL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_InterFreqInfoV2X_r14(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_PPPP_TxConfigIndex_r15(struct SL_PPPP_TxConfigIndex_r15* p)
{
	if (p->tx_ConfigIndexList_r15.v) {
		serFree(p->tx_ConfigIndexList_r15.v);
	}
	if (p->mcs_PSSCH_RangeList_r15.v) {
		for (size_t i3 = 0; i3 < p->mcs_PSSCH_RangeList_r15.d; i3++) {
		}
		serFree(p->mcs_PSSCH_RangeList_r15.v);
	}
}

static void _serSysFreeSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(struct SL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_PPPP_TxConfigIndex_r15(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(struct SL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_AllowedCarrierFreqList_r15(struct SL_AllowedCarrierFreqList_r15* p)
{
	if (p->allowedCarrierFreqSet1.v) {
		serFree(p->allowedCarrierFreqSet1.v);
	}
	if (p->allowedCarrierFreqSet2.v) {
		serFree(p->allowedCarrierFreqSet2.v);
	}
}

static void _serSysFreeSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(struct SL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_AllowedCarrierFreqList_r15(&p->v);
}

static void _serSysFreeSL_PPPR_Dest_CarrierFreq(struct SL_PPPR_Dest_CarrierFreq* p)
{
	_serSysFreeSL_DestinationInfoList_r12_SL_PPPR_Dest_CarrierFreq_destinationInfoList_r15_Optional(&p->destinationInfoList_r15);
	_serSysFreeSL_AllowedCarrierFreqList_r15_SL_PPPR_Dest_CarrierFreq_allowedCarrierFreqList_r15_Optional(&p->allowedCarrierFreqList_r15);
}

static void _serSysFreeSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(struct SL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_PPPR_Dest_CarrierFreq(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_V2X_PacketDuplicationConfig_r15(struct SL_V2X_PacketDuplicationConfig_r15* p)
{
	_serSysFreeSL_PPPR_Dest_CarrierFreqList_r15_SL_V2X_PacketDuplicationConfig_r15_allowedCarrierFreqConfig_r15_Optional(&p->allowedCarrierFreqConfig_r15);
}

static void _serSysFreeSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(struct SL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_V2X_PacketDuplicationConfig_r15(&p->v);
}

static void _serSysFreeSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(struct SL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(struct SL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeSL_V2X_FreqSelectionConfig_r15(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType26_r15(struct SystemInformationBlockType26_r15* p)
{
	_serSysFreeSL_InterFreqInfoListV2X_r14_SystemInformationBlockType26_r15_v2x_InterFreqInfoList_r15_Optional(&p->v2x_InterFreqInfoList_r15);
	_serSysFreeSL_CBR_PPPP_TxConfigList_r15_SystemInformationBlockType26_r15_cbr_pssch_TxConfigList_r15_Optional(&p->cbr_pssch_TxConfigList_r15);
	_serSysFreeSL_V2X_PacketDuplicationConfig_r15_SystemInformationBlockType26_r15_v2x_PacketDuplicationConfig_r15_Optional(&p->v2x_PacketDuplicationConfig_r15);
	_serSysFreeSL_V2X_SyncFreqList_r15_SystemInformationBlockType26_r15_syncFreqList_r15_Optional(&p->syncFreqList_r15);
	_serSysFreeSL_V2X_FreqSelectionConfigList_r15_SystemInformationBlockType26_r15_v2x_FreqSelectionConfigList_r15_Optional(&p->v2x_FreqSelectionConfigList_r15);
	_serSysFreeOCTET_STRING_SystemInformationBlockType26_r15_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType26a_r16(struct SystemInformationBlockType26a_r16* p)
{
	if (p->plmn_InfoList_r16.v) {
		for (size_t i2 = 0; i2 < p->plmn_InfoList_r16.d; i2++) {
		}
		serFree(p->plmn_InfoList_r16.v);
	}
	if (p->bandListENDC_r16.v) {
		serFree(p->bandListENDC_r16.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType26a_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(struct CarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType27_r16(struct SystemInformationBlockType27_r16* p)
{
	_serSysFreeCarrierFreqListNBIOT_r16_SystemInformationBlockType27_r16_carrierFreqListNBIOT_r16_Optional(&p->carrierFreqListNBIOT_r16);
	_serSysFreeOCTET_STRING_SystemInformationBlockType27_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType28_r16(struct SystemInformationBlockType28_r16* p)
{
	if (p->segmentContainer_r16.v) {
		serFree(p->segmentContainer_r16.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockType28_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType29_r16(struct SystemInformationBlockType29_r16* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType29_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(union SystemInformation_r8_IEs_sib_TypeAndInfo_s_Value* p, enum SystemInformation_r8_IEs_sib_TypeAndInfo_s_Sel d)
{
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib2) {
		_serSysFreeSystemInformationBlockType2(&p->sib2);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib3) {
		_serSysFreeSystemInformationBlockType3(&p->sib3);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib4) {
		_serSysFreeSystemInformationBlockType4(&p->sib4);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib5) {
		_serSysFreeSystemInformationBlockType5(&p->sib5);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib6) {
		_serSysFreeSystemInformationBlockType6(&p->sib6);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib7) {
		_serSysFreeSystemInformationBlockType7(&p->sib7);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib8) {
		_serSysFreeSystemInformationBlockType8(&p->sib8);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib9) {
		_serSysFreeSystemInformationBlockType9(&p->sib9);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib10) {
		_serSysFreeSystemInformationBlockType10(&p->sib10);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib11) {
		_serSysFreeSystemInformationBlockType11(&p->sib11);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib12_v920) {
		_serSysFreeSystemInformationBlockType12_r9(&p->sib12_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib13_v920) {
		_serSysFreeSystemInformationBlockType13_r9(&p->sib13_v920);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib14_v1130) {
		_serSysFreeSystemInformationBlockType14_r11(&p->sib14_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib15_v1130) {
		_serSysFreeSystemInformationBlockType15_r11(&p->sib15_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib16_v1130) {
		_serSysFreeSystemInformationBlockType16_r11(&p->sib16_v1130);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib17_v1250) {
		_serSysFreeSystemInformationBlockType17_r12(&p->sib17_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib18_v1250) {
		_serSysFreeSystemInformationBlockType18_r12(&p->sib18_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib19_v1250) {
		_serSysFreeSystemInformationBlockType19_r12(&p->sib19_v1250);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib20_v1310) {
		_serSysFreeSystemInformationBlockType20_r13(&p->sib20_v1310);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib21_v1430) {
		_serSysFreeSystemInformationBlockType21_r14(&p->sib21_v1430);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib24_v1530) {
		_serSysFreeSystemInformationBlockType24_r15(&p->sib24_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib25_v1530) {
		_serSysFreeSystemInformationBlockType25_r15(&p->sib25_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26_v1530) {
		_serSysFreeSystemInformationBlockType26_r15(&p->sib26_v1530);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib26a_v1610) {
		_serSysFreeSystemInformationBlockType26a_r16(&p->sib26a_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib27_v1610) {
		_serSysFreeSystemInformationBlockType27_r16(&p->sib27_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib28_v1610) {
		_serSysFreeSystemInformationBlockType28_r16(&p->sib28_v1610);
	}
	if (d == SystemInformation_r8_IEs_sib_TypeAndInfo_s_sib29_v1610) {
		_serSysFreeSystemInformationBlockType29_r16(&p->sib29_v1610);
	}
}

static void _serSysFreeSystemInformation_r8_IEs_sib_TypeAndInfo_s(struct SystemInformation_r8_IEs_sib_TypeAndInfo_s* p)
{
	_serSysFreeSystemInformation_r8_IEs_sib_TypeAndInfo_s_Value(&p->v, p->d);
}

static void _serSysFreeOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformation_v8a0_IEs(struct SystemInformation_v8a0_IEs* p)
{
	_serSysFreeOCTET_STRING_SystemInformation_v8a0_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(struct SystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformation_v8a0_IEs(&p->v);
}

static void _serSysFreeSystemInformation_r8_IEs(struct SystemInformation_r8_IEs* p)
{
	if (p->sib_TypeAndInfo.v) {
		for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
			_serSysFreeSystemInformation_r8_IEs_sib_TypeAndInfo_s(&p->sib_TypeAndInfo.v[i1]);
		}
		serFree(p->sib_TypeAndInfo.v);
	}
	_serSysFreeSystemInformation_v8a0_IEs_SystemInformation_r8_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockPos_r15(struct SystemInformationBlockPos_r15* p)
{
	if (p->assistanceDataSIB_Element_r15.v) {
		serFree(p->assistanceDataSIB_Element_r15.v);
	}
	_serSysFreeOCTET_STRING_SystemInformationBlockPos_r15_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreePosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(union PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value* p, enum PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Sel d)
{
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_1_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_2_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_3_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_4_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_5_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_6_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib1_7_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib1_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_1_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_1_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_2_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_2_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_3_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_3_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_4_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_4_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_5_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_5_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_6_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_6_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_7_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_7_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_8_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_8_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_9_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_9_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_10_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_10_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_11_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_11_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_12_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_12_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_13_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_13_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_14_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_14_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_15_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_15_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_16_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_16_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_17_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_17_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_18_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_18_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib2_19_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib2_19_r15);
	}
	if (d == PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_posSib3_1_r15) {
		_serSysFreeSystemInformationBlockPos_r15(&p->posSib3_1_r15);
	}
}

static void _serSysFreePosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(struct PosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s* p)
{
	_serSysFreePosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s_Value(&p->v, p->d);
}

static void _serSysFreeOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePosSystemInformation_r15_IEs(struct PosSystemInformation_r15_IEs* p)
{
	if (p->posSIB_TypeAndInfo_r15.v) {
		for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r15.d; i1++) {
			_serSysFreePosSystemInformation_r15_IEs_posSIB_TypeAndInfo_r15_s(&p->posSIB_TypeAndInfo_r15.v[i1]);
		}
		serFree(p->posSIB_TypeAndInfo_r15.v);
	}
	_serSysFreeOCTET_STRING_PosSystemInformation_r15_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serSysFreeSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(union SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value* p, enum SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Sel d)
{
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15_posSystemInformation_r15) {
		_serSysFreePosSystemInformation_r15_IEs(&p->posSystemInformation_r15);
	}
}

static void _serSysFreeSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(struct SystemInformation_criticalExtensions_criticalExtensionsFuture_r15* p)
{
	_serSysFreeSystemInformation_criticalExtensions_criticalExtensionsFuture_r15_Value(&p->v, p->d);
}

static void _serSysFreeSystemInformation_criticalExtensions_Value(union SystemInformation_criticalExtensions_Value* p, enum SystemInformation_criticalExtensions_Sel d)
{
	if (d == SystemInformation_criticalExtensions_systemInformation_r8) {
		_serSysFreeSystemInformation_r8_IEs(&p->systemInformation_r8);
	}
	if (d == SystemInformation_criticalExtensions_criticalExtensionsFuture_r15) {
		_serSysFreeSystemInformation_criticalExtensions_criticalExtensionsFuture_r15(&p->criticalExtensionsFuture_r15);
	}
}

static void _serSysFreeSystemInformation_criticalExtensions(struct SystemInformation_criticalExtensions* p)
{
	_serSysFreeSystemInformation_criticalExtensions_Value(&p->v, p->d);
}

static void _serSysFreeSystemInformation(struct SystemInformation* p)
{
	_serSysFreeSystemInformation_criticalExtensions(&p->criticalExtensions);
}

static void _serSysFreeSystemInformationBlockType1_cellAccessRelatedInfo(struct SystemInformationBlockType1_cellAccessRelatedInfo* p)
{
	if (p->plmn_IdentityList.v) {
		for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
			_serSysFreePLMN_IdentityInfo(&p->plmn_IdentityList.v[i1]);
		}
		serFree(p->plmn_IdentityList.v);
	}
}

static void _serSysFreeSchedulingInfo(struct SchedulingInfo* p)
{
	if (p->sib_MappingInfo.v) {
		serFree(p->sib_MappingInfo.v);
	}
}

static void _serSysFreeOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(struct SchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(struct SystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13* p)
{
	_serSysFreeSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(&p->schedulingInfoList_BR_r13);
	_serSysFreeSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(&p->systemInfoValueTagList_r13);
}

static void _serSysFreeSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(struct SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13(&p->v);
}

static void _serSysFreeCellAccessRelatedInfo_r14(struct CellAccessRelatedInfo_r14* p)
{
	if (p->plmn_IdentityList_r14.v) {
		for (size_t i2 = 0; i2 < p->plmn_IdentityList_r14.d; i2++) {
			_serSysFreePLMN_IdentityInfo(&p->plmn_IdentityList_r14.v[i2]);
		}
		serFree(p->plmn_IdentityList_r14.v);
	}
}

static void _serSysFreeCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(struct CellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeCellAccessRelatedInfo_r14(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(struct PLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePosSchedulingInfo_r15(struct PosSchedulingInfo_r15* p)
{
	if (p->posSIB_MappingInfo_r15.v) {
		for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r15.d; i2++) {
		}
		serFree(p->posSIB_MappingInfo_r15.v);
	}
}

static void _serSysFreePosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(struct PosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreePosSchedulingInfo_r15(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(union PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value* p, enum PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Sel d)
{
	if (d == PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_plmn_Identity_r15) {
		_serSysFreePLMN_Identity(&p->plmn_Identity_r15);
	}
}

static void _serSysFreePLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(struct PLMN_IdentityInfo_r15_plmn_Identity_5GC_r15* p)
{
	_serSysFreePLMN_IdentityInfo_r15_plmn_Identity_5GC_r15_Value(&p->v, p->d);
}

static void _serSysFreePLMN_IdentityInfo_r15(struct PLMN_IdentityInfo_r15* p)
{
	_serSysFreePLMN_IdentityInfo_r15_plmn_Identity_5GC_r15(&p->plmn_Identity_5GC_r15);
}

static void _serSysFreeCellAccessRelatedInfo_5GC_r15(struct CellAccessRelatedInfo_5GC_r15* p)
{
	if (p->plmn_IdentityList_r15.v) {
		for (size_t i2 = 0; i2 < p->plmn_IdentityList_r15.d; i2++) {
			_serSysFreePLMN_IdentityInfo_r15(&p->plmn_IdentityList_r15.v[i2]);
		}
		serFree(p->plmn_IdentityList_r15.v);
	}
}

static void _serSysFreeSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15* p)
{
	if (p->cellAccessRelatedInfoList_5GC_r15.v) {
		for (size_t i1 = 0; i1 < p->cellAccessRelatedInfoList_5GC_r15.d; i1++) {
			_serSysFreeCellAccessRelatedInfo_5GC_r15(&p->cellAccessRelatedInfoList_5GC_r15.v[i1]);
		}
		serFree(p->cellAccessRelatedInfoList_5GC_r15.v);
	}
}

static void _serSysFreeSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(struct SystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15(&p->v);
}

static void _serSysFreePLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(struct PLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSystemInformationBlockType1_v1610_IEs(struct SystemInformationBlockType1_v1610_IEs* p)
{
	_serSysFreePLMN_IdentityList_v1610_SystemInformationBlockType1_v1610_IEs_plmn_IdentityList_v1610_Optional(&p->plmn_IdentityList_v1610);
}

static void _serSysFreeSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1610_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1540_IEs(struct SystemInformationBlockType1_v1540_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1610_IEs_SystemInformationBlockType1_v1540_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1540_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1530_IEs(struct SystemInformationBlockType1_v1530_IEs* p)
{
	_serSysFreePLMN_IdentityList_v1530_SystemInformationBlockType1_v1530_IEs_plmn_IdentityList_v1530_Optional(&p->plmn_IdentityList_v1530);
	_serSysFreePosSchedulingInfoList_r15_SystemInformationBlockType1_v1530_IEs_posSchedulingInfoList_r15_Optional(&p->posSchedulingInfoList_r15);
	_serSysFreeSystemInformationBlockType1_v1530_IEs_cellAccessRelatedInfo_5GC_r15_cellAccessRelatedInfo_5GC_r15_Optional(&p->cellAccessRelatedInfo_5GC_r15);
	_serSysFreeSystemInformationBlockType1_v1540_IEs_SystemInformationBlockType1_v1530_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1530_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1450_IEs(struct SystemInformationBlockType1_v1450_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1530_IEs_SystemInformationBlockType1_v1450_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1450_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1430_IEs(struct SystemInformationBlockType1_v1430_IEs* p)
{
	_serSysFreeCellAccessRelatedInfo_r14_SystemInformationBlockType1_v1430_IEs_cellAccessRelatedInfoList_r14_DynamicOptional(&p->cellAccessRelatedInfoList_r14);
	_serSysFreeSystemInformationBlockType1_v1450_IEs_SystemInformationBlockType1_v1430_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1430_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1360_IEs(struct SystemInformationBlockType1_v1360_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1430_IEs_SystemInformationBlockType1_v1360_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1360_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1350_IEs(struct SystemInformationBlockType1_v1350_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1360_IEs_SystemInformationBlockType1_v1350_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1350_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1320_IEs(struct SystemInformationBlockType1_v1320_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1350_IEs_SystemInformationBlockType1_v1320_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1320_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1310_IEs(struct SystemInformationBlockType1_v1310_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_bandwidthReducedAccessRelatedInfo_r13_Optional(&p->bandwidthReducedAccessRelatedInfo_r13);
	_serSysFreeSystemInformationBlockType1_v1320_IEs_SystemInformationBlockType1_v1310_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1310_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1250_IEs(struct SystemInformationBlockType1_v1250_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1310_IEs_SystemInformationBlockType1_v1250_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1250_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v1130_IEs(struct SystemInformationBlockType1_v1130_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1250_IEs_SystemInformationBlockType1_v1130_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v1130_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v920_IEs(struct SystemInformationBlockType1_v920_IEs* p)
{
	_serSysFreeSystemInformationBlockType1_v1130_IEs_SystemInformationBlockType1_v920_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v920_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1_v890_IEs(struct SystemInformationBlockType1_v890_IEs* p)
{
	_serSysFreeOCTET_STRING_SystemInformationBlockType1_v890_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreeSystemInformationBlockType1_v920_IEs_SystemInformationBlockType1_v890_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(struct SystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSystemInformationBlockType1_v890_IEs(&p->v);
}

static void _serSysFreeSystemInformationBlockType1(struct SystemInformationBlockType1* p)
{
	_serSysFreeSystemInformationBlockType1_cellAccessRelatedInfo(&p->cellAccessRelatedInfo);
	if (p->schedulingInfoList.v) {
		for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
			_serSysFreeSchedulingInfo(&p->schedulingInfoList.v[i1]);
		}
		serFree(p->schedulingInfoList.v);
	}
	_serSysFreeSystemInformationBlockType1_v890_IEs_SystemInformationBlockType1_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreeBCCH_DL_SCH_MessageType_c1_Value(union BCCH_DL_SCH_MessageType_c1_Value* p, enum BCCH_DL_SCH_MessageType_c1_Sel d)
{
	if (d == BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serSysFreeSystemInformation(&p->systemInformation);
	}
	if (d == BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serSysFreeSystemInformationBlockType1(&p->systemInformationBlockType1);
	}
}

static void _serSysFreeBCCH_DL_SCH_MessageType_c1(struct BCCH_DL_SCH_MessageType_c1* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType_c1_Value(&p->v, p->d);
}

static void _serSysFreeBCCH_DL_SCH_MessageType_Value(union BCCH_DL_SCH_MessageType_Value* p, enum BCCH_DL_SCH_MessageType_Sel d)
{
	if (d == BCCH_DL_SCH_MessageType_c1) {
		_serSysFreeBCCH_DL_SCH_MessageType_c1(&p->c1);
	}
}

static void _serSysFreeBCCH_DL_SCH_MessageType(struct BCCH_DL_SCH_MessageType* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType_Value(&p->v, p->d);
}

static void _serSysFreeBCCH_DL_SCH_Message(struct BCCH_DL_SCH_Message* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType(&p->message);
}

static void _serSysFreeBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(struct BCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBCCH_DL_SCH_Message(&p->v);
}

static void _serSysFreeSI_List_Type_SIs_Optional(struct SI_List_Type_SIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeBCCH_DL_SCH_Message(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSegmentedSI_List_Type_SegmentedSIs_Optional(struct SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			if (p->v.v[i1].v) {
				for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
					_serSysFreeBCCH_DL_SCH_Message(&p->v.v[i1].v[i2]);
				}
				serFree(p->v.v[i1].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeBcchInfo_Type(struct BcchInfo_Type* p)
{
	_serSysFreeBCCH_DL_SCH_Message_BcchInfo_Type_SIB1_Optional(&p->SIB1);
	_serSysFreeSI_List_Type_SIs_Optional(&p->SIs);
	_serSysFreeSegmentedSI_List_Type_SegmentedSIs_Optional(&p->SegmentedSIs);
}

static void _serSysFreeBcchInfo_Type_BcchInfo_Optional(struct BcchInfo_Type_BcchInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcchInfo_Type(&p->v);
}

static void _serSysFreeBcchConfig_Type(struct BcchConfig_Type* p)
{
	_serSysFreeBcchToPdschConfig_Type_Pdsch_Optional(&p->Pdsch);
	_serSysFreeBcchInfo_Type_BcchInfo_Optional(&p->BcchInfo);
}

static void _serSysFreeBcchConfig_Type_BcchConfig_Optional(struct BcchConfig_Type_BcchConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcchConfig_Type(&p->v);
}

static void _serSysFreeDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(struct DciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDciDlInfoCommon_Type(&p->v);
}

static void _serSysFreePcchConfig_Type(struct PcchConfig_Type* p)
{
	_serSysFreeDciDlInfoCommon_Type_PcchConfig_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serSysFreePcchConfig_Type_PcchConfig_Optional(struct PcchConfig_Type_PcchConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreePcchConfig_Type(&p->v);
}

static void _serSysFreeBandwidthReducedAccessRelatedInfo_Type(BandwidthReducedAccessRelatedInfo_Type* p)
{
	_serSysFreeSchedulingInfoList_BR_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_schedulingInfoList_BR_r13_Optional(&p->schedulingInfoList_BR_r13);
	_serSysFreeSystemInfoValueTagList_r13_SystemInformationBlockType1_v1310_IEs_bandwidthReducedAccessRelatedInfo_r13_systemInfoValueTagList_r13_Optional(&p->systemInfoValueTagList_r13);
}

static void _serSysFreeBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(struct BandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBandwidthReducedAccessRelatedInfo_Type(&p->v);
}

static void _serSysFreeSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(struct SI_SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeBcch_BRToPdschConfig_Type(struct Bcch_BRToPdschConfig_Type* p)
{
	_serSysFreeBandwidthReducedAccessRelatedInfo_Type_SiSchedul_Optional(&p->SiSchedul);
	_serSysFreeSI_SubframeOffsetList_Type_SubframeOffsetList_Optional(&p->SubframeOffsetList);
}

static void _serSysFreeBcch_BRToPdschConfig_Type_Pdsch_Optional(struct Bcch_BRToPdschConfig_Type_Pdsch_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcch_BRToPdschConfig_Type(&p->v);
}

static void _serSysFreeBCCH_DL_SCH_MessageType_BR_r13_c1_Value(union BCCH_DL_SCH_MessageType_BR_r13_c1_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_c1_Sel d)
{
	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformation_BR_r13) {
		_serSysFreeSystemInformation(&p->systemInformation_BR_r13);
	}
	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1_systemInformationBlockType1_BR_r13) {
		_serSysFreeSystemInformationBlockType1(&p->systemInformationBlockType1_BR_r13);
	}
}

static void _serSysFreeBCCH_DL_SCH_MessageType_BR_r13_c1(struct BCCH_DL_SCH_MessageType_BR_r13_c1* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType_BR_r13_c1_Value(&p->v, p->d);
}

static void _serSysFreeBCCH_DL_SCH_MessageType_BR_r13_Value(union BCCH_DL_SCH_MessageType_BR_r13_Value* p, enum BCCH_DL_SCH_MessageType_BR_r13_Sel d)
{
	if (d == BCCH_DL_SCH_MessageType_BR_r13_c1) {
		_serSysFreeBCCH_DL_SCH_MessageType_BR_r13_c1(&p->c1);
	}
}

static void _serSysFreeBCCH_DL_SCH_MessageType_BR_r13(struct BCCH_DL_SCH_MessageType_BR_r13* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType_BR_r13_Value(&p->v, p->d);
}

static void _serSysFreeBCCH_DL_SCH_Message_BR(struct BCCH_DL_SCH_Message_BR* p)
{
	_serSysFreeBCCH_DL_SCH_MessageType_BR_r13(&p->message);
}

static void _serSysFreeBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(struct BCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBCCH_DL_SCH_Message_BR(&p->v);
}

static void _serSysFreeBR_SI_List_Type_SIs_Optional(struct BR_SI_List_Type_SIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeBCCH_DL_SCH_Message_BR(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeBR_SegmentedSI_List_Type_SegmentedSIs_Optional(struct BR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			if (p->v.v[i1].v) {
				for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
					_serSysFreeBCCH_DL_SCH_Message_BR(&p->v.v[i1].v[i2]);
				}
				serFree(p->v.v[i1].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeBcch_BRInfo_Type(struct Bcch_BRInfo_Type* p)
{
	_serSysFreeBCCH_DL_SCH_Message_BR_Bcch_BRInfo_Type_SIB1_Optional(&p->SIB1);
	_serSysFreeBR_SI_List_Type_SIs_Optional(&p->SIs);
	_serSysFreeBR_SegmentedSI_List_Type_SegmentedSIs_Optional(&p->SegmentedSIs);
}

static void _serSysFreeBcch_BRInfo_Type_BcchInfo_Optional(struct Bcch_BRInfo_Type_BcchInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcch_BRInfo_Type(&p->v);
}

static void _serSysFreeBcch_BRConfig_Type(struct Bcch_BRConfig_Type* p)
{
	_serSysFreeBcch_BRToPdschConfig_Type_Pdsch_Optional(&p->Pdsch);
	_serSysFreeBcch_BRInfo_Type_BcchInfo_Optional(&p->BcchInfo);
}

static void _serSysFreeBcch_BRConfig_Type_BRBcchConfig_Optional(struct Bcch_BRConfig_Type_BRBcchConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBcch_BRConfig_Type(&p->v);
}

static void _serSysFreeBasicCellConfig_Type(struct BasicCellConfig_Type* p)
{
	_serSysFreePhysicalLayerConfigDL_Type_PhysicalLayerConfigDL_Optional(&p->PhysicalLayerConfigDL);
	_serSysFreeBcchConfig_Type_BcchConfig_Optional(&p->BcchConfig);
	_serSysFreePcchConfig_Type_PcchConfig_Optional(&p->PcchConfig);
	_serSysFreeBcch_BRConfig_Type_BRBcchConfig_Optional(&p->BRBcchConfig);
}

static void _serSysFreeBasicCellConfig_Type_Basic_Optional(struct BasicCellConfig_Type_Basic_Optional* p)
{
	if (!p->d) return;
	_serSysFreeBasicCellConfig_Type(&p->v);
}

static void _serSysFreeRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(struct RSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(struct PRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreePRACH_ParametersCE_r13(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePRACH_Config_v1310(struct PRACH_Config_v1310* p)
{
	_serSysFreeRSRP_ThresholdsPrachInfoList_r13_PRACH_Config_v1310_rsrp_ThresholdsPrachInfoList_r13_Optional(&p->rsrp_ThresholdsPrachInfoList_r13);
	_serSysFreePRACH_ParametersListCE_r13_PRACH_Config_v1310_prach_ParametersListCE_r13_Optional(&p->prach_ParametersListCE_r13);
}

static void _serSysFreePRACH_Config_v1310_prach_Config_v1310_Optional(struct PRACH_Config_v1310_prach_Config_v1310_Optional* p)
{
	if (!p->d) return;
	_serSysFreePRACH_Config_v1310(&p->v);
}

static void _serSysFreePRACH_Config_R8andLater_Type(struct PRACH_Config_R8andLater_Type* p)
{
	_serSysFreePRACH_Config_v1310_prach_Config_v1310_Optional(&p->prach_Config_v1310);
}

static void _serSysFreePRACH_Config_Type_Value(union PRACH_Config_Type_Value* p, enum PRACH_Config_Type_Sel d)
{
	if (d == PRACH_Config_Type_R8andLater) {
		_serSysFreePRACH_Config_R8andLater_Type(&p->R8andLater);
	}
}

static void _serSysFreePRACH_Config_Type(struct PRACH_Config_Type* p)
{
	_serSysFreePRACH_Config_Type_Value(&p->v, p->d);
}

static void _serSysFreePRACH_Config_Type_Prach_Optional(struct PRACH_Config_Type_Prach_Optional* p)
{
	if (!p->d) return;
	_serSysFreePRACH_Config_Type(&p->v);
}

static void _serSysFreePUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(struct PUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigCommon_v1310(&p->v);
}

static void _serSysFreePUCCH_ConfigCommon_R8andLater_Type(struct PUCCH_ConfigCommon_R8andLater_Type* p)
{
	_serSysFreePUCCH_ConfigCommon_v1310_pucch_ConfigCommon_v1310_Optional(&p->pucch_ConfigCommon_v1310);
}

static void _serSysFreePUCCH_ConfigCommon_Type_Value(union PUCCH_ConfigCommon_Type_Value* p, enum PUCCH_ConfigCommon_Type_Sel d)
{
	if (d == PUCCH_ConfigCommon_Type_R8andLater) {
		_serSysFreePUCCH_ConfigCommon_R8andLater_Type(&p->R8andLater);
	}
}

static void _serSysFreePUCCH_ConfigCommon_Type(struct PUCCH_ConfigCommon_Type* p)
{
	_serSysFreePUCCH_ConfigCommon_Type_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigCommon_Type_Common_Optional(struct PUCCH_ConfigCommon_Type_Common_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigCommon_Type(&p->v);
}

static void _serSysFreeUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(struct uint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	if (p->n3PUCCH_AN_ListP1_r13.v) {
		serFree(p->n3PUCCH_AN_ListP1_r13.v);
	}
}

static void _serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(union PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	if (d == PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(&p->setup);
	}
}

static void _serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	_serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(struct PUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13(&p->v);
}

static void _serSysFreePUCCH_Format3_Conf_r13(struct PUCCH_Format3_Conf_r13* p)
{
	_serSysFreeUint16_t_PUCCH_Format3_Conf_r13_n3PUCCH_AN_List_r13_DynamicOptional(&p->n3PUCCH_AN_List_r13);
	_serSysFreePUCCH_Format3_Conf_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(&p->twoAntennaPortActivatedPUCCH_Format3_r13);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup* p)
{
	if (p->n1PUCCH_AN_CS_List_r10.v) {
		for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r10.d; i1++) {
			if (p->n1PUCCH_AN_CS_List_r10.v[i1].v) {
				serFree(p->n1PUCCH_AN_CS_List_r10.v[i1].v);
			}
		}
		serFree(p->n1PUCCH_AN_CS_List_r10.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Sel d)
{
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup) {
		_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_setup(&p->setup);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10_n1PUCCH_AN_CS_r10_n1PUCCH_AN_CS_r10_Optional(&p->n1PUCCH_AN_CS_r10);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(union PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value* p, enum PUCCH_ConfigDedicated_v1020_pucch_Format_r10_Sel d)
{
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_format3_r10) {
		_serSysFreePUCCH_Format3_Conf_r13(&p->format3_r10);
	}
	if (d == PUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10) {
		_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_channelSelection_r10(&p->channelSelection_r10);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(struct PUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020(struct PUCCH_ConfigDedicated_v1020* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_Format_r10_pucch_Format_r10_Optional(&p->pucch_Format_r10);
}

static void _serSysFreePUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(struct PUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_v1020(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup* p)
{
	if (p->n1PUCCH_AN_CS_ListP1_r11.v) {
		serFree(p->n1PUCCH_AN_CS_ListP1_r11.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(union PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value* p, enum PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Sel d)
{
	if (d == PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup) {
		_serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_setup(&p->setup);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(struct PUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_v1130(struct PUCCH_ConfigDedicated_v1130* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1130_n1PUCCH_AN_CS_v1130_n1PUCCH_AN_CS_v1130_Optional(&p->n1PUCCH_AN_CS_v1130);
}

static void _serSysFreePUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(struct PUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_v1130(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_R8andLater_Type(struct PUCCH_ConfigDedicated_R8andLater_Type* p)
{
	_serSysFreePUCCH_ConfigDedicated_v1020_pucch_ConfigDedicated_v1020_Optional(&p->pucch_ConfigDedicated_v1020);
	_serSysFreePUCCH_ConfigDedicated_v1130_pucch_ConfigDedicated_v1130_Optional(&p->pucch_ConfigDedicated_v1130);
}

static void _serSysFreeUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(struct uint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup* p)
{
	if (p->n3PUCCH_AN_ListP1_r13.v) {
		serFree(p->n3PUCCH_AN_ListP1_r13.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(union PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Sel d)
{
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup) {
		_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_setup(&p->setup);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13* p)
{
	_serSysFreeUint16_t_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_n3PUCCH_AN_List_r13_DynamicOptional(&p->n3PUCCH_AN_List_r13);
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_twoAntennaPortActivatedPUCCH_Format3_r13_Optional(&p->twoAntennaPortActivatedPUCCH_Format3_r13);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup* p)
{
	if (p->n1PUCCH_AN_CS_List_r13.v) {
		for (size_t i1 = 0; i1 < p->n1PUCCH_AN_CS_List_r13.d; i1++) {
			if (p->n1PUCCH_AN_CS_List_r13.v[i1].v) {
				serFree(p->n1PUCCH_AN_CS_List_r13.v[i1].v);
			}
		}
		serFree(p->n1PUCCH_AN_CS_List_r13.v);
	}
	if (p->dummy1.v) {
		serFree(p->dummy1.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(union PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Sel d)
{
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup) {
		_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_setup(&p->setup);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13_n1PUCCH_AN_CS_r13_n1PUCCH_AN_CS_r13_Optional(&p->n1PUCCH_AN_CS_r13);
}

static void _serSysFreeFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(struct Format4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13* p)
{
	_serSysFreeFormat4_resource_r13_PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13_format4_MultiCSI_resourceConfiguration_r13_DynamicOptional(&p->format4_MultiCSI_resourceConfiguration_r13);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(union PUCCH_ConfigDedicated_r13_pucch_Format_r13_Value* p, enum PUCCH_ConfigDedicated_r13_pucch_Format_r13_Sel d)
{
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13) {
		_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format3_r13(&p->format3_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13) {
		_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_channelSelection_r13(&p->channelSelection_r13);
	}
	if (d == PUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13) {
		_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_format4_r13(&p->format4_r13);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(struct PUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13(&p->v);
}

static void _serSysFreePUCCH_ConfigDedicated_r13(struct PUCCH_ConfigDedicated_r13* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13_pucch_Format_r13_pucch_Format_r13_Optional(&p->pucch_Format_r13);
}

static void _serSysFreePUCCH_ConfigDedicated_R13andLater_Type(struct PUCCH_ConfigDedicated_R13andLater_Type* p)
{
	_serSysFreePUCCH_ConfigDedicated_r13(&p->pucch_ConfigDedicated_r13);
}

static void _serSysFreePUCCH_ConfigDedicated_Type_Value(union PUCCH_ConfigDedicated_Type_Value* p, enum PUCCH_ConfigDedicated_Type_Sel d)
{
	if (d == PUCCH_ConfigDedicated_Type_R8andLater) {
		_serSysFreePUCCH_ConfigDedicated_R8andLater_Type(&p->R8andLater);
	}
	if (d == PUCCH_ConfigDedicated_Type_R13andLater) {
		_serSysFreePUCCH_ConfigDedicated_R13andLater_Type(&p->R13andLater);
	}
}

static void _serSysFreePUCCH_ConfigDedicated_Type(struct PUCCH_ConfigDedicated_Type* p)
{
	_serSysFreePUCCH_ConfigDedicated_Type_Value(&p->v, p->d);
}

static void _serSysFreePUCCH_ConfigDedicated_Type_Dedicated_Optional(struct PUCCH_ConfigDedicated_Type_Dedicated_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_ConfigDedicated_Type(&p->v);
}

static void _serSysFreePUCCH_Configuration_Type(struct PUCCH_Configuration_Type* p)
{
	_serSysFreePUCCH_ConfigCommon_Type_Common_Optional(&p->Common);
	_serSysFreePUCCH_ConfigDedicated_Type_Dedicated_Optional(&p->Dedicated);
}

static void _serSysFreePUCCH_Configuration_Type_Pucch_Optional(struct PUCCH_Configuration_Type_Pucch_Optional* p)
{
	if (!p->d) return;
	_serSysFreePUCCH_Configuration_Type(&p->v);
}

static void _serSysFreeSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(struct SRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup* p)
{
	_serSysFreeSRS_ConfigAp_r10_SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup_srs_ConfigApDCI_Format4_r10_DynamicOptional(&p->srs_ConfigApDCI_Format4_r10);
}

static void _serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(union SoundingRS_UL_ConfigDedicatedAperiodic_r10_Value* p, enum SoundingRS_UL_ConfigDedicatedAperiodic_r10_Sel d)
{
	if (d == SoundingRS_UL_ConfigDedicatedAperiodic_r10_setup) {
		_serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_setup(&p->setup);
	}
}

static void _serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10(struct SoundingRS_UL_ConfigDedicatedAperiodic_r10* p)
{
	_serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_Value(&p->v, p->d);
}

static void _serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(struct SoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10(&p->v);
}

static void _serSysFreeSoundingRS_UL_ConfigDedicated_R8andLater_Type(struct SoundingRS_UL_ConfigDedicated_R8andLater_Type* p)
{
	_serSysFreeSoundingRS_UL_ConfigDedicatedAperiodic_r10_soundingRS_UL_ConfigDedicatedAperiodic_r10_Optional(&p->soundingRS_UL_ConfigDedicatedAperiodic_r10);
}

static void _serSysFreeSoundingRS_UL_ConfigDedicated_Type_Value(union SoundingRS_UL_ConfigDedicated_Type_Value* p, enum SoundingRS_UL_ConfigDedicated_Type_Sel d)
{
	if (d == SoundingRS_UL_ConfigDedicated_Type_R8andLater) {
		_serSysFreeSoundingRS_UL_ConfigDedicated_R8andLater_Type(&p->R8andLater);
	}
}

static void _serSysFreeSoundingRS_UL_ConfigDedicated_Type(struct SoundingRS_UL_ConfigDedicated_Type* p)
{
	_serSysFreeSoundingRS_UL_ConfigDedicated_Type_Value(&p->v, p->d);
}

static void _serSysFreeSRS_UL_Config_Type(struct SRS_UL_Config_Type* p)
{
	_serSysFreeSoundingRS_UL_ConfigDedicated_Type(&p->Dedicated);
}

static void _serSysFreeSRS_UL_Config_Type_SRS_UL_Config_Optional(struct SRS_UL_Config_Type_SRS_UL_Config_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSRS_UL_Config_Type(&p->v);
}

static void _serSysFreeCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(struct CQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(struct CQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCQI_ReportPeriodic_v1130(struct CQI_ReportPeriodic_v1130* p)
{
	_serSysFreeCQI_ReportPeriodicProcExtToReleaseList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToReleaseList_r11_Optional(&p->cqi_ReportPeriodicProcExtToReleaseList_r11);
	_serSysFreeCQI_ReportPeriodicProcExtToAddModList_r11_CQI_ReportPeriodic_v1130_cqi_ReportPeriodicProcExtToAddModList_r11_Optional(&p->cqi_ReportPeriodicProcExtToAddModList_r11);
}

static void _serSysFreeCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(struct CSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(struct CSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(struct CSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeP_C_AndCBSR_r11(struct P_C_AndCBSR_r11* p)
{
	if (p->codebookSubsetRestriction_r11.v) {
		serFree(p->codebookSubsetRestriction_r11.v);
	}
}

static void _serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(union CSI_Process_r11_csi_IM_ConfigIdList_r12_Value* p, enum CSI_Process_r11_csi_IM_ConfigIdList_r12_Sel d)
{
	if (d == CSI_Process_r11_csi_IM_ConfigIdList_r12_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
	}
}

static void _serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12(struct CSI_Process_r11_csi_IM_ConfigIdList_r12* p)
{
	_serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12_Value(&p->v, p->d);
}

static void _serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(struct CSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12(&p->v);
}

static void _serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(struct P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13* p)
{
	if (p->codebookSubsetRestriction1_r13.v) {
		serFree(p->codebookSubsetRestriction1_r13.v);
	}
	if (p->codebookSubsetRestriction2_r13.v) {
		serFree(p->codebookSubsetRestriction2_r13.v);
	}
}

static void _serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13* p)
{
	if (p->codebookSubsetRestriction3_r13.v) {
		serFree(p->codebookSubsetRestriction3_r13.v);
	}
}

static void _serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(struct P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13* p)
{
	if (p->codebookSubsetRestriction_r13.v) {
		serFree(p->codebookSubsetRestriction_r13.v);
	}
}

static void _serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_Value(union P_C_AndCBSR_r13_cbsr_Selection_r13_Value* p, enum P_C_AndCBSR_r13_cbsr_Selection_r13_Sel d)
{
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13) {
		_serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_nonPrecoded_r13(&p->nonPrecoded_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13) {
		_serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedK1a_r13(&p->beamformedK1a_r13);
	}
	if (d == P_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13) {
		_serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_beamformedKN_r13(&p->beamformedKN_r13);
	}
}

static void _serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13(struct P_C_AndCBSR_r13_cbsr_Selection_r13* p)
{
	_serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13_Value(&p->v, p->d);
}

static void _serSysFreeP_C_AndCBSR_r13(struct P_C_AndCBSR_r13* p)
{
	_serSysFreeP_C_AndCBSR_r13_cbsr_Selection_r13(&p->cbsr_Selection_r13);
}

static void _serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeP_C_AndCBSR_r13(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(struct CSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_setup(struct CSI_RS_ConfigNZP_EMIMO_r13_setup* p)
{
	if (p->nzp_resourceConfigList_r13.v) {
		for (size_t i2 = 0; i2 < p->nzp_resourceConfigList_r13.d; i2++) {
		}
		serFree(p->nzp_resourceConfigList_r13.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_Value(union CSI_RS_ConfigNZP_EMIMO_r13_Value* p, enum CSI_RS_ConfigNZP_EMIMO_r13_Sel d)
{
	if (d == CSI_RS_ConfigNZP_EMIMO_r13_setup) {
		_serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_r13(struct CSI_RS_ConfigNZP_EMIMO_r13* p)
{
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(struct CSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_r13(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNonPrecoded_r13(struct CSI_RS_ConfigNonPrecoded_r13* p)
{
	_serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigNonPrecoded_r13_p_C_AndCBSRList_r13_Optional(&p->p_C_AndCBSRList_r13);
	_serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigNonPrecoded_r13_csi_IM_ConfigIdList_r13_DynamicOptional(&p->csi_IM_ConfigIdList_r13);
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_r13_CSI_RS_ConfigNonPrecoded_r13_csi_RS_ConfigNZP_EMIMO_r13_Optional(&p->csi_RS_ConfigNZP_EMIMO_r13);
}

static void _serSysFreeCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			if (p->v.v[i2].v) {
				for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
					_serSysFreeP_C_AndCBSR_r13(&p->v.v[i2].v[i3]);
				}
				serFree(p->v.v[i2].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(struct bool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigBeamformed_r13(struct CSI_RS_ConfigBeamformed_r13* p)
{
	_serSysFreeCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r13_csi_RS_ConfigNZPIdListExt_r13_DynamicOptional(&p->csi_RS_ConfigNZPIdListExt_r13);
	_serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r13_csi_IM_ConfigIdList_r13_DynamicOptional(&p->csi_IM_ConfigIdList_r13);
	_serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r13_p_C_AndCBSR_PerResourceConfigList_r13_DynamicOptional(&p->p_C_AndCBSR_PerResourceConfigList_r13);
	_serSysFreeBool_CSI_RS_ConfigBeamformed_r13_ace_For4Tx_PerResourceConfigList_r13_DynamicOptional(&p->ace_For4Tx_PerResourceConfigList_r13);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_r13_setup_Value(union CSI_RS_ConfigEMIMO_r13_setup_Value* p, enum CSI_RS_ConfigEMIMO_r13_setup_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_r13_setup_nonPrecoded_r13) {
		_serSysFreeCSI_RS_ConfigNonPrecoded_r13(&p->nonPrecoded_r13);
	}
	if (d == CSI_RS_ConfigEMIMO_r13_setup_beamformed_r13) {
		_serSysFreeCSI_RS_ConfigBeamformed_r13(&p->beamformed_r13);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_r13_setup(struct CSI_RS_ConfigEMIMO_r13_setup* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_r13_setup_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_r13_Value(union CSI_RS_ConfigEMIMO_r13_Value* p, enum CSI_RS_ConfigEMIMO_r13_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_r13_setup) {
		_serSysFreeCSI_RS_ConfigEMIMO_r13_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_r13(struct CSI_RS_ConfigEMIMO_r13* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_r13_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(struct CSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO_r13(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430(struct CSI_RS_ConfigNZP_EMIMO_v1430* p)
{
	if (p->nzp_resourceConfigListExt_r14.v) {
		for (size_t i2 = 0; i2 < p->nzp_resourceConfigListExt_r14.d; i2++) {
		}
		serFree(p->nzp_resourceConfigListExt_r14.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNonPrecoded_v1430(struct CSI_RS_ConfigNonPrecoded_v1430* p)
{
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1430_csi_RS_ConfigNZP_EMIMO_v1430_Optional(&p->csi_RS_ConfigNZP_EMIMO_v1430);
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCSI_RS_ConfigNZP_r11(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigBeamformed_v1430(struct CSI_RS_ConfigBeamformed_v1430* p)
{
	_serSysFreeCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_v1430_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(&p->csi_RS_ConfigNZP_ApList_r14);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1430_setup_Value(union CSI_RS_ConfigEMIMO_v1430_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1430_setup_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1430_setup_nonPrecoded_v1430) {
		_serSysFreeCSI_RS_ConfigNonPrecoded_v1430(&p->nonPrecoded_v1430);
	}
	if (d == CSI_RS_ConfigEMIMO_v1430_setup_beamformed_v1430) {
		_serSysFreeCSI_RS_ConfigBeamformed_v1430(&p->beamformed_v1430);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1430_setup(struct CSI_RS_ConfigEMIMO_v1430_setup* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1430_setup_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1430_Value(union CSI_RS_ConfigEMIMO_v1430_Value* p, enum CSI_RS_ConfigEMIMO_v1430_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1430_setup) {
		_serSysFreeCSI_RS_ConfigEMIMO_v1430_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1430(struct CSI_RS_ConfigEMIMO_v1430* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1430_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(struct CSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO_v1430(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(struct CSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(struct CSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(struct P_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			if (p->v.v[i2].v) {
				for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
					_serSysFreeP_C_AndCBSR_r13(&p->v.v[i2].v[i3]);
				}
				serFree(p->v.v[i2].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(struct bool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(struct CSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeCSI_RS_ConfigNZP_r11(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigBeamformed_r14(struct CSI_RS_ConfigBeamformed_r14* p)
{
	_serSysFreeCSI_RS_ConfigNZPId_r13_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZPIdListExt_r14_DynamicOptional(&p->csi_RS_ConfigNZPIdListExt_r14);
	_serSysFreeCSI_IM_ConfigId_r13_CSI_RS_ConfigBeamformed_r14_csi_IM_ConfigIdList_r14_DynamicOptional(&p->csi_IM_ConfigIdList_r14);
	_serSysFreeP_C_AndCBSR_Pair_r13_CSI_RS_ConfigBeamformed_r14_p_C_AndCBSR_PerResourceConfigList_r14_DynamicOptional(&p->p_C_AndCBSR_PerResourceConfigList_r14);
	_serSysFreeBool_CSI_RS_ConfigBeamformed_r14_ace_For4Tx_PerResourceConfigList_r14_DynamicOptional(&p->ace_For4Tx_PerResourceConfigList_r14);
	_serSysFreeCSI_RS_ConfigNZP_r11_CSI_RS_ConfigBeamformed_r14_csi_RS_ConfigNZP_ApList_r14_DynamicOptional(&p->csi_RS_ConfigNZP_ApList_r14);
}

static void _serSysFreeCSI_RS_ConfigEMIMO2_r14_Value(union CSI_RS_ConfigEMIMO2_r14_Value* p, enum CSI_RS_ConfigEMIMO2_r14_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO2_r14_setup) {
		_serSysFreeCSI_RS_ConfigBeamformed_r14(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO2_r14(struct CSI_RS_ConfigEMIMO2_r14* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO2_r14_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(struct CSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO2_r14(&p->v);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_setup(struct CSI_RS_ConfigEMIMO_Hybrid_r14_setup* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO2_r14_CSI_RS_ConfigEMIMO_Hybrid_r14_setup_eMIMO_Type2_r14_Optional(&p->eMIMO_Type2_r14);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_Value(union CSI_RS_ConfigEMIMO_Hybrid_r14_Value* p, enum CSI_RS_ConfigEMIMO_Hybrid_r14_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_Hybrid_r14_setup) {
		_serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14(struct CSI_RS_ConfigEMIMO_Hybrid_r14* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(struct CSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(struct CSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430(&p->v);
}

static void _serSysFreeCSI_RS_ConfigNonPrecoded_v1480(struct CSI_RS_ConfigNonPrecoded_v1480* p)
{
	_serSysFreeCSI_RS_ConfigNZP_EMIMO_v1430_CSI_RS_ConfigNonPrecoded_v1480_csi_RS_ConfigNZP_EMIMO_v1480_Optional(&p->csi_RS_ConfigNZP_EMIMO_v1480);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1480_setup_Value(union CSI_RS_ConfigEMIMO_v1480_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1480_setup_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1480_setup_nonPrecoded_v1480) {
		_serSysFreeCSI_RS_ConfigNonPrecoded_v1480(&p->nonPrecoded_v1480);
	}
	if (d == CSI_RS_ConfigEMIMO_v1480_setup_beamformed_v1480) {
		_serSysFreeCSI_RS_ConfigBeamformed_v1430(&p->beamformed_v1480);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1480_setup(struct CSI_RS_ConfigEMIMO_v1480_setup* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1480_setup_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1480_Value(union CSI_RS_ConfigEMIMO_v1480_Value* p, enum CSI_RS_ConfigEMIMO_v1480_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1480_setup) {
		_serSysFreeCSI_RS_ConfigEMIMO_v1480_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1480(struct CSI_RS_ConfigEMIMO_v1480* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1480_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(struct CSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO_v1480(&p->v);
}

static void _serSysFreeP_C_AndCBSR_r15(struct P_C_AndCBSR_r15* p)
{
	if (p->codebookSubsetRestriction4_r15.v) {
		serFree(p->codebookSubsetRestriction4_r15.v);
	}
}

static void _serSysFreeP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(struct P_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serSysFreeP_C_AndCBSR_r15(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCSI_RS_ConfigNonPrecoded_v1530(struct CSI_RS_ConfigNonPrecoded_v1530* p)
{
	_serSysFreeP_C_AndCBSR_Pair_r15_CSI_RS_ConfigNonPrecoded_v1530_p_C_AndCBSRList_r15_Optional(&p->p_C_AndCBSRList_r15);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1530_setup_Value(union CSI_RS_ConfigEMIMO_v1530_setup_Value* p, enum CSI_RS_ConfigEMIMO_v1530_setup_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1530_setup_nonPrecoded_v1530) {
		_serSysFreeCSI_RS_ConfigNonPrecoded_v1530(&p->nonPrecoded_v1530);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1530_setup(struct CSI_RS_ConfigEMIMO_v1530_setup* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1530_setup_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1530_Value(union CSI_RS_ConfigEMIMO_v1530_Value* p, enum CSI_RS_ConfigEMIMO_v1530_Sel d)
{
	if (d == CSI_RS_ConfigEMIMO_v1530_setup) {
		_serSysFreeCSI_RS_ConfigEMIMO_v1530_setup(&p->setup);
	}
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1530(struct CSI_RS_ConfigEMIMO_v1530* p)
{
	_serSysFreeCSI_RS_ConfigEMIMO_v1530_Value(&p->v, p->d);
}

static void _serSysFreeCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(struct CSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCSI_RS_ConfigEMIMO_v1530(&p->v);
}

static void _serSysFreeCSI_Process_r11(struct CSI_Process_r11* p)
{
	if (p->p_C_AndCBSRList_r11.v) {
		for (size_t i2 = 0; i2 < p->p_C_AndCBSRList_r11.d; i2++) {
			_serSysFreeP_C_AndCBSR_r11(&p->p_C_AndCBSRList_r11.v[i2]);
		}
		serFree(p->p_C_AndCBSRList_r11.v);
	}
	_serSysFreeCSI_Process_r11_csi_IM_ConfigIdList_r12_csi_IM_ConfigIdList_r12_Optional(&p->csi_IM_ConfigIdList_r12);
	_serSysFreeCSI_RS_ConfigEMIMO_r13_CSI_Process_r11_eMIMO_Type_r13_Optional(&p->eMIMO_Type_r13);
	_serSysFreeCSI_RS_ConfigEMIMO_v1430_CSI_Process_r11_dummy_Optional(&p->dummy);
	_serSysFreeCSI_RS_ConfigEMIMO_Hybrid_r14_CSI_Process_r11_eMIMO_Hybrid_r14_Optional(&p->eMIMO_Hybrid_r14);
	_serSysFreeCSI_RS_ConfigEMIMO_v1480_CSI_Process_r11_eMIMO_Type_v1480_Optional(&p->eMIMO_Type_v1480);
	_serSysFreeCSI_RS_ConfigEMIMO_v1530_CSI_Process_r11_eMIMO_Type_v1530_Optional(&p->eMIMO_Type_v1530);
}

static void _serSysFreeCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(struct CSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeCSI_Process_r11(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeCQI_ReportBoth_r11(struct CQI_ReportBoth_r11* p)
{
	_serSysFreeCSI_IM_ConfigToReleaseList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToReleaseList_r11_Optional(&p->csi_IM_ConfigToReleaseList_r11);
	_serSysFreeCSI_IM_ConfigToAddModList_r11_CQI_ReportBoth_r11_csi_IM_ConfigToAddModList_r11_Optional(&p->csi_IM_ConfigToAddModList_r11);
	_serSysFreeCSI_ProcessToReleaseList_r11_CQI_ReportBoth_r11_csi_ProcessToReleaseList_r11_Optional(&p->csi_ProcessToReleaseList_r11);
	_serSysFreeCSI_ProcessToAddModList_r11_CQI_ReportBoth_r11_csi_ProcessToAddModList_r11_Optional(&p->csi_ProcessToAddModList_r11);
}

static void _serSysFreeCQI_ReportConfig_v1130(struct CQI_ReportConfig_v1130* p)
{
	_serSysFreeCQI_ReportPeriodic_v1130(&p->cqi_ReportPeriodic_v1130);
	_serSysFreeCQI_ReportBoth_r11(&p->cqi_ReportBoth_r11);
}

static void _serSysFreeCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(struct CQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCQI_ReportConfig_v1130(&p->v);
}

static void _serSysFreeCQI_ReportConfig_R10andLater_Type(struct CQI_ReportConfig_R10andLater_Type* p)
{
	_serSysFreeCQI_ReportConfig_v1130_cqi_ReportConfig_v1130_Optional(&p->cqi_ReportConfig_v1130);
}

static void _serSysFreeCQI_ReportConfig_Type_Value(union CQI_ReportConfig_Type_Value* p, enum CQI_ReportConfig_Type_Sel d)
{
	if (d == CQI_ReportConfig_Type_R10andLater) {
		_serSysFreeCQI_ReportConfig_R10andLater_Type(&p->R10andLater);
	}
}

static void _serSysFreeCQI_ReportConfig_Type(struct CQI_ReportConfig_Type* p)
{
	_serSysFreeCQI_ReportConfig_Type_Value(&p->v, p->d);
}

static void _serSysFreeCQI_ReportConfig_Type_CQI_ReportConfig_Optional(struct CQI_ReportConfig_Type_CQI_ReportConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCQI_ReportConfig_Type(&p->v);
}

static void _serSysFreePhysicalLayerConfigUL_Type(struct PhysicalLayerConfigUL_Type* p)
{
	_serSysFreePRACH_Config_Type_Prach_Optional(&p->Prach);
	_serSysFreePUCCH_Configuration_Type_Pucch_Optional(&p->Pucch);
	_serSysFreeSRS_UL_Config_Type_SRS_UL_Config_Optional(&p->SRS_UL_Config);
	_serSysFreeCQI_ReportConfig_Type_CQI_ReportConfig_Optional(&p->CQI_ReportConfig);
}

static void _serSysFreePhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(struct PhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional* p)
{
	if (!p->d) return;
	_serSysFreePhysicalLayerConfigUL_Type(&p->v);
}

static void _serSysFreeRACH_ConfigCommon_R8andLater_Type(struct RACH_ConfigCommon_R8andLater_Type* p)
{
	_serSysFreeRACH_ConfigCommon(&p->rach_ConfigCommon);
}

static void _serSysFreeRACH_ConfigCommon_Type_Value(union RACH_ConfigCommon_Type_Value* p, enum RACH_ConfigCommon_Type_Sel d)
{
	if (d == RACH_ConfigCommon_Type_R8andLater) {
		_serSysFreeRACH_ConfigCommon_R8andLater_Type(&p->R8andLater);
	}
}

static void _serSysFreeRACH_ConfigCommon_Type(struct RACH_ConfigCommon_Type* p)
{
	_serSysFreeRACH_ConfigCommon_Type_Value(&p->v, p->d);
}

static void _serSysFreeRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(struct RACH_ConfigCommon_Type_RACH_ConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serSysFreeRACH_ConfigCommon_Type(&p->v);
}

static void _serSysFreeRandomAccessResponse_Type_Value(union RandomAccessResponse_Type_Value* p, enum RandomAccessResponse_Type_Sel d)
{
	if (d == RandomAccessResponse_Type_List) {
		if (p->List.v) {
			for (size_t i2 = 0; i2 < p->List.d; i2++) {
			}
			serFree(p->List.v);
		}
	}
}

static void _serSysFreeRandomAccessResponse_Type(struct RandomAccessResponse_Type* p)
{
	_serSysFreeRandomAccessResponse_Type_Value(&p->v, p->d);
}

static void _serSysFreeRandomAccessResponseCtrl_Type(struct RandomAccessResponseCtrl_Type* p)
{
	_serSysFreeDciDlInfoCommon_Type(&p->DciInfo);
	_serSysFreeRandomAccessResponse_Type(&p->Rar);
}

static void _serSysFreeRandomAccessResponseConfig_Type_Value(union RandomAccessResponseConfig_Type_Value* p, enum RandomAccessResponseConfig_Type_Sel d)
{
	if (d == RandomAccessResponseConfig_Type_Ctrl) {
		_serSysFreeRandomAccessResponseCtrl_Type(&p->Ctrl);
	}
	if (d == RandomAccessResponseConfig_Type_Ctrl_CRC_Error) {
		_serSysFreeRandomAccessResponseCtrl_Type(&p->Ctrl_CRC_Error);
	}
}

static void _serSysFreeRandomAccessResponseConfig_Type(struct RandomAccessResponseConfig_Type* p)
{
	_serSysFreeRandomAccessResponseConfig_Type_Value(&p->v, p->d);
}

static void _serSysFreeContentionResolution_ContainedId_Type_Value(union ContentionResolution_ContainedId_Type_Value* p, enum ContentionResolution_ContainedId_Type_Sel d)
{
	if (d == ContentionResolution_ContainedId_Type_XorMask) {
		if (p->XorMask.v) {
			serFree(p->XorMask.v);
		}
	}
}

static void _serSysFreeContentionResolution_ContainedId_Type(struct ContentionResolution_ContainedId_Type* p)
{
	_serSysFreeContentionResolution_ContainedId_Type_Value(&p->v, p->d);
}

static void _serSysFreeContentionResolution_ContainedDlschSdu_Type_Value(union ContentionResolution_ContainedDlschSdu_Type_Value* p, enum ContentionResolution_ContainedDlschSdu_Type_Sel d)
{
	if (d == ContentionResolution_ContainedDlschSdu_Type_RlcPduCCCH) {
		if (p->RlcPduCCCH.v) {
			serFree(p->RlcPduCCCH.v);
		}
	}
	if (d == ContentionResolution_ContainedDlschSdu_Type_PdcpSduDCCH) {
		if (p->PdcpSduDCCH.v) {
			serFree(p->PdcpSduDCCH.v);
		}
	}
}

static void _serSysFreeContentionResolution_ContainedDlschSdu_Type(struct ContentionResolution_ContainedDlschSdu_Type* p)
{
	_serSysFreeContentionResolution_ContainedDlschSdu_Type_Value(&p->v, p->d);
}

static void _serSysFreeTCRNTI_ContentionResolutionMacPdu_Type(struct TCRNTI_ContentionResolutionMacPdu_Type* p)
{
	_serSysFreeContentionResolution_ContainedId_Type(&p->ContainedId);
	_serSysFreeContentionResolution_ContainedDlschSdu_Type(&p->ContainedRlcPdu);
}

static void _serSysFreeTCRNTI_ContentionResolutionCtrl_Type_Value(union TCRNTI_ContentionResolutionCtrl_Type_Value* p, enum TCRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu) {
		_serSysFreeTCRNTI_ContentionResolutionMacPdu_Type(&p->MacPdu);
	}
	if (d == TCRNTI_ContentionResolutionCtrl_Type_MacPdu_CRC_Error) {
		_serSysFreeTCRNTI_ContentionResolutionMacPdu_Type(&p->MacPdu_CRC_Error);
	}
}

static void _serSysFreeTCRNTI_ContentionResolutionCtrl_Type(struct TCRNTI_ContentionResolutionCtrl_Type* p)
{
	_serSysFreeTCRNTI_ContentionResolutionCtrl_Type_Value(&p->v, p->d);
}

static void _serSysFreeDciUlInfo_Type(struct DciUlInfo_Type* p)
{
	if (p->TransRetransmissionList.v) {
		for (size_t i2 = 0; i2 < p->TransRetransmissionList.d; i2++) {
		}
		serFree(p->TransRetransmissionList.v);
	}
}

static void _serSysFreeCRNTI_ContentionResolutionCtrl_Type_Value(union CRNTI_ContentionResolutionCtrl_Type_Value* p, enum CRNTI_ContentionResolutionCtrl_Type_Sel d)
{
	if (d == CRNTI_ContentionResolutionCtrl_Type_AutomaticGrant) {
		_serSysFreeDciUlInfo_Type(&p->AutomaticGrant);
	}
}

static void _serSysFreeCRNTI_ContentionResolutionCtrl_Type(struct CRNTI_ContentionResolutionCtrl_Type* p)
{
	_serSysFreeCRNTI_ContentionResolutionCtrl_Type_Value(&p->v, p->d);
}

static void _serSysFreeContentionResolutionCtrl_Type_Value(union ContentionResolutionCtrl_Type_Value* p, enum ContentionResolutionCtrl_Type_Sel d)
{
	if (d == ContentionResolutionCtrl_Type_TCRNTI_Based) {
		_serSysFreeTCRNTI_ContentionResolutionCtrl_Type(&p->TCRNTI_Based);
	}
	if (d == ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serSysFreeCRNTI_ContentionResolutionCtrl_Type(&p->CRNTI_Based);
	}
}

static void _serSysFreeContentionResolutionCtrl_Type(struct ContentionResolutionCtrl_Type* p)
{
	_serSysFreeContentionResolutionCtrl_Type_Value(&p->v, p->d);
}

static void _serSysFreeRachProcedure_Type(struct RachProcedure_Type* p)
{
	_serSysFreeRandomAccessResponseConfig_Type(&p->RAResponse);
	_serSysFreeContentionResolutionCtrl_Type(&p->ContentionResolutionCtrl);
}

static void _serSysFreeRachProcedureList_Type_RachProcedureList_Optional(struct RachProcedureList_Type_RachProcedureList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeRachProcedure_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeRachProcedureConfig_Type(struct RachProcedureConfig_Type* p)
{
	_serSysFreeRACH_ConfigCommon_Type_RACH_ConfigCommon_Optional(&p->RACH_ConfigCommon);
	_serSysFreeRachProcedureList_Type_RachProcedureList_Optional(&p->RachProcedureList);
}

static void _serSysFreeRachProcedureConfig_Type_RachProcedureConfig_Optional(struct RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeRachProcedureConfig_Type(&p->v);
}

static void _serSysFreeRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(struct RedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeMIMO_DciDlInfo_Type(struct MIMO_DciDlInfo_Type* p)
{
	_serSysFreeRedundancyVersionListDL_Type_RedundancyVersionList_2ndCW_Optional(&p->RedundancyVersionList_2ndCW);
}

static void _serSysFreeMIMO_DciDlInfo_Type_MimoInfo_Optional(struct MIMO_DciDlInfo_Type_MimoInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeMIMO_DciDlInfo_Type(&p->v);
}

static void _serSysFreeDciDlInfoExplicit_Type(struct DciDlInfoExplicit_Type* p)
{
	if (p->RedundancyVersionList.v) {
		serFree(p->RedundancyVersionList.v);
	}
	_serSysFreeMIMO_DciDlInfo_Type_MimoInfo_Optional(&p->MimoInfo);
}

static void _serSysFreeDciDlInfo_Type_Value(union DciDlInfo_Type_Value* p, enum DciDlInfo_Type_Sel d)
{
	if (d == DciDlInfo_Type_Auto) {
		_serSysFreeDciDlInfoCommon_Type(&p->Auto);
	}
	if (d == DciDlInfo_Type_Explicit) {
		_serSysFreeDciDlInfoExplicit_Type(&p->Explicit);
	}
}

static void _serSysFreeDciDlInfo_Type(struct DciDlInfo_Type* p)
{
	_serSysFreeDciDlInfo_Type_Value(&p->v, p->d);
}

static void _serSysFreeDciDlInfo_Type_DciInfo_Optional(struct DciDlInfo_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDciDlInfo_Type(&p->v);
}

static void _serSysFreeBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(struct BIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeAntennaInfoDedicated_r10(struct AntennaInfoDedicated_r10* p)
{
	_serSysFreeBIT_STRING_AntennaInfoDedicated_r10_codebookSubsetRestriction_r10_Optional(&p->codebookSubsetRestriction_r10);
}

static void _serSysFreeAntennaInfoDedicated_R10andLater_Type(struct AntennaInfoDedicated_R10andLater_Type* p)
{
	_serSysFreeAntennaInfoDedicated_r10(&p->antennaInfo);
}

static void _serSysFreeAntennaInfoDedicated_Type_Value(union AntennaInfoDedicated_Type_Value* p, enum AntennaInfoDedicated_Type_Sel d)
{
	if (d == AntennaInfoDedicated_Type_R10andLater) {
		_serSysFreeAntennaInfoDedicated_R10andLater_Type(&p->R10andLater);
	}
}

static void _serSysFreeAntennaInfoDedicated_Type(struct AntennaInfoDedicated_Type* p)
{
	_serSysFreeAntennaInfoDedicated_Type_Value(&p->v, p->d);
}

static void _serSysFreeAntennaInfoDedicated_Type_AntennaInfo_Optional(struct AntennaInfoDedicated_Type_AntennaInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeAntennaInfoDedicated_Type(&p->v);
}

static void _serSysFreeHarqProcessConfigDL_Type_Value(union HarqProcessConfigDL_Type_Value* p, enum HarqProcessConfigDL_Type_Sel d)
{
	if (d == HarqProcessConfigDL_Type_SpecificSubset) {
		if (p->SpecificSubset.v) {
			serFree(p->SpecificSubset.v);
		}
	}
}

static void _serSysFreeHarqProcessConfigDL_Type(struct HarqProcessConfigDL_Type* p)
{
	_serSysFreeHarqProcessConfigDL_Type_Value(&p->v, p->d);
}

static void _serSysFreeHarqProcessConfigDL_Type_HarqProcessConfig_Optional(struct HarqProcessConfigDL_Type_HarqProcessConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeHarqProcessConfigDL_Type(&p->v);
}

static void _serSysFreeCcchDcchDtchConfigDL_Type(struct CcchDcchDtchConfigDL_Type* p)
{
	_serSysFreeDciDlInfo_Type_DciInfo_Optional(&p->DciInfo);
	_serSysFreeAntennaInfoDedicated_Type_AntennaInfo_Optional(&p->AntennaInfo);
	_serSysFreeHarqProcessConfigDL_Type_HarqProcessConfig_Optional(&p->HarqProcessConfig);
}

static void _serSysFreeCcchDcchDtchConfigDL_Type_DL_Optional(struct CcchDcchDtchConfigDL_Type_DL_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCcchDcchDtchConfigDL_Type(&p->v);
}

static void _serSysFreeDciUlInfo_Type_DciInfo_Optional(struct DciUlInfo_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serSysFreeDciUlInfo_Type(&p->v);
}

static void _serSysFreeCcchDcchDtchConfigUL_Type(struct CcchDcchDtchConfigUL_Type* p)
{
	_serSysFreeDciUlInfo_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serSysFreeCcchDcchDtchConfigUL_Type_UL_Optional(struct CcchDcchDtchConfigUL_Type_UL_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCcchDcchDtchConfigUL_Type(&p->v);
}

static void _serSysFreeCcchDcchDtchConfig_Type(struct CcchDcchDtchConfig_Type* p)
{
	_serSysFreeCcchDcchDtchConfigDL_Type_DL_Optional(&p->DL);
	_serSysFreeCcchDcchDtchConfigUL_Type_UL_Optional(&p->UL);
}

static void _serSysFreeCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(struct CcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeCcchDcchDtchConfig_Type(&p->v);
}

static void _serSysFreePrimaryCellInfo_Type(struct PrimaryCellInfo_Type* p)
{
	if (p->AssociatedScellList.v) {
		serFree(p->AssociatedScellList.v);
	}
}

static void _serSysFreePSCellInfo_Type(struct PSCellInfo_Type* p)
{
	if (p->AssociatedScellList.v) {
		serFree(p->AssociatedScellList.v);
	}
}

static void _serSysFreeServingCellConfig_Type_Value(union ServingCellConfig_Type_Value* p, enum ServingCellConfig_Type_Sel d)
{
	if (d == ServingCellConfig_Type_PCell) {
		_serSysFreePrimaryCellInfo_Type(&p->PCell);
	}
	if (d == ServingCellConfig_Type_PSCell) {
		_serSysFreePSCellInfo_Type(&p->PSCell);
	}
}

static void _serSysFreeServingCellConfig_Type(struct ServingCellConfig_Type* p)
{
	_serSysFreeServingCellConfig_Type_Value(&p->v, p->d);
}

static void _serSysFreeServingCellConfig_Type_ServingCellConfig_Optional(struct ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeServingCellConfig_Type(&p->v);
}

static void _serSysFreeBIT_STRING_LowestIndexOfChannelAllocation_Optional(struct BIT_STRING_LowestIndexOfChannelAllocation_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreeSL_Sci1Config_Type(struct SL_Sci1Config_Type* p)
{
	if (p->FreqResourceAllocation.v) {
		serFree(p->FreqResourceAllocation.v);
	}
}

static void _serSysFreeSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(struct SL_Sci1Config_Type_SL_SCI1_Scheduling_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSL_Sci1Config_Type(&p->v);
}

static void _serSysFreeSci1SchedulingConfig_Type(struct Sci1SchedulingConfig_Type* p)
{
	_serSysFreeBIT_STRING_LowestIndexOfChannelAllocation_Optional(&p->LowestIndexOfChannelAllocation);
	_serSysFreeSL_Sci1Config_Type_SL_SCI1_Scheduling_Optional(&p->SL_SCI1_Scheduling);
}

static void _serSysFreeSciSchedulingConfig_Type_Value(union SciSchedulingConfig_Type_Value* p, enum SciSchedulingConfig_Type_Sel d)
{
	if (d == SciSchedulingConfig_Type_SCI1) {
		_serSysFreeSci1SchedulingConfig_Type(&p->SCI1);
	}
}

static void _serSysFreeSciSchedulingConfig_Type(struct SciSchedulingConfig_Type* p)
{
	_serSysFreeSciSchedulingConfig_Type_Value(&p->v, p->d);
}

static void _serSysFreeSciSchedulingConfig_Type_SciSchedulingConfig_Optional(struct SciSchedulingConfig_Type_SciSchedulingConfig_Optional* p)
{
	if (!p->d) return;
	_serSysFreeSciSchedulingConfig_Type(&p->v);
}

static void _serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup* p)
{
	if (p->subframeConfigList_r12.v) {
		for (size_t i1 = 0; i1 < p->subframeConfigList_r12.d; i1++) {
		}
		serFree(p->subframeConfigList_r12.v);
	}
}

static void _serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(union EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value* p, enum EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Sel d)
{
	if (d == EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup) {
		_serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_setup(&p->setup);
	}
}

static void _serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(struct EIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250* p)
{
	_serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250_Value(&p->v, p->d);
}

static void _serSysFreeEIMTA_MainConfigServCell_r12_setup(struct EIMTA_MainConfigServCell_r12_setup* p)
{
	_serSysFreeEIMTA_MainConfigServCell_r12_setup_mbsfn_SubframeConfigList_v1250(&p->mbsfn_SubframeConfigList_v1250);
}

static void _serSysFreeEIMTA_MainConfigServCell_r12_Value(union EIMTA_MainConfigServCell_r12_Value* p, enum EIMTA_MainConfigServCell_r12_Sel d)
{
	if (d == EIMTA_MainConfigServCell_r12_setup) {
		_serSysFreeEIMTA_MainConfigServCell_r12_setup(&p->setup);
	}
}

static void _serSysFreeEIMTA_MainConfigServCell_r12(struct EIMTA_MainConfigServCell_r12* p)
{
	_serSysFreeEIMTA_MainConfigServCell_r12_Value(&p->v, p->d);
}

static void _serSysFreeEIMTA_Config_Type(struct EIMTA_Config_Type* p)
{
	_serSysFreeEIMTA_MainConfigServCell_r12(&p->EIMTA_MainConfigServCell_r12);
}

static void _serSysFreeEIMTA_Config_Type_EIMTA_Config_Optional(struct EIMTA_Config_Type_EIMTA_Config_Optional* p)
{
	if (!p->d) return;
	_serSysFreeEIMTA_Config_Type(&p->v);
}

static void _serSysFreeActiveCellConfig_Type(struct ActiveCellConfig_Type* p)
{
	_serSysFreePhysicalLayerConfigUL_Type_PhysicalLayerConfigUL_Optional(&p->PhysicalLayerConfigUL);
	_serSysFreeRachProcedureConfig_Type_RachProcedureConfig_Optional(&p->RachProcedureConfig);
	_serSysFreeCcchDcchDtchConfig_Type_CcchDcchDtchConfig_Optional(&p->CcchDcchDtchConfig);
	_serSysFreeServingCellConfig_Type_ServingCellConfig_Optional(&p->ServingCellConfig);
	_serSysFreeSciSchedulingConfig_Type_SciSchedulingConfig_Optional(&p->SciSchedulingConfig);
	_serSysFreeEIMTA_Config_Type_EIMTA_Config_Optional(&p->EIMTA_Config);
}

static void _serSysFreeActiveCellConfig_Type_Active_Optional(struct ActiveCellConfig_Type_Active_Optional* p)
{
	if (!p->d) return;
	_serSysFreeActiveCellConfig_Type(&p->v);
}

static void _serSysFreeCellConfigInfo_Type(struct CellConfigInfo_Type* p)
{
	_serSysFreeBasicCellConfig_Type_Basic_Optional(&p->Basic);
	_serSysFreeActiveCellConfig_Type_Active_Optional(&p->Active);
}

static void _serSysFreeCellConfigRequest_Type_Value(union CellConfigRequest_Type_Value* p, enum CellConfigRequest_Type_Sel d)
{
	if (d == CellConfigRequest_Type_AddOrReconfigure) {
		_serSysFreeCellConfigInfo_Type(&p->AddOrReconfigure);
	}
}

static void _serSysFreeCellConfigRequest_Type(struct CellConfigRequest_Type* p)
{
	_serSysFreeCellConfigRequest_Type_Value(&p->v, p->d);
}

static void _serSysFreeRadioBearer_Type(struct RadioBearer_Type* p)
{
	_serSysFreeRadioBearerId_Type(&p->Id);
}

static void _serSysFreeSecurityActTime_Type(struct SecurityActTime_Type* p)
{
	_serSysFreeRadioBearerId_Type(&p->RadioBearerId);
}

static void _serSysFreeSecurityActTimeList_Type_ActTimeList_Optional(struct SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreeSecurityActTime_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeAS_IntegrityInfo_Type(struct AS_IntegrityInfo_Type* p)
{
	_serSysFreeSecurityActTimeList_Type_ActTimeList_Optional(&p->ActTimeList);
}

static void _serSysFreeAS_IntegrityInfo_Type_Integrity_Optional(struct AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	if (!p->d) return;
	_serSysFreeAS_IntegrityInfo_Type(&p->v);
}

static void _serSysFreeAS_CipheringInfo_Type(struct AS_CipheringInfo_Type* p)
{
	if (p->ActTimeList.v) {
		for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
			_serSysFreeSecurityActTime_Type(&p->ActTimeList.v[i1]);
		}
		serFree(p->ActTimeList.v);
	}
}

static void _serSysFreeAS_CipheringInfo_Type_Ciphering_Optional(struct AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	if (!p->d) return;
	_serSysFreeAS_CipheringInfo_Type(&p->v);
}

static void _serSysFreeAS_SecStartRestart_Type(struct AS_SecStartRestart_Type* p)
{
	_serSysFreeAS_IntegrityInfo_Type_Integrity_Optional(&p->Integrity);
	_serSysFreeAS_CipheringInfo_Type_Ciphering_Optional(&p->Ciphering);
}

static void _serSysFreeAS_Security_Type_Value(union AS_Security_Type_Value* p, enum AS_Security_Type_Sel d)
{
	if (d == AS_Security_Type_StartRestart) {
		_serSysFreeAS_SecStartRestart_Type(&p->StartRestart);
	}
}

static void _serSysFreeAS_Security_Type(struct AS_Security_Type* p)
{
	_serSysFreeAS_Security_Type_Value(&p->v, p->d);
}

static void _serSysFreePagingUE_Identity_Value(union PagingUE_Identity_Value* p, enum PagingUE_Identity_Sel d)
{
	if (d == PagingUE_Identity_imsi) {
		if (p->imsi.v) {
			serFree(p->imsi.v);
		}
	}
}

static void _serSysFreePagingUE_Identity(struct PagingUE_Identity* p)
{
	_serSysFreePagingUE_Identity_Value(&p->v, p->d);
}

static void _serSysFreePagingRecord(struct PagingRecord* p)
{
	_serSysFreePagingUE_Identity(&p->ue_Identity);
}

static void _serSysFreePagingRecordList_Paging_pagingRecordList_Optional(struct PagingRecordList_Paging_pagingRecordList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serSysFreePagingRecord(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serSysFreeOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(struct PagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serSysFreePaging_v1610_IEs(struct Paging_v1610_IEs* p)
{
	_serSysFreePagingRecordList_v1610_Paging_v1610_IEs_pagingRecordList_v1610_Optional(&p->pagingRecordList_v1610);
}

static void _serSysFreePaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(struct Paging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v1610_IEs(&p->v);
}

static void _serSysFreePaging_v1530_IEs(struct Paging_v1530_IEs* p)
{
	_serSysFreePaging_v1610_IEs_Paging_v1530_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(struct Paging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v1530_IEs(&p->v);
}

static void _serSysFreePaging_v1310_IEs(struct Paging_v1310_IEs* p)
{
	_serSysFreePaging_v1530_IEs_Paging_v1310_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(struct Paging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v1310_IEs(&p->v);
}

static void _serSysFreePaging_v1130_IEs(struct Paging_v1130_IEs* p)
{
	_serSysFreePaging_v1310_IEs_Paging_v1130_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(struct Paging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v1130_IEs(&p->v);
}

static void _serSysFreePaging_v920_IEs(struct Paging_v920_IEs* p)
{
	_serSysFreePaging_v1130_IEs_Paging_v920_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(struct Paging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v920_IEs(&p->v);
}

static void _serSysFreePaging_v890_IEs(struct Paging_v890_IEs* p)
{
	_serSysFreeOCTET_STRING_Paging_v890_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serSysFreePaging_v920_IEs_Paging_v890_IEs_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePaging_v890_IEs_Paging_nonCriticalExtension_Optional(struct Paging_v890_IEs_Paging_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serSysFreePaging_v890_IEs(&p->v);
}

static void _serSysFreePaging(struct Paging* p)
{
	_serSysFreePagingRecordList_Paging_pagingRecordList_Optional(&p->pagingRecordList);
	_serSysFreePaging_v890_IEs_Paging_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serSysFreePCCH_MessageType_c1_Value(union PCCH_MessageType_c1_Value* p, enum PCCH_MessageType_c1_Sel d)
{
	if (d == PCCH_MessageType_c1_paging) {
		_serSysFreePaging(&p->paging);
	}
}

static void _serSysFreePCCH_MessageType_c1(struct PCCH_MessageType_c1* p)
{
	_serSysFreePCCH_MessageType_c1_Value(&p->v, p->d);
}

static void _serSysFreePCCH_MessageType_Value(union PCCH_MessageType_Value* p, enum PCCH_MessageType_Sel d)
{
	if (d == PCCH_MessageType_c1) {
		_serSysFreePCCH_MessageType_c1(&p->c1);
	}
}

static void _serSysFreePCCH_MessageType(struct PCCH_MessageType* p)
{
	_serSysFreePCCH_MessageType_Value(&p->v, p->d);
}

static void _serSysFreePCCH_Message(struct PCCH_Message* p)
{
	_serSysFreePCCH_MessageType(&p->message);
}

static void _serSysFreeSubframeOffsetList_Type_SubframeOffsetList_Optional(struct SubframeOffsetList_Type_SubframeOffsetList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serSysFreePagingTrigger_Type(struct PagingTrigger_Type* p)
{
	_serSysFreePCCH_Message(&p->Paging);
	_serSysFreeSubframeOffsetList_Type_SubframeOffsetList_Optional(&p->SubframeOffsetList);
}

static void _serSysFreePdcpCountGetReq_Type_Value(union PdcpCountGetReq_Type_Value* p, enum PdcpCountGetReq_Type_Sel d)
{
	if (d == PdcpCountGetReq_Type_SingleRB) {
		_serSysFreeRadioBearerId_Type(&p->SingleRB);
	}
}

static void _serSysFreePdcpCountGetReq_Type(struct PdcpCountGetReq_Type* p)
{
	_serSysFreePdcpCountGetReq_Type_Value(&p->v, p->d);
}

static void _serSysFreePdcpCountInfo_Type(struct PdcpCountInfo_Type* p)
{
	_serSysFreeRadioBearerId_Type(&p->RadioBearerId);
}

static void _serSysFreePdcp_CountReq_Type_Value(union Pdcp_CountReq_Type_Value* p, enum Pdcp_CountReq_Type_Sel d)
{
	if (d == Pdcp_CountReq_Type_Get) {
		_serSysFreePdcpCountGetReq_Type(&p->Get);
	}
	if (d == Pdcp_CountReq_Type_Set) {
		if (p->Set.v) {
			for (size_t i1 = 0; i1 < p->Set.d; i1++) {
				_serSysFreePdcpCountInfo_Type(&p->Set.v[i1]);
			}
			serFree(p->Set.v);
		}
	}
}

static void _serSysFreePdcp_CountReq_Type(struct Pdcp_CountReq_Type* p)
{
	_serSysFreePdcp_CountReq_Type_Value(&p->v, p->d);
}

static void _serSysFreeSystemRequest_Type_Value(union SystemRequest_Type_Value* p, enum SystemRequest_Type_Sel d)
{
	if (d == SystemRequest_Type_Cell) {
		_serSysFreeCellConfigRequest_Type(&p->Cell);
	}
	if (d == SystemRequest_Type_CellAttenuationList) {
		if (p->CellAttenuationList.v) {
			for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			}
			serFree(p->CellAttenuationList.v);
		}
	}
	if (d == SystemRequest_Type_RadioBearerList) {
		if (p->RadioBearerList.v) {
			for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
				_serSysFreeRadioBearer_Type(&p->RadioBearerList.v[i1]);
			}
			serFree(p->RadioBearerList.v);
		}
	}
	if (d == SystemRequest_Type_AS_Security) {
		_serSysFreeAS_Security_Type(&p->AS_Security);
	}
	if (d == SystemRequest_Type_Paging) {
		_serSysFreePagingTrigger_Type(&p->Paging);
	}
	if (d == SystemRequest_Type_PdcpCount) {
		_serSysFreePdcp_CountReq_Type(&p->PdcpCount);
	}
}

static void _serSysFreeSystemRequest_Type(struct SystemRequest_Type* p)
{
	_serSysFreeSystemRequest_Type_Value(&p->v, p->d);
}

static void _serSysFreeSYSTEM_CTRL_REQ(struct SYSTEM_CTRL_REQ* p)
{
	_serSysFreeReqAspCommonPart_Type(&p->Common);
	_serSysFreeSystemRequest_Type(&p->Request);
}

void serSysProcessFreeSrv(struct SYSTEM_CTRL_REQ* FromSS)
{
	if (FromSS) {
		_serSysFreeSYSTEM_CTRL_REQ(FromSS);
		serFree(FromSS);
	}
}

static int _serSysEncConfirmationResult_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ConfirmationResult_Type_Value* p, enum ConfirmationResult_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ConfirmationResult_Type_Success) {
		HTON_8(&_buffer[*_lidx], p->Success, _lidx);
	}
	if (d == ConfirmationResult_Type_Error) {
		HTON_32(&_buffer[*_lidx], p->Error, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncConfirmationResult_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ConfirmationResult_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncConfirmationResult_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncCnfAspCommonPart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CnfAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncRoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serSysEncConfirmationResult_Type(_buffer, _size, _lidx, &p->Result);

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcp_CountCnf_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union Pdcp_CountCnf_Type_Value* p, enum Pdcp_CountCnf_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pdcp_CountCnf_Type_Get) {
		HTON_32(&_buffer[*_lidx], p->Get.d, _lidx);
		for (size_t i1 = 0; i1 < p->Get.d; i1++) {
			_serSysEncPdcpCountInfo_Type(_buffer, _size, _lidx, &p->Get.v[i1]);
		}
	}
	if (d == Pdcp_CountCnf_Type_Set) {
		HTON_8(&_buffer[*_lidx], p->Set, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncPdcp_CountCnf_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Pdcp_CountCnf_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncPdcp_CountCnf_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemConfirm_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemConfirm_Type_Value* p, enum SystemConfirm_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemConfirm_Type_Cell) {
		HTON_8(&_buffer[*_lidx], p->Cell, _lidx);
	}
	if (d == SystemConfirm_Type_CellAttenuationList) {
		HTON_8(&_buffer[*_lidx], p->CellAttenuationList, _lidx);
	}
	if (d == SystemConfirm_Type_RadioBearerList) {
		HTON_8(&_buffer[*_lidx], p->RadioBearerList, _lidx);
	}
	if (d == SystemConfirm_Type_EnquireTiming) {
		HTON_8(&_buffer[*_lidx], p->EnquireTiming, _lidx);
	}
	if (d == SystemConfirm_Type_AS_Security) {
		HTON_8(&_buffer[*_lidx], p->AS_Security, _lidx);
	}
	if (d == SystemConfirm_Type_Sps) {
		HTON_8(&_buffer[*_lidx], p->Sps, _lidx);
	}
	if (d == SystemConfirm_Type_Paging) {
		HTON_8(&_buffer[*_lidx], p->Paging, _lidx);
	}
	if (d == SystemConfirm_Type_L1MacIndCtrl) {
		HTON_8(&_buffer[*_lidx], p->L1MacIndCtrl, _lidx);
	}
	if (d == SystemConfirm_Type_RlcIndCtrl) {
		HTON_8(&_buffer[*_lidx], p->RlcIndCtrl, _lidx);
	}
	if (d == SystemConfirm_Type_PdcpCount) {
		_serSysEncPdcp_CountCnf_Type(_buffer, _size, _lidx, &p->PdcpCount);
	}
	if (d == SystemConfirm_Type_PdcpHandoverControl) {
		HTON_8(&_buffer[*_lidx], p->PdcpHandoverControl, _lidx);
	}
	if (d == SystemConfirm_Type_L1_TestMode) {
		HTON_8(&_buffer[*_lidx], p->L1_TestMode, _lidx);
	}
	if (d == SystemConfirm_Type_PdcchOrder) {
		HTON_8(&_buffer[*_lidx], p->PdcchOrder, _lidx);
	}
	if (d == SystemConfirm_Type_ActivateScell) {
		HTON_8(&_buffer[*_lidx], p->ActivateScell, _lidx);
	}
	if (d == SystemConfirm_Type_MbmsConfig) {
		HTON_8(&_buffer[*_lidx], p->MbmsConfig, _lidx);
	}
	if (d == SystemConfirm_Type_PDCCH_MCCH_ChangeNotification) {
		HTON_8(&_buffer[*_lidx], p->PDCCH_MCCH_ChangeNotification, _lidx);
	}
	if (d == SystemConfirm_Type_MSI_Config) {
		HTON_8(&_buffer[*_lidx], p->MSI_Config, _lidx);
	}
	if (d == SystemConfirm_Type_UE_Cat_Info) {
		HTON_8(&_buffer[*_lidx], p->UE_Cat_Info, _lidx);
	}
	if (d == SystemConfirm_Type_OCNG_Config) {
		HTON_8(&_buffer[*_lidx], p->OCNG_Config, _lidx);
	}
	if (d == SystemConfirm_Type_DirectIndicationInfo) {
		HTON_8(&_buffer[*_lidx], p->DirectIndicationInfo, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysEncSystemConfirm_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemConfirm_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serSysEncSystemConfirm_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysEncSYSTEM_CTRL_CNF(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SYSTEM_CTRL_CNF* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncCnfAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serSysEncSystemConfirm_Type(_buffer, _size, _lidx, &p->Confirm);

	return SIDL_STATUS_OK;
}

int serSysProcessEncSrv(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SYSTEM_CTRL_CNF* ToSS)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysEncSYSTEM_CTRL_CNF(_buffer, _size, _lidx, ToSS);

	return SIDL_STATUS_OK;
}

static int _serSysDecConfirmationResult_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ConfirmationResult_Type_Value* p, enum ConfirmationResult_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ConfirmationResult_Type_Success) {
		NTOH_8(p->Success, &_buffer[*_lidx], _lidx);
	}
	if (d == ConfirmationResult_Type_Error) {
		NTOH_32(p->Error, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecConfirmationResult_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ConfirmationResult_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ConfirmationResult_Type_Sel)_tmp;
	}
	_serSysDecConfirmationResult_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecCnfAspCommonPart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct CnfAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (EUTRA_CellId_Type)_tmp;
	}
	_serSysDecRoutingInfo_Type(_buffer, _size, _lidx, _mem, &p->RoutingInfo);
	_serSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serSysDecConfirmationResult_Type(_buffer, _size, _lidx, &p->Result);

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcp_CountCnf_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union Pdcp_CountCnf_Type_Value* p, enum Pdcp_CountCnf_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == Pdcp_CountCnf_Type_Get) {
		NTOH_32(p->Get.d, &_buffer[*_lidx], _lidx);
		p->Get.v = serMalloc(_mem, p->Get.d * sizeof(struct PdcpCountInfo_Type));
		for (size_t i1 = 0; i1 < p->Get.d; i1++) {
			_serSysDecPdcpCountInfo_Type(_buffer, _size, _lidx, _mem, &p->Get.v[i1]);
		}
	}
	if (d == Pdcp_CountCnf_Type_Set) {
		NTOH_8(p->Set, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecPdcp_CountCnf_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct Pdcp_CountCnf_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum Pdcp_CountCnf_Type_Sel)_tmp;
	}
	_serSysDecPdcp_CountCnf_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemConfirm_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SystemConfirm_Type_Value* p, enum SystemConfirm_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemConfirm_Type_Cell) {
		NTOH_8(p->Cell, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_CellAttenuationList) {
		NTOH_8(p->CellAttenuationList, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_RadioBearerList) {
		NTOH_8(p->RadioBearerList, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_EnquireTiming) {
		NTOH_8(p->EnquireTiming, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_AS_Security) {
		NTOH_8(p->AS_Security, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_Sps) {
		NTOH_8(p->Sps, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_Paging) {
		NTOH_8(p->Paging, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_L1MacIndCtrl) {
		NTOH_8(p->L1MacIndCtrl, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_RlcIndCtrl) {
		NTOH_8(p->RlcIndCtrl, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_PdcpCount) {
		_serSysDecPdcp_CountCnf_Type(_buffer, _size, _lidx, _mem, &p->PdcpCount);
	}
	if (d == SystemConfirm_Type_PdcpHandoverControl) {
		NTOH_8(p->PdcpHandoverControl, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_L1_TestMode) {
		NTOH_8(p->L1_TestMode, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_PdcchOrder) {
		NTOH_8(p->PdcchOrder, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_ActivateScell) {
		NTOH_8(p->ActivateScell, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_MbmsConfig) {
		NTOH_8(p->MbmsConfig, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_PDCCH_MCCH_ChangeNotification) {
		NTOH_8(p->PDCCH_MCCH_ChangeNotification, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_MSI_Config) {
		NTOH_8(p->MSI_Config, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_UE_Cat_Info) {
		NTOH_8(p->UE_Cat_Info, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_OCNG_Config) {
		NTOH_8(p->OCNG_Config, &_buffer[*_lidx], _lidx);
	}
	if (d == SystemConfirm_Type_DirectIndicationInfo) {
		NTOH_8(p->DirectIndicationInfo, &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serSysDecSystemConfirm_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SystemConfirm_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemConfirm_Type_Sel)_tmp;
	}
	_serSysDecSystemConfirm_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serSysDecSYSTEM_CTRL_CNF(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SYSTEM_CTRL_CNF* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serSysDecCnfAspCommonPart_Type(_buffer, _size, _lidx, _mem, &p->Common);
	_serSysDecSystemConfirm_Type(_buffer, _size, _lidx, _mem, &p->Confirm);

	return SIDL_STATUS_OK;
}

int serSysProcessDecClt(const unsigned char* _buffer, size_t _size, unsigned char* _arena, size_t _aSize, struct SYSTEM_CTRL_CNF** ToSS)
{
	(void)_size; // TODO: generate boundaries checking

	serMem_t _mem = serMemInit(_arena, _aSize);

	size_t __lidx = 0;
	size_t* _lidx = &__lidx;

	*ToSS = serMalloc(_mem, sizeof(struct SYSTEM_CTRL_CNF));
	_serSysDecSYSTEM_CTRL_CNF(_buffer, _size, _lidx, _mem, *ToSS);

	return SIDL_STATUS_OK;
}

static void _serSysFreeCnfAspCommonPart_Type(struct CnfAspCommonPart_Type* p)
{
	_serSysFreeRoutingInfo_Type(&p->RoutingInfo);
}

static void _serSysFreePdcp_CountCnf_Type_Value(union Pdcp_CountCnf_Type_Value* p, enum Pdcp_CountCnf_Type_Sel d)
{
	if (d == Pdcp_CountCnf_Type_Get) {
		if (p->Get.v) {
			for (size_t i1 = 0; i1 < p->Get.d; i1++) {
				_serSysFreePdcpCountInfo_Type(&p->Get.v[i1]);
			}
			serFree(p->Get.v);
		}
	}
}

static void _serSysFreePdcp_CountCnf_Type(struct Pdcp_CountCnf_Type* p)
{
	_serSysFreePdcp_CountCnf_Type_Value(&p->v, p->d);
}

static void _serSysFreeSystemConfirm_Type_Value(union SystemConfirm_Type_Value* p, enum SystemConfirm_Type_Sel d)
{
	if (d == SystemConfirm_Type_PdcpCount) {
		_serSysFreePdcp_CountCnf_Type(&p->PdcpCount);
	}
}

static void _serSysFreeSystemConfirm_Type(struct SystemConfirm_Type* p)
{
	_serSysFreeSystemConfirm_Type_Value(&p->v, p->d);
}

static void _serSysFreeSYSTEM_CTRL_CNF(struct SYSTEM_CTRL_CNF* p)
{
	_serSysFreeCnfAspCommonPart_Type(&p->Common);
	_serSysFreeSystemConfirm_Type(&p->Confirm);
}

void serSysProcessFreeClt(struct SYSTEM_CTRL_CNF* ToSS)
{
	if (ToSS) {
		_serSysFreeSYSTEM_CTRL_CNF(ToSS);
		serFree(ToSS);
	}
}
